<!-- Created by tixml2svd; https://github.com/dhoove/tixml2svd -->
<?xml version="1.0" encoding="utf-8"?>
<device>
  <name>CC2652</name>
  <version>1.1</version>
  <description>CC2652</description>
  <cpu>
    <name>CM4</name>
    <revision>r1p0</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <size>32</size>
  <access>read-write</access>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>AON_BATMON</name>
      <baseAddress>0x40095000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Always On (AON) Battery And Temperature MONitor (BATMON) residing in the AON domain  Note: This module only supports 32 bit Read/Write access from MCU.</description>
      <registers>
        <register>
          <name>CTL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CALC_EN</name>
              <description>[1:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MEAS_EN</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MEASCFG</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PER</name>
              <description>[1:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>32CYC</name>
                  <value>3</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>16CYC</name>
                  <value>2</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8CYC</name>
                  <value>1</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CONT</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TEMPP0</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CFG</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TEMPP1</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>CFG</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TEMPP2</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED5</name>
              <description>[31:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CFG</name>
              <description>[4:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>BATMONP0</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>CFG</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>BATMONP1</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>CFG</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IOSTRP0</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>CFG2</name>
              <description>[5:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CFG1</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x28</resetValue>
        </register>
        <register>
          <name>FLASHPUMPP0</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>FALLB</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>HIGHLIM</name>
              <description>[7:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>LOWLIM</name>
              <description>[5:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>OVR</name>
              <description>[4:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CFG</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>BAT</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Last Measured Battery Voltage

This register may be read while BATUPD.STAT = 1</description>
          <fields>
            <field>
              <name>RESERVED11</name>
              <description>[31:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>INT</name>
              <description>[10:8] Integer part:

0x0: 0V + fractional part
...
0x3: 3V + fractional part
0x4: 4V + fractional part</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FRAC</name>
              <description>[7:0] Fractional part, standard binary fractional encoding.

0x00: .0V
...
0x20: 1/8 = .125V
0x40: 1/4 = .25V
0x80: 1/2 = .5V
...
0xA0: 1/2 + 1/8 = .625V
...
0xFF: Max</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>BATUPD</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Battery Update

Indicates BAT Updates</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] 0: No update since last clear
1: New battery voltage is present.

Write 1 to clear the status.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TEMP</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Temperature

Last Measured Temperature in Degrees Celsius

This register may be read while TEMPUPD.STAT = 1.</description>
          <fields>
            <field>
              <name>RESERVED17</name>
              <description>[31:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>INT</name>
              <description>[16:8] Integer part (signed) of temperature value. 
Total value = INTEGER + FRACTIONAL
2's complement encoding

0x100: Min value
0x1D8: -40C
0x1FF: -1C
0x00: 0C
0x1B: 27C
0x55: 85C
0xFF: Max value</description>
              <bitWidth>9</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[7:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TEMPUPD</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Temperature Update

Indicates TEMP Updates</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] 0: No update since last clear
1: New temperature is present.

Write 1 to clear the status.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AON_EVENT</name>
      <baseAddress>0x40093000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <description>This module configures the event fabric located in the AON domain.

Note: This module is only supporting 32 bit ReadWrite access from MCU</description>
      <registers>
        <register>
          <name>MCUWUSEL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Wake-up Selector For MCU

This register contains pointers to 4 events which are routed to AON_WUC as wakeup sources for MCU. AON_WUC will start a wakeup sequence for the MCU domain when either of the 4 selected events are asserted. A wakeup sequence will guarantee that the MCU power switches are turned on, LDO resources are available and SCLK_HF is available and selected as clock source for MCU.

Note: It is recommended ( or required when AON_WUC:MCUCLK.PWR_DWN_SRC=NONE) to also setup a wakeup event here before MCU is requesting powerdown. ( PRCM requests uLDO, see conditions in PRCM:VDCTL.ULDO ) as it will speed up the wakeup procedure.</description>
          <fields>
            <field>
              <name>RESERVED30</name>
              <description>[31:30] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>WU3_EV</name>
              <description>[29:24] MCU Wakeup Source #3

AON Event Source selecting 1 of 4 events routed to AON_WUC for waking up the MCU domain from Power Off or Power Down.
Note:</description>
              <bitWidth>6</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>63</value>
                  <description>No event, always low</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC_N</name>
                  <value>56</value>
                  <description>Comparator B not triggered. Asynchronous signal directly from AUX Comparator B (inverted) as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC</name>
                  <value>55</value>
                  <description>Comparator B triggered. Asynchronous signal directly from the AUX Comparator B as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_VOLT</name>
                  <value>54</value>
                  <description>BATMON voltage update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_TEMP</name>
                  <value>53</value>
                  <description>BATMON temperature update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>52</value>
                  <description>AUX Timer 1 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>51</value>
                  <description>AUX Timer 0 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>50</value>
                  <description>TDC completed or timed out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>49</value>
                  <description>ADC conversion completed</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>48</value>
                  <description>Comparator B triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>47</value>
                  <description>Comparator A triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV2</name>
                  <value>46</value>
                  <description>AUX Software triggered event #2. Triggered by AUX_EVCTL:SWEVSET.SWEV2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>45</value>
                  <description>AUX Software triggered event #1. Triggered by AUX_EVCTL:SWEVSET.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV0</name>
                  <value>44</value>
                  <description>AUX Software triggered event #0. Triggered by AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>JTAG</name>
                  <value>43</value>
                  <description>JTAG generated event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_UPD</name>
                  <value>42</value>
                  <description>RTC Update Tick (16 kHz signal, i.e. event line toggles value every 32 kHz clock period)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_COMB_DLY</name>
                  <value>41</value>
                  <description>RTC combined delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_DLY</name>
                  <value>40</value>
                  <description>RTC channel 2 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1_DLY</name>
                  <value>39</value>
                  <description>RTC channel 1 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0_DLY</name>
                  <value>38</value>
                  <description>RTC channel 0 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2</name>
                  <value>37</value>
                  <description>RTC channel 2 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1</name>
                  <value>36</value>
                  <description>RTC channel 1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0</name>
                  <value>35</value>
                  <description>RTC channel 0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD</name>
                  <value>32</value>
                  <description>Edge detect on any PAD</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD31</name>
                  <value>31</value>
                  <description>Edge detect on PAD31</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD30</name>
                  <value>30</value>
                  <description>Edge detect on PAD30</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD29</name>
                  <value>29</value>
                  <description>Edge detect on PAD29</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD28</name>
                  <value>28</value>
                  <description>Edge detect on PAD28</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD27</name>
                  <value>27</value>
                  <description>Edge detect on PAD27</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD26</name>
                  <value>26</value>
                  <description>Edge detect on PAD26</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD25</name>
                  <value>25</value>
                  <description>Edge detect on PAD25</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD24</name>
                  <value>24</value>
                  <description>Edge detect on PAD24</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD23</name>
                  <value>23</value>
                  <description>Edge detect on PAD23</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD22</name>
                  <value>22</value>
                  <description>Edge detect on PAD22</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD21</name>
                  <value>21</value>
                  <description>Edge detect on PAD21</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD20</name>
                  <value>20</value>
                  <description>Edge detect on PAD20</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD19</name>
                  <value>19</value>
                  <description>Edge detect on PAD19</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD18</name>
                  <value>18</value>
                  <description>Edge detect on PAD18</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD17</name>
                  <value>17</value>
                  <description>Edge detect on PAD17</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD16</name>
                  <value>16</value>
                  <description>Edge detect on PAD16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD15</name>
                  <value>15</value>
                  <description>Edge detect on PAD15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD14</name>
                  <value>14</value>
                  <description>Edge detect on PAD14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD13</name>
                  <value>13</value>
                  <description>Edge detect on PAD13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD12</name>
                  <value>12</value>
                  <description>Edge detect on PAD12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD11</name>
                  <value>11</value>
                  <description>Edge detect on PAD11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD10</name>
                  <value>10</value>
                  <description>Edge detect on PAD10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD9</name>
                  <value>9</value>
                  <description>Edge detect on PAD9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD8</name>
                  <value>8</value>
                  <description>Edge detect on PAD8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD7</name>
                  <value>7</value>
                  <description>Edge detect on PAD7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD6</name>
                  <value>6</value>
                  <description>Edge detect on PAD6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD5</name>
                  <value>5</value>
                  <description>Edge detect on PAD5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD4</name>
                  <value>4</value>
                  <description>Edge detect on PAD4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD3</name>
                  <value>3</value>
                  <description>Edge detect on PAD3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD2</name>
                  <value>2</value>
                  <description>Edge detect on PAD2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD1</name>
                  <value>1</value>
                  <description>Edge detect on PAD1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD0</name>
                  <value>0</value>
                  <description>Edge detect on PAD0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED22</name>
              <description>[23:22] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>WU2_EV</name>
              <description>[21:16] MCU Wakeup Source #2

AON Event Source selecting 1 of 4 events routed to AON_WUC for waking up the MCU domain from Power Off or Power Down.
Note:</description>
              <bitWidth>6</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>63</value>
                  <description>No event, always low</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC_N</name>
                  <value>56</value>
                  <description>Comparator B not triggered. Asynchronous signal directly from AUX Comparator B (inverted) as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC</name>
                  <value>55</value>
                  <description>Comparator B triggered. Asynchronous signal directly from the AUX Comparator B as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_VOLT</name>
                  <value>54</value>
                  <description>BATMON voltage update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_TEMP</name>
                  <value>53</value>
                  <description>BATMON temperature update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>52</value>
                  <description>AUX Timer 1 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>51</value>
                  <description>AUX Timer 0 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>50</value>
                  <description>TDC completed or timed out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>49</value>
                  <description>ADC conversion completed</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>48</value>
                  <description>Comparator B triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>47</value>
                  <description>Comparator A triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV2</name>
                  <value>46</value>
                  <description>AUX Software triggered event #2. Triggered by AUX_EVCTL:SWEVSET.SWEV2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>45</value>
                  <description>AUX Software triggered event #1. Triggered by AUX_EVCTL:SWEVSET.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV0</name>
                  <value>44</value>
                  <description>AUX Software triggered event #0. Triggered by AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>JTAG</name>
                  <value>43</value>
                  <description>JTAG generated event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_UPD</name>
                  <value>42</value>
                  <description>RTC Update Tick (16 kHz signal, i.e. event line toggles value every 32 kHz clock period)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_COMB_DLY</name>
                  <value>41</value>
                  <description>RTC combined delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_DLY</name>
                  <value>40</value>
                  <description>RTC channel 2 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1_DLY</name>
                  <value>39</value>
                  <description>RTC channel 1 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0_DLY</name>
                  <value>38</value>
                  <description>RTC channel 0 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2</name>
                  <value>37</value>
                  <description>RTC channel 2 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1</name>
                  <value>36</value>
                  <description>RTC channel 1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0</name>
                  <value>35</value>
                  <description>RTC channel 0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD</name>
                  <value>32</value>
                  <description>Edge detect on any PAD</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD31</name>
                  <value>31</value>
                  <description>Edge detect on PAD31</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD30</name>
                  <value>30</value>
                  <description>Edge detect on PAD30</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD29</name>
                  <value>29</value>
                  <description>Edge detect on PAD29</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD28</name>
                  <value>28</value>
                  <description>Edge detect on PAD28</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD27</name>
                  <value>27</value>
                  <description>Edge detect on PAD27</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD26</name>
                  <value>26</value>
                  <description>Edge detect on PAD26</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD25</name>
                  <value>25</value>
                  <description>Edge detect on PAD25</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD24</name>
                  <value>24</value>
                  <description>Edge detect on PAD24</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD23</name>
                  <value>23</value>
                  <description>Edge detect on PAD23</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD22</name>
                  <value>22</value>
                  <description>Edge detect on PAD22</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD21</name>
                  <value>21</value>
                  <description>Edge detect on PAD21</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD20</name>
                  <value>20</value>
                  <description>Edge detect on PAD20</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD19</name>
                  <value>19</value>
                  <description>Edge detect on PAD19</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD18</name>
                  <value>18</value>
                  <description>Edge detect on PAD18</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD17</name>
                  <value>17</value>
                  <description>Edge detect on PAD17</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD16</name>
                  <value>16</value>
                  <description>Edge detect on PAD16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD15</name>
                  <value>15</value>
                  <description>Edge detect on PAD15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD14</name>
                  <value>14</value>
                  <description>Edge detect on PAD14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD13</name>
                  <value>13</value>
                  <description>Edge detect on PAD13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD12</name>
                  <value>12</value>
                  <description>Edge detect on PAD12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD11</name>
                  <value>11</value>
                  <description>Edge detect on PAD11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD10</name>
                  <value>10</value>
                  <description>Edge detect on PAD10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD9</name>
                  <value>9</value>
                  <description>Edge detect on PAD9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD8</name>
                  <value>8</value>
                  <description>Edge detect on PAD8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD7</name>
                  <value>7</value>
                  <description>Edge detect on PAD7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD6</name>
                  <value>6</value>
                  <description>Edge detect on PAD6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD5</name>
                  <value>5</value>
                  <description>Edge detect on PAD5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD4</name>
                  <value>4</value>
                  <description>Edge detect on PAD4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD3</name>
                  <value>3</value>
                  <description>Edge detect on PAD3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD2</name>
                  <value>2</value>
                  <description>Edge detect on PAD2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD1</name>
                  <value>1</value>
                  <description>Edge detect on PAD1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD0</name>
                  <value>0</value>
                  <description>Edge detect on PAD0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED14</name>
              <description>[15:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>WU1_EV</name>
              <description>[13:8] MCU Wakeup Source #1

AON Event Source selecting 1 of 4 events routed to AON_WUC for waking up the MCU domain from Power Off or Power Down.
Note:</description>
              <bitWidth>6</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>63</value>
                  <description>No event, always low</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC_N</name>
                  <value>56</value>
                  <description>Comparator B not triggered. Asynchronous signal directly from AUX Comparator B (inverted) as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC</name>
                  <value>55</value>
                  <description>Comparator B triggered. Asynchronous signal directly from the AUX Comparator B as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_VOLT</name>
                  <value>54</value>
                  <description>BATMON voltage update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_TEMP</name>
                  <value>53</value>
                  <description>BATMON temperature update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>52</value>
                  <description>AUX Timer 1 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>51</value>
                  <description>AUX Timer 0 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>50</value>
                  <description>TDC completed or timed out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>49</value>
                  <description>ADC conversion completed</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>48</value>
                  <description>Comparator B triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>47</value>
                  <description>Comparator A triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV2</name>
                  <value>46</value>
                  <description>AUX Software triggered event #2. Triggered by AUX_EVCTL:SWEVSET.SWEV2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>45</value>
                  <description>AUX Software triggered event #1. Triggered by AUX_EVCTL:SWEVSET.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV0</name>
                  <value>44</value>
                  <description>AUX Software triggered event #0. Triggered by AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>JTAG</name>
                  <value>43</value>
                  <description>JTAG generated event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_UPD</name>
                  <value>42</value>
                  <description>RTC Update Tick (16 kHz signal, i.e. event line toggles value every 32 kHz clock period)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_COMB_DLY</name>
                  <value>41</value>
                  <description>RTC combined delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_DLY</name>
                  <value>40</value>
                  <description>RTC channel 2 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1_DLY</name>
                  <value>39</value>
                  <description>RTC channel 1 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0_DLY</name>
                  <value>38</value>
                  <description>RTC channel 0 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2</name>
                  <value>37</value>
                  <description>RTC channel 2 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1</name>
                  <value>36</value>
                  <description>RTC channel 1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0</name>
                  <value>35</value>
                  <description>RTC channel 0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD</name>
                  <value>32</value>
                  <description>Edge detect on any PAD</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD31</name>
                  <value>31</value>
                  <description>Edge detect on PAD31</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD30</name>
                  <value>30</value>
                  <description>Edge detect on PAD30</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD29</name>
                  <value>29</value>
                  <description>Edge detect on PAD29</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD28</name>
                  <value>28</value>
                  <description>Edge detect on PAD28</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD27</name>
                  <value>27</value>
                  <description>Edge detect on PAD27</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD26</name>
                  <value>26</value>
                  <description>Edge detect on PAD26</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD25</name>
                  <value>25</value>
                  <description>Edge detect on PAD25</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD24</name>
                  <value>24</value>
                  <description>Edge detect on PAD24</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD23</name>
                  <value>23</value>
                  <description>Edge detect on PAD23</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD22</name>
                  <value>22</value>
                  <description>Edge detect on PAD22</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD21</name>
                  <value>21</value>
                  <description>Edge detect on PAD21</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD20</name>
                  <value>20</value>
                  <description>Edge detect on PAD20</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD19</name>
                  <value>19</value>
                  <description>Edge detect on PAD19</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD18</name>
                  <value>18</value>
                  <description>Edge detect on PAD18</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD17</name>
                  <value>17</value>
                  <description>Edge detect on PAD17</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD16</name>
                  <value>16</value>
                  <description>Edge detect on PAD16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD15</name>
                  <value>15</value>
                  <description>Edge detect on PAD15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD14</name>
                  <value>14</value>
                  <description>Edge detect on PAD14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD13</name>
                  <value>13</value>
                  <description>Edge detect on PAD13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD12</name>
                  <value>12</value>
                  <description>Edge detect on PAD12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD11</name>
                  <value>11</value>
                  <description>Edge detect on PAD11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD10</name>
                  <value>10</value>
                  <description>Edge detect on PAD10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD9</name>
                  <value>9</value>
                  <description>Edge detect on PAD9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD8</name>
                  <value>8</value>
                  <description>Edge detect on PAD8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD7</name>
                  <value>7</value>
                  <description>Edge detect on PAD7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD6</name>
                  <value>6</value>
                  <description>Edge detect on PAD6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD5</name>
                  <value>5</value>
                  <description>Edge detect on PAD5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD4</name>
                  <value>4</value>
                  <description>Edge detect on PAD4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD3</name>
                  <value>3</value>
                  <description>Edge detect on PAD3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD2</name>
                  <value>2</value>
                  <description>Edge detect on PAD2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD1</name>
                  <value>1</value>
                  <description>Edge detect on PAD1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD0</name>
                  <value>0</value>
                  <description>Edge detect on PAD0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>WU0_EV</name>
              <description>[5:0] MCU Wakeup Source #0

AON Event Source selecting 1 of 4 events routed to AON_WUC for waking up the MCU domain from Power Off or Power Down.
Note:</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>63</value>
                  <description>No event, always low</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC_N</name>
                  <value>56</value>
                  <description>Comparator B not triggered. Asynchronous signal directly from AUX Comparator B (inverted) as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC</name>
                  <value>55</value>
                  <description>Comparator B triggered. Asynchronous signal directly from the AUX Comparator B as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_VOLT</name>
                  <value>54</value>
                  <description>BATMON voltage update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_TEMP</name>
                  <value>53</value>
                  <description>BATMON temperature update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>52</value>
                  <description>AUX Timer 1 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>51</value>
                  <description>AUX Timer 0 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>50</value>
                  <description>TDC completed or timed out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>49</value>
                  <description>ADC conversion completed</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>48</value>
                  <description>Comparator B triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>47</value>
                  <description>Comparator A triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV2</name>
                  <value>46</value>
                  <description>AUX Software triggered event #2. Triggered by AUX_EVCTL:SWEVSET.SWEV2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>45</value>
                  <description>AUX Software triggered event #1. Triggered by AUX_EVCTL:SWEVSET.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV0</name>
                  <value>44</value>
                  <description>AUX Software triggered event #0. Triggered by AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>JTAG</name>
                  <value>43</value>
                  <description>JTAG generated event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_UPD</name>
                  <value>42</value>
                  <description>RTC Update Tick (16 kHz signal, i.e. event line toggles value every 32 kHz clock period)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_COMB_DLY</name>
                  <value>41</value>
                  <description>RTC combined delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_DLY</name>
                  <value>40</value>
                  <description>RTC channel 2 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1_DLY</name>
                  <value>39</value>
                  <description>RTC channel 1 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0_DLY</name>
                  <value>38</value>
                  <description>RTC channel 0 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2</name>
                  <value>37</value>
                  <description>RTC channel 2 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1</name>
                  <value>36</value>
                  <description>RTC channel 1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0</name>
                  <value>35</value>
                  <description>RTC channel 0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD</name>
                  <value>32</value>
                  <description>Edge detect on any PAD</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD31</name>
                  <value>31</value>
                  <description>Edge detect on PAD31</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD30</name>
                  <value>30</value>
                  <description>Edge detect on PAD30</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD29</name>
                  <value>29</value>
                  <description>Edge detect on PAD29</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD28</name>
                  <value>28</value>
                  <description>Edge detect on PAD28</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD27</name>
                  <value>27</value>
                  <description>Edge detect on PAD27</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD26</name>
                  <value>26</value>
                  <description>Edge detect on PAD26</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD25</name>
                  <value>25</value>
                  <description>Edge detect on PAD25</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD24</name>
                  <value>24</value>
                  <description>Edge detect on PAD24</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD23</name>
                  <value>23</value>
                  <description>Edge detect on PAD23</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD22</name>
                  <value>22</value>
                  <description>Edge detect on PAD22</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD21</name>
                  <value>21</value>
                  <description>Edge detect on PAD21</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD20</name>
                  <value>20</value>
                  <description>Edge detect on PAD20</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD19</name>
                  <value>19</value>
                  <description>Edge detect on PAD19</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD18</name>
                  <value>18</value>
                  <description>Edge detect on PAD18</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD17</name>
                  <value>17</value>
                  <description>Edge detect on PAD17</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD16</name>
                  <value>16</value>
                  <description>Edge detect on PAD16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD15</name>
                  <value>15</value>
                  <description>Edge detect on PAD15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD14</name>
                  <value>14</value>
                  <description>Edge detect on PAD14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD13</name>
                  <value>13</value>
                  <description>Edge detect on PAD13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD12</name>
                  <value>12</value>
                  <description>Edge detect on PAD12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD11</name>
                  <value>11</value>
                  <description>Edge detect on PAD11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD10</name>
                  <value>10</value>
                  <description>Edge detect on PAD10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD9</name>
                  <value>9</value>
                  <description>Edge detect on PAD9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD8</name>
                  <value>8</value>
                  <description>Edge detect on PAD8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD7</name>
                  <value>7</value>
                  <description>Edge detect on PAD7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD6</name>
                  <value>6</value>
                  <description>Edge detect on PAD6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD5</name>
                  <value>5</value>
                  <description>Edge detect on PAD5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD4</name>
                  <value>4</value>
                  <description>Edge detect on PAD4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD3</name>
                  <value>3</value>
                  <description>Edge detect on PAD3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD2</name>
                  <value>2</value>
                  <description>Edge detect on PAD2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD1</name>
                  <value>1</value>
                  <description>Edge detect on PAD1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD0</name>
                  <value>0</value>
                  <description>Edge detect on PAD0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x3F3F3F3F</resetValue>
        </register>
        <register>
          <name>AUXWUSEL</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Wake-up Selector For AUX

This register contains pointers to 3 events which are routed to AON_WUC as wakeup sources for AUX. AON_WUC will start a wakeup sequence for the AUX domain when either of the 3 selected events are asserted. A wakeup sequence will guarantee that the AUX power switches are turned on, LDO resources are available and SCLK_HF is available and selected as clock source for AUX.

Note: It is recommended ( or required when AON_WUC:AUXCLK.PWR_DWN_SRC=NONE) to also setup a wakeup event here before AUX is requesting powerdown. ( AUX_WUC:PWRDWNREQ.REQ is asserted] ) as it will speed up the wakeup procedure.</description>
          <fields>
            <field>
              <name>RESERVED22</name>
              <description>[31:22] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>WU2_EV</name>
              <description>[21:16] AUX Wakeup Source #2

AON Event Source selecting 1 of 3 events routed to AON_WUC for waking up the AUX domain from Power Off or Power Down.
Note:</description>
              <bitWidth>6</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>63</value>
                  <description>No event, always low</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC_N</name>
                  <value>56</value>
                  <description>Comparator B not triggered. Asynchronous signal directly from AUX Comparator B (inverted) as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC</name>
                  <value>55</value>
                  <description>Comparator B triggered. Asynchronous signal directly from the AUX Comparator B as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_VOLT</name>
                  <value>54</value>
                  <description>BATMON voltage update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_TEMP</name>
                  <value>53</value>
                  <description>BATMON temperature update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>52</value>
                  <description>AUX Timer 1 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>51</value>
                  <description>AUX Timer 0 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>50</value>
                  <description>TDC completed or timed out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>49</value>
                  <description>ADC conversion completed</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>48</value>
                  <description>Comparator B triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>47</value>
                  <description>Comparator A triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV2</name>
                  <value>46</value>
                  <description>AUX Software triggered event #2. Triggered by AUX_EVCTL:SWEVSET.SWEV2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>45</value>
                  <description>AUX Software triggered event #1. Triggered by AUX_EVCTL:SWEVSET.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV0</name>
                  <value>44</value>
                  <description>AUX Software triggered event #0. Triggered by AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>JTAG</name>
                  <value>43</value>
                  <description>JTAG generated event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_UPD</name>
                  <value>42</value>
                  <description>RTC Update Tick (16 kHz signal, i.e. event line toggles value every 32 kHz clock period)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_COMB_DLY</name>
                  <value>41</value>
                  <description>RTC combined delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_DLY</name>
                  <value>40</value>
                  <description>RTC channel 2 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1_DLY</name>
                  <value>39</value>
                  <description>RTC channel 1 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0_DLY</name>
                  <value>38</value>
                  <description>RTC channel 0 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2</name>
                  <value>37</value>
                  <description>RTC channel 2 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1</name>
                  <value>36</value>
                  <description>RTC channel 1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0</name>
                  <value>35</value>
                  <description>RTC channel 0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD</name>
                  <value>32</value>
                  <description>Edge detect on any PAD</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD31</name>
                  <value>31</value>
                  <description>Edge detect on PAD31</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD30</name>
                  <value>30</value>
                  <description>Edge detect on PAD30</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD29</name>
                  <value>29</value>
                  <description>Edge detect on PAD29</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD28</name>
                  <value>28</value>
                  <description>Edge detect on PAD28</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD27</name>
                  <value>27</value>
                  <description>Edge detect on PAD27</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD26</name>
                  <value>26</value>
                  <description>Edge detect on PAD26</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD25</name>
                  <value>25</value>
                  <description>Edge detect on PAD25</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD24</name>
                  <value>24</value>
                  <description>Edge detect on PAD24</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD23</name>
                  <value>23</value>
                  <description>Edge detect on PAD23</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD22</name>
                  <value>22</value>
                  <description>Edge detect on PAD22</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD21</name>
                  <value>21</value>
                  <description>Edge detect on PAD21</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD20</name>
                  <value>20</value>
                  <description>Edge detect on PAD20</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD19</name>
                  <value>19</value>
                  <description>Edge detect on PAD19</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD18</name>
                  <value>18</value>
                  <description>Edge detect on PAD18</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD17</name>
                  <value>17</value>
                  <description>Edge detect on PAD17</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD16</name>
                  <value>16</value>
                  <description>Edge detect on PAD16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD15</name>
                  <value>15</value>
                  <description>Edge detect on PAD15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD14</name>
                  <value>14</value>
                  <description>Edge detect on PAD14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD13</name>
                  <value>13</value>
                  <description>Edge detect on PAD13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD12</name>
                  <value>12</value>
                  <description>Edge detect on PAD12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD11</name>
                  <value>11</value>
                  <description>Edge detect on PAD11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD10</name>
                  <value>10</value>
                  <description>Edge detect on PAD10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD9</name>
                  <value>9</value>
                  <description>Edge detect on PAD9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD8</name>
                  <value>8</value>
                  <description>Edge detect on PAD8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD7</name>
                  <value>7</value>
                  <description>Edge detect on PAD7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD6</name>
                  <value>6</value>
                  <description>Edge detect on PAD6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD5</name>
                  <value>5</value>
                  <description>Edge detect on PAD5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD4</name>
                  <value>4</value>
                  <description>Edge detect on PAD4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD3</name>
                  <value>3</value>
                  <description>Edge detect on PAD3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD2</name>
                  <value>2</value>
                  <description>Edge detect on PAD2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD1</name>
                  <value>1</value>
                  <description>Edge detect on PAD1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD0</name>
                  <value>0</value>
                  <description>Edge detect on PAD0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED14</name>
              <description>[15:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>WU1_EV</name>
              <description>[13:8] AUX Wakeup Source #1

AON Event Source selecting 1 of 3 events routed to AON_WUC for waking up the AUX domain from Power Off or Power Down.
Note:</description>
              <bitWidth>6</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>63</value>
                  <description>No event, always low</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC_N</name>
                  <value>56</value>
                  <description>Comparator B not triggered. Asynchronous signal directly from AUX Comparator B (inverted) as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC</name>
                  <value>55</value>
                  <description>Comparator B triggered. Asynchronous signal directly from the AUX Comparator B as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_VOLT</name>
                  <value>54</value>
                  <description>BATMON voltage update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_TEMP</name>
                  <value>53</value>
                  <description>BATMON temperature update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>52</value>
                  <description>AUX Timer 1 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>51</value>
                  <description>AUX Timer 0 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>50</value>
                  <description>TDC completed or timed out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>49</value>
                  <description>ADC conversion completed</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>48</value>
                  <description>Comparator B triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>47</value>
                  <description>Comparator A triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV2</name>
                  <value>46</value>
                  <description>AUX Software triggered event #2. Triggered by AUX_EVCTL:SWEVSET.SWEV2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>45</value>
                  <description>AUX Software triggered event #1. Triggered by AUX_EVCTL:SWEVSET.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV0</name>
                  <value>44</value>
                  <description>AUX Software triggered event #0. Triggered by AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>JTAG</name>
                  <value>43</value>
                  <description>JTAG generated event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_UPD</name>
                  <value>42</value>
                  <description>RTC Update Tick (16 kHz signal, i.e. event line toggles value every 32 kHz clock period)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_COMB_DLY</name>
                  <value>41</value>
                  <description>RTC combined delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_DLY</name>
                  <value>40</value>
                  <description>RTC channel 2 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1_DLY</name>
                  <value>39</value>
                  <description>RTC channel 1 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0_DLY</name>
                  <value>38</value>
                  <description>RTC channel 0 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2</name>
                  <value>37</value>
                  <description>RTC channel 2 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1</name>
                  <value>36</value>
                  <description>RTC channel 1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0</name>
                  <value>35</value>
                  <description>RTC channel 0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD</name>
                  <value>32</value>
                  <description>Edge detect on any PAD</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD31</name>
                  <value>31</value>
                  <description>Edge detect on PAD31</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD30</name>
                  <value>30</value>
                  <description>Edge detect on PAD30</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD29</name>
                  <value>29</value>
                  <description>Edge detect on PAD29</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD28</name>
                  <value>28</value>
                  <description>Edge detect on PAD28</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD27</name>
                  <value>27</value>
                  <description>Edge detect on PAD27</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD26</name>
                  <value>26</value>
                  <description>Edge detect on PAD26</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD25</name>
                  <value>25</value>
                  <description>Edge detect on PAD25</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD24</name>
                  <value>24</value>
                  <description>Edge detect on PAD24</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD23</name>
                  <value>23</value>
                  <description>Edge detect on PAD23</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD22</name>
                  <value>22</value>
                  <description>Edge detect on PAD22</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD21</name>
                  <value>21</value>
                  <description>Edge detect on PAD21</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD20</name>
                  <value>20</value>
                  <description>Edge detect on PAD20</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD19</name>
                  <value>19</value>
                  <description>Edge detect on PAD19</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD18</name>
                  <value>18</value>
                  <description>Edge detect on PAD18</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD17</name>
                  <value>17</value>
                  <description>Edge detect on PAD17</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD16</name>
                  <value>16</value>
                  <description>Edge detect on PAD16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD15</name>
                  <value>15</value>
                  <description>Edge detect on PAD15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD14</name>
                  <value>14</value>
                  <description>Edge detect on PAD14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD13</name>
                  <value>13</value>
                  <description>Edge detect on PAD13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD12</name>
                  <value>12</value>
                  <description>Edge detect on PAD12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD11</name>
                  <value>11</value>
                  <description>Edge detect on PAD11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD10</name>
                  <value>10</value>
                  <description>Edge detect on PAD10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD9</name>
                  <value>9</value>
                  <description>Edge detect on PAD9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD8</name>
                  <value>8</value>
                  <description>Edge detect on PAD8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD7</name>
                  <value>7</value>
                  <description>Edge detect on PAD7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD6</name>
                  <value>6</value>
                  <description>Edge detect on PAD6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD5</name>
                  <value>5</value>
                  <description>Edge detect on PAD5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD4</name>
                  <value>4</value>
                  <description>Edge detect on PAD4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD3</name>
                  <value>3</value>
                  <description>Edge detect on PAD3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD2</name>
                  <value>2</value>
                  <description>Edge detect on PAD2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD1</name>
                  <value>1</value>
                  <description>Edge detect on PAD1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD0</name>
                  <value>0</value>
                  <description>Edge detect on PAD0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>WU0_EV</name>
              <description>[5:0] AUX Wakeup Source #0

AON Event Source selecting 1 of 3 events routed to AON_WUC for waking up the AUX domain from Power Off or Power Down.
Note:</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>63</value>
                  <description>No event, always low</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC_N</name>
                  <value>56</value>
                  <description>Comparator B not triggered. Asynchronous signal directly from AUX Comparator B (inverted) as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC</name>
                  <value>55</value>
                  <description>Comparator B triggered. Asynchronous signal directly from the AUX Comparator B as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_VOLT</name>
                  <value>54</value>
                  <description>BATMON voltage update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_TEMP</name>
                  <value>53</value>
                  <description>BATMON temperature update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>52</value>
                  <description>AUX Timer 1 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>51</value>
                  <description>AUX Timer 0 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>50</value>
                  <description>TDC completed or timed out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>49</value>
                  <description>ADC conversion completed</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>48</value>
                  <description>Comparator B triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>47</value>
                  <description>Comparator A triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV2</name>
                  <value>46</value>
                  <description>AUX Software triggered event #2. Triggered by AUX_EVCTL:SWEVSET.SWEV2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>45</value>
                  <description>AUX Software triggered event #1. Triggered by AUX_EVCTL:SWEVSET.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV0</name>
                  <value>44</value>
                  <description>AUX Software triggered event #0. Triggered by AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>JTAG</name>
                  <value>43</value>
                  <description>JTAG generated event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_UPD</name>
                  <value>42</value>
                  <description>RTC Update Tick (16 kHz signal, i.e. event line toggles value every 32 kHz clock period)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_COMB_DLY</name>
                  <value>41</value>
                  <description>RTC combined delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_DLY</name>
                  <value>40</value>
                  <description>RTC channel 2 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1_DLY</name>
                  <value>39</value>
                  <description>RTC channel 1 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0_DLY</name>
                  <value>38</value>
                  <description>RTC channel 0 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2</name>
                  <value>37</value>
                  <description>RTC channel 2 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1</name>
                  <value>36</value>
                  <description>RTC channel 1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0</name>
                  <value>35</value>
                  <description>RTC channel 0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD</name>
                  <value>32</value>
                  <description>Edge detect on any PAD</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD31</name>
                  <value>31</value>
                  <description>Edge detect on PAD31</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD30</name>
                  <value>30</value>
                  <description>Edge detect on PAD30</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD29</name>
                  <value>29</value>
                  <description>Edge detect on PAD29</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD28</name>
                  <value>28</value>
                  <description>Edge detect on PAD28</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD27</name>
                  <value>27</value>
                  <description>Edge detect on PAD27</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD26</name>
                  <value>26</value>
                  <description>Edge detect on PAD26</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD25</name>
                  <value>25</value>
                  <description>Edge detect on PAD25</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD24</name>
                  <value>24</value>
                  <description>Edge detect on PAD24</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD23</name>
                  <value>23</value>
                  <description>Edge detect on PAD23</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD22</name>
                  <value>22</value>
                  <description>Edge detect on PAD22</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD21</name>
                  <value>21</value>
                  <description>Edge detect on PAD21</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD20</name>
                  <value>20</value>
                  <description>Edge detect on PAD20</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD19</name>
                  <value>19</value>
                  <description>Edge detect on PAD19</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD18</name>
                  <value>18</value>
                  <description>Edge detect on PAD18</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD17</name>
                  <value>17</value>
                  <description>Edge detect on PAD17</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD16</name>
                  <value>16</value>
                  <description>Edge detect on PAD16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD15</name>
                  <value>15</value>
                  <description>Edge detect on PAD15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD14</name>
                  <value>14</value>
                  <description>Edge detect on PAD14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD13</name>
                  <value>13</value>
                  <description>Edge detect on PAD13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD12</name>
                  <value>12</value>
                  <description>Edge detect on PAD12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD11</name>
                  <value>11</value>
                  <description>Edge detect on PAD11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD10</name>
                  <value>10</value>
                  <description>Edge detect on PAD10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD9</name>
                  <value>9</value>
                  <description>Edge detect on PAD9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD8</name>
                  <value>8</value>
                  <description>Edge detect on PAD8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD7</name>
                  <value>7</value>
                  <description>Edge detect on PAD7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD6</name>
                  <value>6</value>
                  <description>Edge detect on PAD6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD5</name>
                  <value>5</value>
                  <description>Edge detect on PAD5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD4</name>
                  <value>4</value>
                  <description>Edge detect on PAD4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD3</name>
                  <value>3</value>
                  <description>Edge detect on PAD3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD2</name>
                  <value>2</value>
                  <description>Edge detect on PAD2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD1</name>
                  <value>1</value>
                  <description>Edge detect on PAD1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD0</name>
                  <value>0</value>
                  <description>Edge detect on PAD0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x3F3F3F</resetValue>
        </register>
        <register>
          <name>EVTOMCUSEL</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Event Selector For MCU Event Fabric 

This register contains pointers for 3 AON events that are routed to the MCU Event Fabric EVENT</description>
          <fields>
            <field>
              <name>RESERVED22</name>
              <description>[31:22] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>AON_PROG2_EV</name>
              <description>[21:16] Event selector for AON_PROG2 event.

AON Event Source id# selecting event routed to EVENT as AON_PROG2 event.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>63</value>
                  <description>No event, always low</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC_N</name>
                  <value>56</value>
                  <description>Comparator B not triggered. Asynchronous signal directly from AUX Comparator B (inverted) as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC</name>
                  <value>55</value>
                  <description>Comparator B triggered. Asynchronous signal directly from the AUX Comparator B as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_VOLT</name>
                  <value>54</value>
                  <description>BATMON voltage update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_TEMP</name>
                  <value>53</value>
                  <description>BATMON temperature update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>52</value>
                  <description>AUX Timer 1 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>51</value>
                  <description>AUX Timer 0 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>50</value>
                  <description>TDC completed or timed out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>49</value>
                  <description>ADC conversion completed</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>48</value>
                  <description>Comparator B triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>47</value>
                  <description>Comparator A triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV2</name>
                  <value>46</value>
                  <description>AUX Software triggered event #2. Triggered by AUX_EVCTL:SWEVSET.SWEV2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>45</value>
                  <description>AUX Software triggered event #1. Triggered by AUX_EVCTL:SWEVSET.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV0</name>
                  <value>44</value>
                  <description>AUX Software triggered event #0. Triggered by AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>JTAG</name>
                  <value>43</value>
                  <description>JTAG generated event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_UPD</name>
                  <value>42</value>
                  <description>RTC Update Tick (16 kHz signal, i.e. event line toggles value every 32 kHz clock period)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_COMB_DLY</name>
                  <value>41</value>
                  <description>RTC combined delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_DLY</name>
                  <value>40</value>
                  <description>RTC channel 2 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1_DLY</name>
                  <value>39</value>
                  <description>RTC channel 1 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0_DLY</name>
                  <value>38</value>
                  <description>RTC channel 0 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2</name>
                  <value>37</value>
                  <description>RTC channel 2 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1</name>
                  <value>36</value>
                  <description>RTC channel 1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0</name>
                  <value>35</value>
                  <description>RTC channel 0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD</name>
                  <value>32</value>
                  <description>Edge detect on any PAD</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD31</name>
                  <value>31</value>
                  <description>Edge detect on PAD31</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD30</name>
                  <value>30</value>
                  <description>Edge detect on PAD30</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD29</name>
                  <value>29</value>
                  <description>Edge detect on PAD29</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD28</name>
                  <value>28</value>
                  <description>Edge detect on PAD28</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD27</name>
                  <value>27</value>
                  <description>Edge detect on PAD27</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD26</name>
                  <value>26</value>
                  <description>Edge detect on PAD26</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD25</name>
                  <value>25</value>
                  <description>Edge detect on PAD25</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD24</name>
                  <value>24</value>
                  <description>Edge detect on PAD24</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD23</name>
                  <value>23</value>
                  <description>Edge detect on PAD23</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD22</name>
                  <value>22</value>
                  <description>Edge detect on PAD22</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD21</name>
                  <value>21</value>
                  <description>Edge detect on PAD21</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD20</name>
                  <value>20</value>
                  <description>Edge detect on PAD20</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD19</name>
                  <value>19</value>
                  <description>Edge detect on PAD19</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD18</name>
                  <value>18</value>
                  <description>Edge detect on PAD18</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD17</name>
                  <value>17</value>
                  <description>Edge detect on PAD17</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD16</name>
                  <value>16</value>
                  <description>Edge detect on PAD16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD15</name>
                  <value>15</value>
                  <description>Edge detect on PAD15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD14</name>
                  <value>14</value>
                  <description>Edge detect on PAD14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD13</name>
                  <value>13</value>
                  <description>Edge detect on PAD13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD12</name>
                  <value>12</value>
                  <description>Edge detect on PAD12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD11</name>
                  <value>11</value>
                  <description>Edge detect on PAD11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD10</name>
                  <value>10</value>
                  <description>Edge detect on PAD10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD9</name>
                  <value>9</value>
                  <description>Edge detect on PAD9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD8</name>
                  <value>8</value>
                  <description>Edge detect on PAD8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD7</name>
                  <value>7</value>
                  <description>Edge detect on PAD7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD6</name>
                  <value>6</value>
                  <description>Edge detect on PAD6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD5</name>
                  <value>5</value>
                  <description>Edge detect on PAD5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD4</name>
                  <value>4</value>
                  <description>Edge detect on PAD4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD3</name>
                  <value>3</value>
                  <description>Edge detect on PAD3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD2</name>
                  <value>2</value>
                  <description>Edge detect on PAD2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD1</name>
                  <value>1</value>
                  <description>Edge detect on PAD1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD0</name>
                  <value>0</value>
                  <description>Edge detect on PAD0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED14</name>
              <description>[15:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>AON_PROG1_EV</name>
              <description>[13:8] Event selector for AON_PROG1 event.

AON Event Source id# selecting event routed to EVENT as AON_PROG1 event.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>63</value>
                  <description>No event, always low</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC_N</name>
                  <value>56</value>
                  <description>Comparator B not triggered. Asynchronous signal directly from AUX Comparator B (inverted) as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC</name>
                  <value>55</value>
                  <description>Comparator B triggered. Asynchronous signal directly from the AUX Comparator B as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_VOLT</name>
                  <value>54</value>
                  <description>BATMON voltage update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_TEMP</name>
                  <value>53</value>
                  <description>BATMON temperature update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>52</value>
                  <description>AUX Timer 1 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>51</value>
                  <description>AUX Timer 0 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>50</value>
                  <description>TDC completed or timed out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>49</value>
                  <description>ADC conversion completed</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>48</value>
                  <description>Comparator B triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>47</value>
                  <description>Comparator A triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV2</name>
                  <value>46</value>
                  <description>AUX Software triggered event #2. Triggered by AUX_EVCTL:SWEVSET.SWEV2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>45</value>
                  <description>AUX Software triggered event #1. Triggered by AUX_EVCTL:SWEVSET.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV0</name>
                  <value>44</value>
                  <description>AUX Software triggered event #0. Triggered by AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>JTAG</name>
                  <value>43</value>
                  <description>JTAG generated event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_UPD</name>
                  <value>42</value>
                  <description>RTC Update Tick (16 kHz signal, i.e. event line toggles value every 32 kHz clock period)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_COMB_DLY</name>
                  <value>41</value>
                  <description>RTC combined delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_DLY</name>
                  <value>40</value>
                  <description>RTC channel 2 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1_DLY</name>
                  <value>39</value>
                  <description>RTC channel 1 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0_DLY</name>
                  <value>38</value>
                  <description>RTC channel 0 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2</name>
                  <value>37</value>
                  <description>RTC channel 2 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1</name>
                  <value>36</value>
                  <description>RTC channel 1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0</name>
                  <value>35</value>
                  <description>RTC channel 0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD</name>
                  <value>32</value>
                  <description>Edge detect on any PAD</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD31</name>
                  <value>31</value>
                  <description>Edge detect on PAD31</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD30</name>
                  <value>30</value>
                  <description>Edge detect on PAD30</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD29</name>
                  <value>29</value>
                  <description>Edge detect on PAD29</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD28</name>
                  <value>28</value>
                  <description>Edge detect on PAD28</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD27</name>
                  <value>27</value>
                  <description>Edge detect on PAD27</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD26</name>
                  <value>26</value>
                  <description>Edge detect on PAD26</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD25</name>
                  <value>25</value>
                  <description>Edge detect on PAD25</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD24</name>
                  <value>24</value>
                  <description>Edge detect on PAD24</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD23</name>
                  <value>23</value>
                  <description>Edge detect on PAD23</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD22</name>
                  <value>22</value>
                  <description>Edge detect on PAD22</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD21</name>
                  <value>21</value>
                  <description>Edge detect on PAD21</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD20</name>
                  <value>20</value>
                  <description>Edge detect on PAD20</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD19</name>
                  <value>19</value>
                  <description>Edge detect on PAD19</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD18</name>
                  <value>18</value>
                  <description>Edge detect on PAD18</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD17</name>
                  <value>17</value>
                  <description>Edge detect on PAD17</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD16</name>
                  <value>16</value>
                  <description>Edge detect on PAD16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD15</name>
                  <value>15</value>
                  <description>Edge detect on PAD15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD14</name>
                  <value>14</value>
                  <description>Edge detect on PAD14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD13</name>
                  <value>13</value>
                  <description>Edge detect on PAD13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD12</name>
                  <value>12</value>
                  <description>Edge detect on PAD12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD11</name>
                  <value>11</value>
                  <description>Edge detect on PAD11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD10</name>
                  <value>10</value>
                  <description>Edge detect on PAD10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD9</name>
                  <value>9</value>
                  <description>Edge detect on PAD9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD8</name>
                  <value>8</value>
                  <description>Edge detect on PAD8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD7</name>
                  <value>7</value>
                  <description>Edge detect on PAD7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD6</name>
                  <value>6</value>
                  <description>Edge detect on PAD6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD5</name>
                  <value>5</value>
                  <description>Edge detect on PAD5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD4</name>
                  <value>4</value>
                  <description>Edge detect on PAD4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD3</name>
                  <value>3</value>
                  <description>Edge detect on PAD3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD2</name>
                  <value>2</value>
                  <description>Edge detect on PAD2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD1</name>
                  <value>1</value>
                  <description>Edge detect on PAD1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD0</name>
                  <value>0</value>
                  <description>Edge detect on PAD0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>AON_PROG0_EV</name>
              <description>[5:0] Event selector for AON_PROG0 event.

AON Event Source id# selecting event routed to EVENT as AON_PROG0 event.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>63</value>
                  <description>No event, always low</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC_N</name>
                  <value>56</value>
                  <description>Comparator B not triggered. Asynchronous signal directly from AUX Comparator B (inverted) as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC</name>
                  <value>55</value>
                  <description>Comparator B triggered. Asynchronous signal directly from the AUX Comparator B as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_VOLT</name>
                  <value>54</value>
                  <description>BATMON voltage update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_TEMP</name>
                  <value>53</value>
                  <description>BATMON temperature update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>52</value>
                  <description>AUX Timer 1 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>51</value>
                  <description>AUX Timer 0 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>50</value>
                  <description>TDC completed or timed out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>49</value>
                  <description>ADC conversion completed</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>48</value>
                  <description>Comparator B triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>47</value>
                  <description>Comparator A triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV2</name>
                  <value>46</value>
                  <description>AUX Software triggered event #2. Triggered by AUX_EVCTL:SWEVSET.SWEV2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>45</value>
                  <description>AUX Software triggered event #1. Triggered by AUX_EVCTL:SWEVSET.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV0</name>
                  <value>44</value>
                  <description>AUX Software triggered event #0. Triggered by AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>JTAG</name>
                  <value>43</value>
                  <description>JTAG generated event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_UPD</name>
                  <value>42</value>
                  <description>RTC Update Tick (16 kHz signal, i.e. event line toggles value every 32 kHz clock period)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_COMB_DLY</name>
                  <value>41</value>
                  <description>RTC combined delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_DLY</name>
                  <value>40</value>
                  <description>RTC channel 2 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1_DLY</name>
                  <value>39</value>
                  <description>RTC channel 1 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0_DLY</name>
                  <value>38</value>
                  <description>RTC channel 0 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2</name>
                  <value>37</value>
                  <description>RTC channel 2 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1</name>
                  <value>36</value>
                  <description>RTC channel 1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0</name>
                  <value>35</value>
                  <description>RTC channel 0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD</name>
                  <value>32</value>
                  <description>Edge detect on any PAD</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD31</name>
                  <value>31</value>
                  <description>Edge detect on PAD31</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD30</name>
                  <value>30</value>
                  <description>Edge detect on PAD30</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD29</name>
                  <value>29</value>
                  <description>Edge detect on PAD29</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD28</name>
                  <value>28</value>
                  <description>Edge detect on PAD28</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD27</name>
                  <value>27</value>
                  <description>Edge detect on PAD27</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD26</name>
                  <value>26</value>
                  <description>Edge detect on PAD26</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD25</name>
                  <value>25</value>
                  <description>Edge detect on PAD25</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD24</name>
                  <value>24</value>
                  <description>Edge detect on PAD24</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD23</name>
                  <value>23</value>
                  <description>Edge detect on PAD23</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD22</name>
                  <value>22</value>
                  <description>Edge detect on PAD22</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD21</name>
                  <value>21</value>
                  <description>Edge detect on PAD21</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD20</name>
                  <value>20</value>
                  <description>Edge detect on PAD20</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD19</name>
                  <value>19</value>
                  <description>Edge detect on PAD19</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD18</name>
                  <value>18</value>
                  <description>Edge detect on PAD18</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD17</name>
                  <value>17</value>
                  <description>Edge detect on PAD17</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD16</name>
                  <value>16</value>
                  <description>Edge detect on PAD16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD15</name>
                  <value>15</value>
                  <description>Edge detect on PAD15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD14</name>
                  <value>14</value>
                  <description>Edge detect on PAD14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD13</name>
                  <value>13</value>
                  <description>Edge detect on PAD13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD12</name>
                  <value>12</value>
                  <description>Edge detect on PAD12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD11</name>
                  <value>11</value>
                  <description>Edge detect on PAD11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD10</name>
                  <value>10</value>
                  <description>Edge detect on PAD10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD9</name>
                  <value>9</value>
                  <description>Edge detect on PAD9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD8</name>
                  <value>8</value>
                  <description>Edge detect on PAD8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD7</name>
                  <value>7</value>
                  <description>Edge detect on PAD7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD6</name>
                  <value>6</value>
                  <description>Edge detect on PAD6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD5</name>
                  <value>5</value>
                  <description>Edge detect on PAD5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD4</name>
                  <value>4</value>
                  <description>Edge detect on PAD4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD3</name>
                  <value>3</value>
                  <description>Edge detect on PAD3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD2</name>
                  <value>2</value>
                  <description>Edge detect on PAD2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD1</name>
                  <value>1</value>
                  <description>Edge detect on PAD1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD0</name>
                  <value>0</value>
                  <description>Edge detect on PAD0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x2B2B2B</resetValue>
        </register>
        <register>
          <name>RTCSEL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>RTC Capture Event Selector For AON_RTC

This register contains a pointer to select an AON event for RTC capture. Please refer to AON_RTC:CH1CAPT</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RTC_CH1_CAPT_EV</name>
              <description>[5:0] AON Event Source id# for RTCSEL event which is fed to AON_RTC. Please refer to AON_RTC:CH1CAPT</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>63</value>
                  <description>No event, always low</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC_N</name>
                  <value>56</value>
                  <description>Comparator B not triggered. Asynchronous signal directly from AUX Comparator B (inverted) as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB_ASYNC</name>
                  <value>55</value>
                  <description>Comparator B triggered. Asynchronous signal directly from the AUX Comparator B as opposed to AUX_COMPB which is synchronized in AUX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_VOLT</name>
                  <value>54</value>
                  <description>BATMON voltage update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BATMON_TEMP</name>
                  <value>53</value>
                  <description>BATMON temperature update event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>52</value>
                  <description>AUX Timer 1 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>51</value>
                  <description>AUX Timer 0 Event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>50</value>
                  <description>TDC completed or timed out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>49</value>
                  <description>ADC conversion completed</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>48</value>
                  <description>Comparator B triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>47</value>
                  <description>Comparator A triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV2</name>
                  <value>46</value>
                  <description>AUX Software triggered event #2. Triggered by AUX_EVCTL:SWEVSET.SWEV2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>45</value>
                  <description>AUX Software triggered event #1. Triggered by AUX_EVCTL:SWEVSET.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV0</name>
                  <value>44</value>
                  <description>AUX Software triggered event #0. Triggered by AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>JTAG</name>
                  <value>43</value>
                  <description>JTAG generated event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_UPD</name>
                  <value>42</value>
                  <description>RTC Update Tick (16 kHz signal, i.e. event line toggles value every 32 kHz clock period)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_COMB_DLY</name>
                  <value>41</value>
                  <description>RTC combined delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_DLY</name>
                  <value>40</value>
                  <description>RTC channel 2 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1_DLY</name>
                  <value>39</value>
                  <description>RTC channel 1 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0_DLY</name>
                  <value>38</value>
                  <description>RTC channel 0 - delayed event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2</name>
                  <value>37</value>
                  <description>RTC channel 2 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH1</name>
                  <value>36</value>
                  <description>RTC channel 1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH0</name>
                  <value>35</value>
                  <description>RTC channel 0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD</name>
                  <value>32</value>
                  <description>Edge detect on any PAD</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD31</name>
                  <value>31</value>
                  <description>Edge detect on PAD31</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD30</name>
                  <value>30</value>
                  <description>Edge detect on PAD30</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD29</name>
                  <value>29</value>
                  <description>Edge detect on PAD29</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD28</name>
                  <value>28</value>
                  <description>Edge detect on PAD28</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD27</name>
                  <value>27</value>
                  <description>Edge detect on PAD27</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD26</name>
                  <value>26</value>
                  <description>Edge detect on PAD26</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD25</name>
                  <value>25</value>
                  <description>Edge detect on PAD25</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD24</name>
                  <value>24</value>
                  <description>Edge detect on PAD24</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD23</name>
                  <value>23</value>
                  <description>Edge detect on PAD23</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD22</name>
                  <value>22</value>
                  <description>Edge detect on PAD22</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD21</name>
                  <value>21</value>
                  <description>Edge detect on PAD21</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD20</name>
                  <value>20</value>
                  <description>Edge detect on PAD20</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD19</name>
                  <value>19</value>
                  <description>Edge detect on PAD19</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD18</name>
                  <value>18</value>
                  <description>Edge detect on PAD18</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD17</name>
                  <value>17</value>
                  <description>Edge detect on PAD17</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD16</name>
                  <value>16</value>
                  <description>Edge detect on PAD16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD15</name>
                  <value>15</value>
                  <description>Edge detect on PAD15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD14</name>
                  <value>14</value>
                  <description>Edge detect on PAD14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD13</name>
                  <value>13</value>
                  <description>Edge detect on PAD13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD12</name>
                  <value>12</value>
                  <description>Edge detect on PAD12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD11</name>
                  <value>11</value>
                  <description>Edge detect on PAD11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD10</name>
                  <value>10</value>
                  <description>Edge detect on PAD10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD9</name>
                  <value>9</value>
                  <description>Edge detect on PAD9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD8</name>
                  <value>8</value>
                  <description>Edge detect on PAD8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD7</name>
                  <value>7</value>
                  <description>Edge detect on PAD7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD6</name>
                  <value>6</value>
                  <description>Edge detect on PAD6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD5</name>
                  <value>5</value>
                  <description>Edge detect on PAD5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD4</name>
                  <value>4</value>
                  <description>Edge detect on PAD4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD3</name>
                  <value>3</value>
                  <description>Edge detect on PAD3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD2</name>
                  <value>2</value>
                  <description>Edge detect on PAD2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD1</name>
                  <value>1</value>
                  <description>Edge detect on PAD1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PAD0</name>
                  <value>0</value>
                  <description>Edge detect on PAD0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x3F</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AON_IOC</name>
      <baseAddress>0x40094000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Always On (AON) IO Controller  - controls IO operation when the MCU IO Controller (IOC) is powered off and resides in the AON domain.  Note: This module only supports 32 bit Read/Write access from MCU.</description>
      <registers>
        <register>
          <name>IOSTRMIN</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>GRAY_CODE</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3</resetValue>
        </register>
        <register>
          <name>IOSTRMED</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>GRAY_CODE</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x6</resetValue>
        </register>
        <register>
          <name>IOSTRMAX</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>GRAY_CODE</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x5</resetValue>
        </register>
        <register>
          <name>IOCLATCH</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>IO Latch Control

Controls transparency of all latches holding I/O or configuration state from the MCU IOC</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] Controls latches between MCU IOC and AON_IOC.

The latches are transparent by default.

They must be closed prior to power off the domain(s) controlling the IOs in order to preserve IO values on external pins.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TRANSP</name>
                  <value>1</value>
                  <description>Latches are transparent, meaning the value of the IO is directly controlled by the GPIO or peripheral value</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STATIC</name>
                  <value>0</value>
                  <description>Latches are static, meaning the current value on the IO pin is frozen by latches and kept even if GPIO module or a peripheral module is turned off</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>CLK32KCTL</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>SCLK_LF External Output Control</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>OE_N</name>
              <description>[0:0] 0: Output enable active. SCLK_LF output on IO pin that has PORT_ID (e.g. IOC:IOCFG0.PORT_ID) set to AON_CLK32K.
1: Output enable not active</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AON_RTC</name>
      <baseAddress>0x40092000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <description>This component control the Real Time Clock residing in AON

Note: This module is only supporting 32 bit ReadWrite access.</description>
      <registers>
        <register>
          <name>CTL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Control

This register contains various  bitfields for configuration of RTC</description>
          <fields>
            <field>
              <name>RESERVED19</name>
              <description>[31:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>13</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>COMB_EV_MASK</name>
              <description>[18:16] Eventmask selecting which delayed events that form the combined event.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CH2</name>
                  <value>4</value>
                  <description>Use Channel 2 delayed event in combined event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH1</name>
                  <value>2</value>
                  <description>Use Channel 1 delayed event in combined event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH0</name>
                  <value>1</value>
                  <description>Use Channel 0 delayed event in combined event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No event is selected for combined event.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[15:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>EV_DELAY</name>
              <description>[11:8] Number of SCLK_LF clock cycles waited before generating delayed events. (Common setting for all RTC cannels)  the delayed event is delayed</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>D144</name>
                  <value>13</value>
                  <description>Delay by 144 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D128</name>
                  <value>12</value>
                  <description>Delay by 128 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D112</name>
                  <value>11</value>
                  <description>Delay by 112 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D96</name>
                  <value>10</value>
                  <description>Delay by 96 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D80</name>
                  <value>9</value>
                  <description>Delay by 80 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D64</name>
                  <value>8</value>
                  <description>Delay by 64 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D48</name>
                  <value>7</value>
                  <description>Delay by 48 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D32</name>
                  <value>6</value>
                  <description>Delay by 32 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D16</name>
                  <value>5</value>
                  <description>Delay by 16 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D8</name>
                  <value>4</value>
                  <description>Delay by 8 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D4</name>
                  <value>3</value>
                  <description>Delay by 4 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D2</name>
                  <value>2</value>
                  <description>Delay by 2 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D1</name>
                  <value>1</value>
                  <description>Delay by 1 clock cycles</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>D0</name>
                  <value>0</value>
                  <description>No delay on delayed event</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESET</name>
              <description>[7:7] RTC Counter reset.

Writing 1 to this bit will reset the RTC counter.

This bit is cleared when reset takes effect</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[6:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RTC_4KHZ_EN</name>
              <description>[2:2] RTC_4KHZ is a 4 KHz reference output, tapped from  SUBSEC.VALUE  bit 19 which is used by AUX timer. 

0: RTC_4KHZ signal is forced to 0
1: RTC_4KHZ is enabled ( provied that RTC is enabled EN)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTC_UPD_EN</name>
              <description>[1:1] RTC_UPD is a 16 KHz signal used to sync up the radio timer. The 16 Khz is SCLK_LF divided by 2

0: RTC_UPD signal is forced to 0
1: RTC_UPD signal is toggling @16 kHz</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] Enable RTC counter

0: Halted (frozen)
1: Running</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EVFLAGS</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Event Flags, RTC Status

This register contains event flags from the 3 RTC channels. Each flag will be cleared when writing a '1' to the corresponding bitfield.</description>
          <fields>
            <field>
              <name>RESERVED17</name>
              <description>[31:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>CH2</name>
              <description>[16:16] Channel 2 event flag, set when CHCTL.CH2_EN = 1 and the RTC value matches or passes the CH2CMP value.

An event will be scheduled to occur as soon as possible when writing to CH2CMP provided that the channel is enabled and the new value matches any time between next  RTC value and 1 second in the past

Writing 1 clears this flag. Note that a new event can not occur on this channel in first 2 SCLK_LF cycles after a clearance.

AUX_SCE can read the flag through AUX_WUC:WUEVFLAGS.AON_RTC_CH2 and clear it using AUX_WUC:WUEVCLR.AON_RTC_CH2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[15:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>CH1</name>
              <description>[8:8] Channel 1 event flag, set when CHCTL.CH1_EN = 1 and one of the following:
- CHCTL.CH1_CAPT_EN = 0 and the RTC value matches or passes the CH1CMP value.
- CHCTL.CH1_CAPT_EN = 1 and capture occurs.

An event will be scheduled to occur as soon as possible when writing to CH1CMP provided that the channel is enabled, in compare mode and the new value matches any time between next  RTC value and 1 second in the past.

Writing 1 clears this flag. Note that a new event can not occur on this channel in first 2 SCLK_LF cycles after a clearance.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CH0</name>
              <description>[0:0] Channel 0 event flag, set when CHCTL.CH0_EN = 1 and the RTC value matches or passes the CH0CMP value.

An event will be scheduled to occur as soon as possible when writing to CH0CMP provided that the channels is enabled and the new value matches any time between next  RTC value and 1 second in the past.

Writing 1 clears this flag. Note that a new event can not occur on this channel in first 2 SCLK_LF cycles after a clearance.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SEC</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Second Counter Value, Integer Part</description>
          <fields>
            <field>
              <name>VALUE</name>
              <description>[31:0] Unsigned integer representing Real Time Clock in seconds. 

When reading this register the content of SUBSEC.VALUE is simultaneously latched. A consistent reading of the combined Real Time Clock can be obtained by first reading this register, then reading SUBSEC register.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SUBSEC</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Second Counter Value, Fractional Part</description>
          <fields>
            <field>
              <name>VALUE</name>
              <description>[31:0] Unsigned integer representing Real Time Clock in fractions of a second (VALUE/2^32 seconds) at the time when SEC register was read.

Examples : 
- 0x0000_0000 = 0.0 sec
- 0x4000_0000 = 0.25 sec
- 0x8000_0000 = 0.5 sec
- 0xC000_0000 = 0.75 sec</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SUBSECINC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Subseconds Increment
Value added to SUBSEC.VALUE on every SCLK_LFclock cycle.</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>VALUEINC</name>
              <description>[23:0] This value compensates for a SCLK_LF clock which has an offset from 32768 Hz.

The compensation value can be found as 2^38 / freq, where freq is SCLK_LF clock frequency in Hertz

This value is added to SUBSEC.VALUE on every cycle, and carry of this is added to SEC.VALUE. To perform the addition, bits [23:6] are aligned with SUBSEC.VALUE bits [17:0]. The remaining bits [5:0] are accumulated in a hidden 6-bit register that generates a carry into the above mentioned addition on overflow.
The default value corresponds to incrementing by precisely 1/32768 of a second.

NOTE: This register is read only. Modification of the register value must be done using registers AUX_WUC:RTCSUBSECINC1 ,  AUX_WUC:RTCSUBSECINC0 and  AUX_WUC:RTCSUBSECINCCTL</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x800000</resetValue>
        </register>
        <register>
          <name>CHCTL</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Channel Configuration</description>
          <fields>
            <field>
              <name>RESERVED19</name>
              <description>[31:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>13</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CH2_CONT_EN</name>
              <description>[18:18] Set to enable continuous operation of Channel 2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RESERVED17</name>
              <description>[17:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>CH2_EN</name>
              <description>[16:16] RTC Channel 2 Enable

0: Disable RTC Channel 2
1: Enable RTC Channel 2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED10</name>
              <description>[15:10] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CH1_CAPT_EN</name>
              <description>[9:9] Set Channel 1 mode

0: Compare mode (default)
1: Capture mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>CH1_EN</name>
              <description>[8:8] RTC Channel 1 Enable

0: Disable RTC Channel 1
1: Enable RTC Channel 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CH0_EN</name>
              <description>[0:0] RTC Channel 0 Enable

0: Disable RTC Channel 0
1: Enable RTC Channel 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CH0CMP</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Channel 0 Compare Value</description>
          <fields>
            <field>
              <name>VALUE</name>
              <description>[31:0] RTC Channel 0 compare value.

Bit 31 to 16 represents seconds and bits 15 to 0 represents subseconds of the compare value.

The compare value is compared against SEC.VALUE (15:0) and SUBSEC.VALUE (31:16) values of the Real Time Clock register. A Cannel 0 event is generated when {SEC.VALUE(15:0),SUBSEC.VALUE (31:16)} is reaching or exciting the compare value. 

Writing to this register can trigger an immediate*) event in case the new compare value matches a Real Time Clock  value from 1 second in the past up till current Real Time Clock value.

Example:
To generate a compare  5.5 seconds RTC start,- set this value = 0x0005_8000

*) It can take up to 2 SCLK_LF clock cycles before event occurs due to synchronization.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CH1CMP</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Channel 1 Compare Value</description>
          <fields>
            <field>
              <name>VALUE</name>
              <description>[31:0] RTC Channel 1 compare value.

Bit 31 to 16 represents seconds and bits 15 to 0 represents subseconds of the compare value.

The compare value is compared against SEC.VALUE (15:0) and SUBSEC.VALUE (31:16) values of the Real Time Clock register. A Cannel 0 event is generated when {SEC.VALUE(15:0),SUBSEC.VALUE (31:16)} is reaching or exciting the compare value. 

Writing to this register can trigger an immediate*) event in case the new compare value matches a Real Time Clock  value from 1 second in the past up till current Real Time Clock value.

Example:
To generate a compare  5.5 seconds RTC start,- set this value = 0x0005_8000

*) It can take up to 2 SCLK_LF clock cycles before event occurs due to synchronization.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CH2CMP</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Channel 2 Compare Value</description>
          <fields>
            <field>
              <name>VALUE</name>
              <description>[31:0] RTC Channel 2 compare value.

Bit 31 to 16 represents seconds and bits 15 to 0 represents subseconds of the compare value.

The compare value is compared against SEC.VALUE (15:0) and SUBSEC.VALUE (31:16) values of the Real Time Clock register. A Cannel 0 event is generated when {SEC.VALUE(15:0),SUBSEC.VALUE (31:16)} is reaching or exciting the compare value. 

Writing to this register can trigger an immediate*) event in case the new compare value matches a Real Time Clock  value from 1 second in the past up till current Real Time Clock value.

Example:
To generate a compare  5.5 seconds RTC start,- set this value = 0x0005_8000

*) It can take up to 2 SCLK_LF clock cycles before event occurs due to synchronization.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CH2CMPINC</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Channel 2 Compare Value Auto-increment

This register is primarily used to generate periodical wake-up for the AUX_SCE module, through the [AUX_EVCTL.EVSTAT0.AON_RTC] event.</description>
          <fields>
            <field>
              <name>VALUE</name>
              <description>[31:0] If CHCTL.CH2_CONT_EN is set, this value is added to CH2CMP.VALUE on every channel 2 compare event.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CH1CAPT</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Channel 1 Capture Value

If CHCTL.CH1_EN = 1and CHCTL.CH1_CAPT_EN = 1, capture occurs on each rising edge of the event selected in AON_EVENT:RTCSEL.</description>
          <fields>
            <field>
              <name>SEC</name>
              <description>[31:16] Value of SEC.VALUE bits 15:0 at capture time.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SUBSEC</name>
              <description>[15:0] Value of SUBSEC.VALUE bits 31:16 at capture time.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>AON Synchronization

This register is used for synchronizing between MCU and entire AON domain.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>WBUSY</name>
              <description>[0:0] This register will always return 0,- however it will not return the value until there are no outstanding write requests between MCU and AON

Note: Writing to this register prior to reading will force a wait until next SCLK_LF  edge. This is recommended for syncing read registers from AON when waking up from sleep
Failure to do so may result in reading AON values from prior to going to sleep</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AON_SYSCTL</name>
      <baseAddress>0x40090000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <description>This component controls AON_SYSCTL, which is the device's system controller.

Note: This module is only supporting 32 bit ReadWrite access from MCU</description>
      <registers>
        <register>
          <name>PWRCTL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Power Management

This register controls bitfields for setting low level power management features such as selection of  regulator for VDDR supply and control of IO ring where certain segments can be enabled / disabled.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DCDC_ACTIVE</name>
              <description>[2:2] Select to use DCDC regulator for VDDR in active mode 

0: Use GLDO for regulation of VDDRin active mode. 
1: Use DCDC for regulation of VDDRin active mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>EXT_REG_MODE</name>
              <description>[1:1] Status of source for VDDRsupply:

0: DCDC/GLDO are generating VDDR
1: DCDC/GLDO are bypassed, external regulator supplies VDDR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DCDC_EN</name>
              <description>[0:0] Select to use DCDC regulator during recharge of VDDR

0: Use GLDO for recharge of VDDR
1: Use DCDC for recharge of VDDR

Note: This bitfield should be set to the same as DCDC_ACTIVE</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESETCTL</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Reset Management

This register contains bitfields releated to system reset such as reset source and reset request  and control of brown out resets.</description>
          <fields>
            <field>
              <name>SYSRESET</name>
              <description>[31:31] Cold reset register. Writing 1 to this bitfield will reset the entire chip and cause boot code to run again.

0: No effect
1: Generate system reset. Appears as SYSRESET in RESET_SRC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>RESERVED26</name>
              <description>[30:26] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>BOOT_DET_1_CLR</name>
              <description>[25:25] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>BOOT_DET_0_CLR</name>
              <description>[24:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED18</name>
              <description>[23:18] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>BOOT_DET_1_SET</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>BOOT_DET_0_SET</name>
              <description>[16:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>WU_FROM_SD</name>
              <description>[15:15] A Wakeup from SHUTDOWN on an IO event has occurred, or a wakeup from SHUTDOWN has occurred as a result of the debugger being attached.. (TCK pin being forced low) 

Please refer to [IOC:IOCFGn,.WU_CFG] for configuring the IO's as wakeup sources.

0: Wakeup occurred from cold reset or brown out as seen in RESET_SRC
1: A wakeup has occurred from SHUTDOWN

Note: This flag can not be cleared and will therefor remain valid untill poweroff/reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>GPIO_WU_FROM_SD</name>
              <description>[14:14] A wakeup from SHUTDOWN on an IO event has occurred 

Please refer to [IOC:IOCFGn,.WU_CFG] for configuring the IO's as wakeup sources.

0: The wakeup did not occur from SHUTDOWN on an IO event
1: A wakeup from SHUTDOWN occurred from an IO event

The case where WU_FROM_SD is asserted but this bitfield is not asserted will only occur in a debug session. The boot code will not proceed with wakeup from SHUTDOWN procedure until this bitfield is asserted as well.

Note: This flag can not be cleared and will therefor remain valid untill poweroff/reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>BOOT_DET_1</name>
              <description>[13:13] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>BOOT_DET_0</name>
              <description>[12:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>VDDS_LOSS_EN_OVR</name>
              <description>[11:11] Override of VDDS_LOSS_EN

0: Brown out detect of VDDS is ignored, unless VDDS_LOSS_EN=1
1: Brown out detect of VDDS generates system reset (regardless of  VDDS_LOSS_EN)

This bit can be locked</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>VDDR_LOSS_EN_OVR</name>
              <description>[10:10] Override of VDDR_LOSS_EN

0: Brown out detect of VDDR is ignored, unless VDDR_LOSS_EN=1
1: Brown out detect of VDDR generates system reset (regardless of  VDDR_LOSS_EN)

This bit can be locked</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>VDD_LOSS_EN_OVR</name>
              <description>[9:9] Override of VDD_LOSS_EN

0: Brown out detect of VDD is ignored, unless VDD_LOSS_EN=1
1: Brown out detect of VDD generates system reset (regardless of  VDD_LOSS_EN)

This bit can be locked</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>RESERVED8</name>
              <description>[8:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VDDS_LOSS_EN</name>
              <description>[7:7] Controls reset generation in case VDDS is lost

0: Brown out detect of VDDS is ignored, unless VDDS_LOSS_EN_OVR=1
1: Brown out detect of VDDS generates system reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>VDDR_LOSS_EN</name>
              <description>[6:6] Controls reset generation in case VDDR is lost 

0: Brown out detect of VDDR is ignored, unless VDDR_LOSS_EN_OVR=1
1: Brown out detect of VDDR generates system reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>VDD_LOSS_EN</name>
              <description>[5:5] Controls reset generation in case VDD is lost

0: Brown out detect of VDD is ignored, unless VDD_LOSS_EN_OVR=1
1: Brown out detect of VDD generates system reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CLK_LOSS_EN</name>
              <description>[4:4] Controls reset generation in case SCLK_LF is lost.  (provided that clock loss detection is enabled by DDI_0_OSC:CTL0.CLK_LOSS_EN)

Note: Clock loss reset generation must be disabled before SCLK_LF clock source is changed in  DDI_0_OSC:CTL0.SCLK_LF_SRC_SEL and remain disabled untill the change is confirmed in DDI_0_OSC:STAT0.SCLK_LF_SRC. Failure to do so may result in a spurious system reset. Clock loss reset generation can be disabled through this bitfield or by clearing  DDI_0_OSC:CTL0.CLK_LOSS_EN
 
0: Clock loss is ignored
1: Clock loss generates system reset</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESET_SRC</name>
              <description>[3:1] Shows the source of the last system reset:
Occurrence of one of the reset sources may trigger several other reset sources as essential parts of the system are undergoing reset. This field will report the root cause of the reset (not the other resets that are consequence of the system reset). 
To support this feature the actual register is not captured before the reset source being released. If a new reset source is triggered, in a window of four  32 kHz periods after the previous has been released,  this register may indicate Power on reset as source.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WARMRESET</name>
                  <value>7</value>
                  <description>Software reset via PRCM warm reset request</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSRESET</name>
                  <value>6</value>
                  <description>Software reset via SYSRESET register</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_LOSS</name>
                  <value>5</value>
                  <description>Clock loss detect</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDR_LOSS</name>
                  <value>4</value>
                  <description>Brown out detect on VDDR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDD_LOSS</name>
                  <value>3</value>
                  <description>Brown out detect on VDD</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDS_LOSS</name>
                  <value>2</value>
                  <description>Brown out detect on VDDS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PIN_RESET</name>
                  <value>1</value>
                  <description>Reset pin</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR_ON</name>
                  <value>0</value>
                  <description>Power on reset</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xE0</resetValue>
        </register>
        <register>
          <name>SLEEPCTL</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Sleep Mode

This register is used to unfreeze the IO pad ring after waking up from SHUTDOWN</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>IO_PAD_SLEEP_DIS</name>
              <description>[0:0] Controls the I/O pad sleep mode. The boot code will set this bitfield automatically unless waking up from a SHUTDOWN ( RESETCTL.WU_FROM_SD is set ).  

0: I/O pad sleep mode is enabled, ie all pads are latched and can not toggle.
1: I/O pad sleep mode is disabled

Application software may want to reconfigure the state for all IO's before setting this bitfield upon waking up from a SHUTDOWN.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AON_WUC</name>
      <baseAddress>0x40091000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>This component control the Wakeup controller residing in the AON domain.

Note: This module is only supporting 32 bit ReadWrite access from MCU</description>
      <registers>
        <register>
          <name>MCUCLK</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>MCU Clock Management

This register contains bitfields related to the MCU clock.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RCOSC_HF_CAL_DONE</name>
              <description>[2:2] MCU bootcode will set this bit when RCOSC_HF is calibrated.  The FLASH can not be used until this bit is set.

1: RCOSC_HF is calibrated to 48 MHz, allowing FLASH to power up.
0: RCOSC_HF is not yet calibrated, ie FLASH must not assume that the SCLK_HF is safe</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PWR_DWN_SRC</name>
              <description>[1:0] Controls the clock source for the entire MCU domain while MCU is requesting powerdown.

When MCU requests powerdown with SCLK_HF as source, then WUC will switch over to this clock source during powerdown, and automatically switch back to SCLK_HF when MCU is no longer requesting powerdown and system is back in active mode.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SCLK_LF</name>
                  <value>1</value>
                  <description>Use SCLK_LF in Powerdown</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No clock in Powerdown</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AUXCLK</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>AUX Clock Management

This register contains bitfields that are relevant for setting up the clock to the AUX domain.</description>
          <fields>
            <field>
              <name>RESERVED13</name>
              <description>[31:13] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>19</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PWR_DWN_SRC</name>
              <description>[12:11] When AUX requests powerdown with SCLK_HF as source, then WUC will switch over to this clock source during powerdown, and automatically switch back to SCLK_HF when AUX system is back in active mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SCLK_LF</name>
                  <value>1</value>
                  <description>Use SCLK_LF in Powerdown</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No clock in Powerdown</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCLK_HF_DIV</name>
              <description>[10:8] Select the AUX clock divider for SCLK_HF

NB: It is not supported to change the AUX clock divider while SCLK_HF is active source for AUX</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIV256</name>
                  <value>7</value>
                  <description>Divide by 256</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV128</name>
                  <value>6</value>
                  <description>Divide by 128</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV64</name>
                  <value>5</value>
                  <description>Divide by 64</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV32</name>
                  <value>4</value>
                  <description>Divide by 32</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV16</name>
                  <value>3</value>
                  <description>Divide by 16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV8</name>
                  <value>2</value>
                  <description>Divide by 8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV4</name>
                  <value>1</value>
                  <description>Divide by 4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV2</name>
                  <value>0</value>
                  <description>Divide by 2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[7:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SRC</name>
              <description>[2:0] Selects the clock source for AUX:

NB: Switching the clock source is guaranteed to be glitchless</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SCLK_LF</name>
                  <value>4</value>
                  <description>LF Clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SCLK_HF</name>
                  <value>1</value>
                  <description>HF Clock (SCLK_HF)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>MCUCFG</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>MCU Configuration

This register contains power management related bitfields for the MCU domain.</description>
          <fields>
            <field>
              <name>RESERVED18</name>
              <description>[31:18] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>14</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>VIRT_OFF</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>FIXED_WU_EN</name>
              <description>[16:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[15:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SRAM_RET_EN</name>
              <description>[3:0] MCU SRAM is partitioned into 4 banks . This register controls which of the banks that has retention during MCU power off</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RET_FULL</name>
                  <value>15</value>
                  <description>Retention on for all banks (SRAM:BANK0, SRAM:BANK1 ,SRAM:BANK2 and SRAM:BANK3)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RET_LEVEL3</name>
                  <value>7</value>
                  <description>Retention on for SRAM:BANK0, SRAM:BANK1 and SRAM:BANK2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RET_LEVEL2</name>
                  <value>3</value>
                  <description>Retention on for SRAM:BANK0 and SRAM:BANK1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RET_LEVEL1</name>
                  <value>1</value>
                  <description>Retention on for SRAM:BANK0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RET_NONE</name>
                  <value>0</value>
                  <description>Retention is disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0xF</resetValue>
        </register>
        <register>
          <name>AUXCFG</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>AUX Configuration

This register contains power management related signals for the AUX domain.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RAM_RET_EN</name>
              <description>[0:0] This bit controls retention mode for the AUX_RAM:BANK0:

0: Retention is disabled
1: Retention is enabled

NB: If retention is disabled, the AUX_RAM will be powered off when it would otherwise be put in retention mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>AUXCTL</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>AUX Control

This register contains events and control signals for the AUX domain.</description>
          <fields>
            <field>
              <name>RESET_REQ</name>
              <description>[31:31] Reset request for AUX. Writing 1 to this register will assert reset to AUX. The reset will be held until the bit is cleared again.

0: AUX reset pin will be deasserted
1: AUX reset pin will be asserted</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[30:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SCE_RUN_EN</name>
              <description>[2:2] Enables (1) or disables (0) AUX_SCE execution. AUX_SCE execution will begin when AUX Domain is powered and either this or AUX_SCE:CTL.CLK_EN is set. 

Setting this bit will assure that AUX_SCE execution starts as soon as AUX power domain is woken up. (  AUX_SCE:CTL.CLK_EN will be reset to 0 if AUX power domain has been off)

0: AUX_SCE execution will be disabled if AUX_SCE:CTL.CLK_EN is 0
1: AUX_SCE execution is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SWEV</name>
              <description>[1:1] Writing 1 sets the software event to the AUX domain, which can be read through AUX_WUC:WUEVFLAGS.AON_SW.

This event is normally cleared by AUX_SCE through the AUX_WUC:WUEVCLR.AON_SW. It can also be cleared by writing 0 to this register.

Reading 0 means that there is no outstanding software event for AUX. 

Note that it can take up to 1,5 SCLK_LF clock cycles to clear the event from AUX.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>AUX_FORCE_ON</name>
              <description>[0:0] Forces the AUX domain into active mode, overriding the requests from AUX_WUC:PWROFFREQ, AUX_WUC:PWRDWNREQ and AUX_WUC:MCUBUSCTL. 
Note that an ongoing AUX_WUC:PWROFFREQ will complete before this bit will set the AUX domain into active mode.

MCU must set this bit in order to access the AUX peripherals. 
The AUX domain status can be read from PWRSTAT.AUX_PD_ON 

0: AUX is allowed to Power Off, Power Down or Disconnect.
1: AUX  Power OFF, Power Down or Disconnect requests will be overruled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PWRSTAT</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Power Status

This register is used to monitor various power management related signals in AON.  Most signals are for test, calibration and debug purpose only, and others can be used to detect that AUX or JTAG domains are powered up.</description>
          <fields>
            <field>
              <name>RESERVED10</name>
              <description>[31:10] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>22</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>AUX_PWR_DWN</name>
              <description>[9:9] Indicates the AUX powerdown state when AUX domain is powered up.

0: Active mode
1: AUX Powerdown request has been granted</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>[8:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>JTAG_PD_ON</name>
              <description>[6:6] Indicates JTAG power state:

0: JTAG is powered off
1: JTAG is powered on</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>AUX_PD_ON</name>
              <description>[5:5] Indicates AUX power state:

0: AUX is not ready for use ( may be powered off or in power state transition )
1: AUX is powered on, connected to bus and ready for use,</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>MCU_PD_ON</name>
              <description>[4:4] Indicates MCU power state:

0: MCU Power sequencing is not yet finalized and MCU_AONIF registers may not be reliable
1: MCU Power sequencing is finalized and all MCU_AONIF registers are reliable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>AUX_BUS_CONNECTED</name>
              <description>[2:2] Indicates that AUX Bus is connected:

0: AUX bus is not connected
1: AUX bus is connected ( idle_ack = 0 )</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AUX_RESET_DONE</name>
              <description>[1:1] Indicates Reset Done from AUX:

0: AUX is being reset
1: AUX reset is released</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3800000</resetValue>
        </register>
        <register>
          <name>SHUTDOWN</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Shutdown Control

This register contains bitfields required for entering shutdown mode</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] Writing a 1 to this bit forces a shutdown request to be registered and all I/O values to be latched - in the PAD ring, possibly enabling I/O wakeup. Writing 0 will cancel a registered shutdown request and open th I/O latches residing in the PAD ring.

A registered shutdown request takes effect the next time power down conditions exists. At this time, the will not enter Powerdown mode, but instead it will turn off all internal powersupplies, effectively putting the device into Shutdown mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CTL0</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Control 0

This register contains various chip level control and debug bitfields.</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PWR_DWN_DIS</name>
              <description>[8:8] Controls whether MCU and AUX requesting to be powered off will enable a transition to powerdown:

0: Enabled
1: Disabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[7:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>AUX_SRAM_ERASE</name>
              <description>[3:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MCU_SRAM_ERASE</name>
              <description>[2:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[1:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CTL1</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Control 1

This register contains various chip level control and debug bitfields.</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MCU_RESET_SRC</name>
              <description>[1:1] Indicates source of last MCU Voltage Domain warm reset request:

0: MCU SW reset
1: JTAG reset

This bit can only be cleared by writing a 1 to it</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MCU_WARM_RESET</name>
              <description>[0:0] Indicates type of last MCU Voltage Domain reset:

0: Last MCU reset was not a warm reset
1: Last MCU reset was a warm reset (requested from MCU or JTAG as indicated in MCU_RESET_SRC)

This bit can only be cleared by writing a 1 to it</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RECHARGECFG</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Recharge Controller Configuration

This register sets all relevant patameters for controlling the recharge algorithm.</description>
          <fields>
            <field>
              <name>ADAPTIVE_EN</name>
              <description>[31:31] Enable adaptive recharge

Note: Recharge can be turned completely of by setting MAX_PER_E=7 and MAX_PER_M=31 and this bitfield to 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>RESERVED24</name>
              <description>[30:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>C2</name>
              <description>[23:20] Gain factor for adaptive recharge algorithm

period_new=period * ( 1+/-(2^-C1+2^-C2) )
Valid values for C2 is 2 to 10

Note: Rounding may cause adaptive recharge not to start for very small values of both Gain and Initial period. Criteria for algorithm to start is MAX(PERIOD*2^-C1,PERIOD*2^-C2) >= 1</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>C1</name>
              <description>[19:16] Gain factor for adaptive recharge algorithm

period_new=period * ( 1+/-(2^-C1+2^-C2) )
Valid values for C1 is 1 to 10

Note: Rounding may cause adaptive recharge not to start for very small values of both Gain and Initial period. Criteria for algorithm to start is MAX(PERIOD*2^-C1,PERIOD*2^-C2) >= 1</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MAX_PER_M</name>
              <description>[15:11] This register defines the maximum period that the recharge algorithm can take, i.e. it defines  the maximum number of cycles between 2 recharges.
The maximum number of cycles is specified with a 5 bit mantissa and 3 bit exponent:
MAXCYCLES=(MAX_PER_M*16+15)*2^MAX_PER_E
This field sets the mantissa of MAXCYCLES</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>MAX_PER_E</name>
              <description>[10:8] This register defines the maximum period that the recharge algorithm can take, i.e. it defines  the maximum number of cycles between 2 recharges.
The maximum number of cycles is specified with a 5 bit mantissa and 3 bit exponent:
MAXCYCLES=(MAX_PER_M*16+15)*2^MAX_PER_E
This field sets the exponent MAXCYCLES</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PER_M</name>
              <description>[7:3] Number of 32 KHz clocks between activation of recharge controller
For recharge algorithm, PERIOD is the initial period when entering powerdown mode. The adaptive recharge algorithm will not change this register
PERIOD will effectively be a 16 bit value coded in a 5 bit mantissa and 3 bit exponent:
This field sets the Mantissa of the Period.
PERIOD=(PER_M*16+15)*2^PER_E</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PER_E</name>
              <description>[2:0] Number of 32 KHz clocks between activation of recharge controller
For recharge algorithm, PERIOD is the initial period when entering powerdown mode. The adaptive recharge algorithm will not change this register
PERIOD will effectively be a 16 bit value coded in a 5 bit mantissa and 3 bit exponent:
This field sets the Exponent of the Period.  
PERIOD=(PER_M*16+15)*2^PER_E</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RECHARGESTAT</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Recharge Controller Status

This register controls various status registers which are updated during recharge.  The register is mostly intended for test and debug.</description>
          <fields>
            <field>
              <name>RESERVED20</name>
              <description>[31:20] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>VDDR_SMPLS</name>
              <description>[19:16] The last 4 VDDR samples, bit 0 being the newest.

The register is being updated in every recharge period with a shift left, and bit 0 is updated with the last VDDR sample, ie a 1 is shiftet in in case VDDR > VDDR_threshold just before recharge starts. Otherwise a 0 will be shifted in.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MAX_USED_PER</name>
              <description>[15:0] The maximum value of recharge period seen with VDDR>threshold.

The VDDR voltage is compared against the threshold voltage at  just before  each recharge. If VDDR is above threshold, MAX_USED_PER is updated with max ( current recharge peride; MAX_USED_PER )  This way MAX_USED_PER can track the recharge period where VDDR is decharged to the threshold value. We can therefore use the value as an indication of the leakage current during recharge.

This bitfield is cleared to 0 when writing this register.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>OSCCFG</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Oscillator Configuration

This register sets the period for Amplitude compensation requests sent to the oscillator control system. The amplitude compensations is only applicable when XOSC_HF is running in low power mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PER_M</name>
              <description>[7:3] Number of 32 KHz clocks between oscillator amplitude calibrations.
When this counter expires, an oscillator amplitude compensation is triggered immediately in Active mode. When this counter expires in Powerdown mode an internal flag is set such that the amplitude compensation is postponed until the next recharge occurs.

The Period will effectively be a 16 bit value coded in a 5 bit mantissa and 3 bit exponent
PERIOD=(PER_M*16+15)*2^PER_E
This field sets the mantissa
Note: Oscillator amplitude calibration is turned of when both this bitfield and PER_E are set to 0</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PER_E</name>
              <description>[2:0] Number of 32 KHz clocks between oscillator amplitude calibrations.
When this counter expires, an oscillator amplitude compensation is triggered immediately in Active mode. When this counter expires in Powerdown mode an internal flag is set such that the amplitude compensation is postponed until the next recharge occurs.
The Period will effectively be a 16 bit value coded in a 5 bit mantissa and 3 bit exponent
PERIOD=(PER_M*16+15)*2^PER_E
This field sets the exponent
Note: Oscillator amplitude calibration is turned of when both  PER_M and this bitfield are set to 0</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>JTAGCFG</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>JTAG Configuration

This register contains control for configuration of the JTAG domain,- hereunder access permissions for each TAP.</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>JTAG_PD_FORCE_ON</name>
              <description>[8:8] Controls JTAG PowerDomain power state:

0: Controlled exclusively by debug subsystem. (JTAG Powerdomain will be powered off unless a debugger is attached)
1: JTAG Power Domain is forced on, independent of debug subsystem.

NB: The reset value causes JTAG Power Domain to be powered on by default. Software must clear this bit to turn off the JTAG Power Domain</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[7:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x100</resetValue>
        </register>
        <register>
          <name>JTAGUSERCODE</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>JTAG USERCODE

Boot code copies the JTAG USERCODE to this register from where it is forwarded to the debug subsystem.</description>
          <fields>
            <field>
              <name>USER_CODE</name>
              <description>[31:0] 32-bit JTAG USERCODE register feeding main JTAG TAP
NB: This field can be locked</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xB99A02F</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUX_ADI4</name>
      <baseAddress>0x400CB000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x200</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Configuration registers controlling analog peripherals of AUX. Registers Fields should be considered static unless otherwise noted (as dynamic)</description>
      <registers>
        <register>
          <name>MUX0</name>
          <addressOffset>0x0</addressOffset>
          <size>8</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[7:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>COMPA_REF</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADCVREFP</name>
                  <value>8</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDS</name>
                  <value>4</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VSS</name>
                  <value>2</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DCOUPL</name>
                  <value>1</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NC</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MUX1</name>
          <addressOffset>0x1</addressOffset>
          <size>8</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>COMPA_IN</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>128</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>64</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>32</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>8</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>4</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>2</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>1</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NC</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MUX2</name>
          <addressOffset>0x2</addressOffset>
          <size>8</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>ADCCOMPB_IN</name>
              <description>[7:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VDDS</name>
                  <value>16</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VSS</name>
                  <value>8</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DCOUPL</name>
                  <value>4</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ATEST1</name>
                  <value>2</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ATEST0</name>
                  <value>1</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NC</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMPB_REF</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VDDS</name>
                  <value>4</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VSS</name>
                  <value>2</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DCOUPL</name>
                  <value>1</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NC</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MUX3</name>
          <addressOffset>0x3</addressOffset>
          <size>8</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>ADCCOMPB_IN</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>128</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>64</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>32</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>8</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>4</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>2</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>1</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NC</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ISRC</name>
          <addressOffset>0x4</addressOffset>
          <size>8</size>
          <description>Current Source

Strength and trim control for current source. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>TRIM</name>
              <description>[7:2] Adjust current from current source.

Output currents may be combined to get desired total current.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>11P75U</name>
                  <value>32</value>
                  <description>11.75 uA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4P5U</name>
                  <value>16</value>
                  <description>4.5 uA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2P0U</name>
                  <value>8</value>
                  <description>2.0 uA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1P0U</name>
                  <value>4</value>
                  <description>1.0 uA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>0P5U</name>
                  <value>2</value>
                  <description>0.5 uA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>0P25U</name>
                  <value>1</value>
                  <description>0.25 uA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NC</name>
                  <value>0</value>
                  <description>No current connected</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[1:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] Current source enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>COMP</name>
          <addressOffset>0x5</addressOffset>
          <size>8</size>
          <description>Comparator

Control COMPA and COMPB comparators. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>COMPA_REF_RES_EN</name>
              <description>[7:7] Enables 400kohm resistance from COMPA reference node to ground. Used with COMPA_REF_CURR_EN to generate voltage reference for cap-sense.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>COMPA_REF_CURR_EN</name>
              <description>[6:6] Enables 2uA IPTAT current from ISRC to COMPA reference node. Requires ISRC.EN = 1. Used with COMPA_REF_RES_EN to generate voltage reference for cap-sense.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>COMPB_TRIM</name>
              <description>[5:3] COMPB voltage reference trim temperature coded:</description>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIV4</name>
                  <value>7</value>
                  <description>Divide reference by 4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV3</name>
                  <value>3</value>
                  <description>Divide reference by 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV2</name>
                  <value>1</value>
                  <description>Divide reference by 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV1</name>
                  <value>0</value>
                  <description>No reference division</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMPB_EN</name>
              <description>[2:2] COMPB enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[1:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>COMPA_EN</name>
              <description>[0:0] COMPA enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MUX4</name>
          <addressOffset>0x7</addressOffset>
          <size>8</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>COMPA_REF</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>128</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>64</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>32</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>8</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>4</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>2</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>1</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NC</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ADC0</name>
          <addressOffset>0x8</addressOffset>
          <size>8</size>
          <description>ADC Control 0

ADC Sample Control. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>SMPL_MODE</name>
              <description>[7:7] ADC Sampling mode:

0: Synchronous mode
1: Asynchronous mode

The ADC does a sample-and-hold before conversion. In synchronous mode the sampling starts when the ADC clock detects a rising edge on the trigger signal. Jitter/uncertainty will be inferred in the detection if the trigger signal originates from a domain that is asynchronous to the ADC clock. SMPL_CYCLE_EXP  determines the the duration of sampling.
Conversion starts immediately after sampling ends.

In asynchronous mode the sampling is continuous when enabled. Sampling ends and conversion starts immediately with the rising edge of the trigger signal. Sampling restarts when the conversion has finished.
Asynchronous mode is useful when it is important to avoid jitter in the sampling instant of an externally driven signal</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SMPL_CYCLE_EXP</name>
              <description>[6:3] Controls the sampling duration before conversion when the ADC is operated in synchronous mode (SMPL_MODE = 0). The setting has no effect in asynchronous mode. The sampling duration is given as 2^(SMPL_CYCLE_EXP + 1) / 6 us.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>10P9_MS</name>
                  <value>15</value>
                  <description>65536x 6 MHz clock periods = 10.9ms</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>5P46_MS</name>
                  <value>14</value>
                  <description>32768x 6 MHz clock periods = 5.46ms</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2P73_MS</name>
                  <value>13</value>
                  <description>16384x 6 MHz clock periods = 2.73ms</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1P37_MS</name>
                  <value>12</value>
                  <description>8192x 6 MHz clock periods = 1.37ms</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>682_US</name>
                  <value>11</value>
                  <description>4096x 6 MHz clock periods = 682us</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>341_US</name>
                  <value>10</value>
                  <description>2048x 6 MHz clock periods = 341us</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>170_US</name>
                  <value>9</value>
                  <description>1024x 6 MHz clock periods = 170us</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>85P3_US</name>
                  <value>8</value>
                  <description>512x 6 MHz clock periods = 85.3us</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>42P6_US</name>
                  <value>7</value>
                  <description>256x 6 MHz clock periods = 42.6us</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>21P3_US</name>
                  <value>6</value>
                  <description>128x 6 MHz clock periods = 21.3us</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>10P6_US</name>
                  <value>5</value>
                  <description>64x 6 MHz clock periods = 10.6us</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>5P3_US</name>
                  <value>4</value>
                  <description>32x 6 MHz clock periods = 5.3us</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2P7_US</name>
                  <value>3</value>
                  <description>16x 6 MHz clock periods = 2.7us</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[2:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESET_N</name>
              <description>[1:1] Reset ADC digital subchip, active low. ADC must be reset every time it is reconfigured.

0: Reset
1: Normal operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] ADC Enable

0: Disable
1: Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ADC1</name>
          <addressOffset>0x9</addressOffset>
          <size>8</size>
          <description>ADC Control 1

ADC Comparator Control. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SCALE_DIS</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ADCREF0</name>
          <addressOffset>0xa</addressOffset>
          <size>8</size>
          <description>ADC Reference 0

Control reference used by the ADC. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED7</name>
              <description>[7:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>REF_ON_IDLE</name>
              <description>[6:6] Keep ADCREF powered up in IDLE state when ADC0.SMPL_MODE = 0.

Set to 1 if ADC0.SMPL_CYCLE_EXP is less than 6 (21.3us sampling time)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>IOMUX</name>
              <description>[5:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>EXT</name>
              <description>[4:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SRC</name>
              <description>[3:3] ADC reference source:

0: Fixed reference = 4.3V
1: Relative reference = VDDS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[2:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] ADC reference module enable:

0: ADC reference module powered down
1: ADC reference module enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ADCREF1</name>
          <addressOffset>0xb</addressOffset>
          <size>8</size>
          <description>ADC Reference 1

Control reference used by the ADC. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>VTRIM</name>
              <description>[5:0] Trim output voltage of ADC fixed reference (64 steps, 2's complement). Applies only for ADCREF0.SRC = 0.

Examples:
0x00 - nominal voltage 1.43V
0x01 - nominal + 0.4% 1.435V
0x3F - nominal - 0.4% 1.425V
0x1F - maximum voltage 1.6V
0x20 - minimum voltage 1.3V</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUX_AIODIO0</name>
      <baseAddress>0x400C1000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>AUX Analog/Digital Input Output Controller</description>
      <registers>
        <register>
          <name>GPIODOUT</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>General Purpose Input Output Data Out

The output data register is used to set data on AUXIO that are controlled by instance i of AUX_AIODIO.  Hence, in formulas below i = 0 for AUX_AIODIO0 and  i = 1 for AUX_AIODIO1</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IO7_0</name>
              <description>[7:0] Write 1 to bit index n in this bit vector to set AUXIO[8i+n].
Write 0 to bit index n in this bit vector to clear AUXIO[8i+n].</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IOMODE</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Input Output Mode

This register controls pull-up, pull-down, and output mode for AUXIO that are controlled by instance i of AUX_AIODIO. Hence, in formulas below i = 0 for AUX_AIODIO0 and i = 1 for AUX_AIODIO1</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>IO7</name>
              <description>[15:14] Select mode for AUXIO[8i+7].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 7 is 0: AUXIO[8i+7] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 7 is 1: AUXIO[8i+7] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 7 is 0: AUXIO[8i+7] is driven low.  

When GPIODOUT bit 7 is 1: AUXIO[8i+7] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 7 is 0: AUXIO[8i+7] is enabled for analog signal transfer.

When GPIODIE bit 7 is 1: AUXIO[8i+7] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 7 drives AUXIO[8i+7].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO6</name>
              <description>[13:12] Select mode for AUXIO[8i+6].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 6 is 0: AUXIO[8i+6] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 6 is 1: AUXIO[8i+6] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 6 is 0: AUXIO[8i+6] is driven low.  

When GPIODOUT bit 6 is 1: AUXIO[8i+6] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 6 is 0: AUXIO[8i+6] is enabled for analog signal transfer.

When GPIODIE bit 6 is 1: AUXIO[8i+6] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 6 drives AUXIO[8i+6].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO5</name>
              <description>[11:10] Select mode for AUXIO[8i+5].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 5 is 0: AUXIO[8i+5] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 5 is 1: AUXIO[8i+5] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 5 is 0: AUXIO[8i+5] is driven low.  

When GPIODOUT bit 5 is 1: AUXIO[8i+5] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 5 is 0: AUXIO[8i+5] is enabled for analog signal transfer.

When GPIODIE bit 5 is 1: AUXIO[8i+5] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 5 drives AUXIO[8i+5].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO4</name>
              <description>[9:8] Select mode for AUXIO[8i+4].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 4 is 0: AUXIO[8i+4] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 4 is 1: AUXIO[8i+4] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 4 is 0: AUXIO[8i+4] is driven low.  

When GPIODOUT bit 4 is 1: AUXIO[8i+4] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 4 is 0: AUXIO[8i+4] is enabled for analog signal transfer.

When GPIODIE bit 4 is 1: AUXIO[8i+4] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 4 drives AUXIO[8i+4].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO3</name>
              <description>[7:6] Select mode for AUXIO[8i+3].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 3 is 0: AUXIO[8i+3] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 3 is 1: AUXIO[8i+3] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 3 is 0: AUXIO[8i+3] is driven low.  

When GPIODOUT bit 3 is 1: AUXIO[8i+3] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 3 is 0: AUXIO[8i+3] is enabled for analog signal transfer.

When GPIODIE bit 3 is 1: AUXIO[8i+3] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 3 drives AUXIO[8i+3].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO2</name>
              <description>[5:4] Select mode for AUXIO[8i+2].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 2 is 0: AUXIO[8i+2] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 2 is 1: AUXIO[8i+2] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 2 is 0: AUXIO[8i+2] is driven low.  

When GPIODOUT bit 2 is 1: AUXIO[8i+2] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 2 is 0: AUXIO[8i+2] is enabled for analog signal transfer.

When GPIODIE bit 2 is 1: AUXIO[8i+2] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 2 drives AUXIO[8i+2].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO1</name>
              <description>[3:2] Select mode for AUXIO[8i+1].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 1 is 0: AUXIO[8i+1] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 1 is 1: AUXIO[8i+1] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 1 is 0: AUXIO[8i+1] is driven low.  

When GPIODOUT bit 1 is 1: AUXIO[8i+1] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 1 is 0: AUXIO[8i+1] is enabled for analog signal transfer.

When GPIODIE bit 1 is 1: AUXIO[8i+1] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 1 drives AUXIO[8i+1].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO0</name>
              <description>[1:0] Select mode for AUXIO[8i+0].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 0 is 0: AUXIO[8i+0] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 0 is 1: AUXIO[8i+0] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 0 is 0: AUXIO[8i+0] is driven low.  

When GPIODOUT bit 0 is 1: AUXIO[8i+0] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 0 is 0: AUXIO[8i+0] is enabled for analog signal transfer.

When GPIODIE bit 0 is 1: AUXIO[8i+0] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 0 drives AUXIO[8i+0].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIODIN</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>General Purpose Input Output Data In

This register provides synchronized input data for AUXIO  that are controlled by instance i of AUX_AIODIO. Hence, in formulas below i = 0 for AUX_AIODIO0 and I = 1 for AUX_AIODIO1.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IO7_0</name>
              <description>[7:0] Bit n in this bit vector contains the value for AUXIO[8i+n] when GPIODIE bit n is set. Otherwise, bit n value is old.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIODOUTSET</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>General Purpose Input Output Data Out Set

Set bits in GPIODOUT in instance i of AUX_AIODIO. Hence, in formulas below i = 0 for AUX_AIODIO0 and  i = 1 for AUX_AIODIO1.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IO7_0</name>
              <description>[7:0] Write 1 to bit index n in this bit vector to set GPIODOUT bit n. 

Read value is 0.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIODOUTCLR</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>General Purpose Input Output Data Out Clear

Clear bits in GPIODOUT instance i of AUX_AIODIO. Hence, in formulas below i = 0 for AUX_AIODIO0 and i = 1 for AUX_AIODIO1.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IO7_0</name>
              <description>[7:0] Write 1 to bit index n in this bit vector to clear GPIODOUT bit n.

Read value is 0.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIODOUTTGL</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>General Purpose Input Output Data Out Toggle

Toggle bits in GPIODOUT in instance i of AUX_AIODIO. Hence, in formulas below i = 0 for AUX_AIODIO0 and i = 1 for AUX_AIODIO1.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IO7_0</name>
              <description>[7:0] Write 1 to bit index n in this bit vector to toggle GPIODOUT bit n. 

Read value is 0.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIODIE</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>General Purpose Input Output Digital Input Enable

This register controls input buffers for AUXIO that are controlled by instance i of AUX_AIODIO.  Hence, in formulas below i = 0 for AUX_AIODIO0 and I = 1 for AUX_AIODIO1.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IO7_0</name>
              <description>[7:0] Write 1 to bit index n in this bit vector to enable digital input buffer for AUXIO[8i+n]. 
Write 0 to bit index n in this bit vector to disable digital input buffer for AUXIO[8i+n].

You must enable the digital input buffer for AUXIO[8i+n] to read the pin value in GPIODIN.  
You must disable the digital input buffer for analog input or pins that float to avoid current leakage.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUX_AIODIO1</name>
      <baseAddress>0x400C2000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>AUX Analog/Digital Input Output Controller</description>
      <registers>
        <register>
          <name>GPIODOUT</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>General Purpose Input Output Data Out

The output data register is used to set data on AUXIO that are controlled by instance i of AUX_AIODIO.  Hence, in formulas below i = 0 for AUX_AIODIO0 and  i = 1 for AUX_AIODIO1</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IO7_0</name>
              <description>[7:0] Write 1 to bit index n in this bit vector to set AUXIO[8i+n].
Write 0 to bit index n in this bit vector to clear AUXIO[8i+n].</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IOMODE</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Input Output Mode

This register controls pull-up, pull-down, and output mode for AUXIO that are controlled by instance i of AUX_AIODIO. Hence, in formulas below i = 0 for AUX_AIODIO0 and i = 1 for AUX_AIODIO1</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>IO7</name>
              <description>[15:14] Select mode for AUXIO[8i+7].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 7 is 0: AUXIO[8i+7] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 7 is 1: AUXIO[8i+7] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 7 is 0: AUXIO[8i+7] is driven low.  

When GPIODOUT bit 7 is 1: AUXIO[8i+7] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 7 is 0: AUXIO[8i+7] is enabled for analog signal transfer.

When GPIODIE bit 7 is 1: AUXIO[8i+7] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 7 drives AUXIO[8i+7].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO6</name>
              <description>[13:12] Select mode for AUXIO[8i+6].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 6 is 0: AUXIO[8i+6] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 6 is 1: AUXIO[8i+6] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 6 is 0: AUXIO[8i+6] is driven low.  

When GPIODOUT bit 6 is 1: AUXIO[8i+6] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 6 is 0: AUXIO[8i+6] is enabled for analog signal transfer.

When GPIODIE bit 6 is 1: AUXIO[8i+6] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 6 drives AUXIO[8i+6].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO5</name>
              <description>[11:10] Select mode for AUXIO[8i+5].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 5 is 0: AUXIO[8i+5] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 5 is 1: AUXIO[8i+5] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 5 is 0: AUXIO[8i+5] is driven low.  

When GPIODOUT bit 5 is 1: AUXIO[8i+5] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 5 is 0: AUXIO[8i+5] is enabled for analog signal transfer.

When GPIODIE bit 5 is 1: AUXIO[8i+5] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 5 drives AUXIO[8i+5].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO4</name>
              <description>[9:8] Select mode for AUXIO[8i+4].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 4 is 0: AUXIO[8i+4] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 4 is 1: AUXIO[8i+4] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 4 is 0: AUXIO[8i+4] is driven low.  

When GPIODOUT bit 4 is 1: AUXIO[8i+4] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 4 is 0: AUXIO[8i+4] is enabled for analog signal transfer.

When GPIODIE bit 4 is 1: AUXIO[8i+4] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 4 drives AUXIO[8i+4].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO3</name>
              <description>[7:6] Select mode for AUXIO[8i+3].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 3 is 0: AUXIO[8i+3] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 3 is 1: AUXIO[8i+3] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 3 is 0: AUXIO[8i+3] is driven low.  

When GPIODOUT bit 3 is 1: AUXIO[8i+3] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 3 is 0: AUXIO[8i+3] is enabled for analog signal transfer.

When GPIODIE bit 3 is 1: AUXIO[8i+3] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 3 drives AUXIO[8i+3].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO2</name>
              <description>[5:4] Select mode for AUXIO[8i+2].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 2 is 0: AUXIO[8i+2] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 2 is 1: AUXIO[8i+2] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 2 is 0: AUXIO[8i+2] is driven low.  

When GPIODOUT bit 2 is 1: AUXIO[8i+2] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 2 is 0: AUXIO[8i+2] is enabled for analog signal transfer.

When GPIODIE bit 2 is 1: AUXIO[8i+2] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 2 drives AUXIO[8i+2].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO1</name>
              <description>[3:2] Select mode for AUXIO[8i+1].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 1 is 0: AUXIO[8i+1] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 1 is 1: AUXIO[8i+1] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 1 is 0: AUXIO[8i+1] is driven low.  

When GPIODOUT bit 1 is 1: AUXIO[8i+1] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 1 is 0: AUXIO[8i+1] is enabled for analog signal transfer.

When GPIODIE bit 1 is 1: AUXIO[8i+1] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 1 drives AUXIO[8i+1].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IO0</name>
              <description>[1:0] Select mode for AUXIO[8i+0].</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN_SOURCE</name>
                  <value>3</value>
                  <description>Open-Source Mode: 

When GPIODOUT bit 0 is 0: AUXIO[8i+0] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.

When GPIODOUT bit 0 is 1: AUXIO[8i+0] is driven high.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPEN_DRAIN</name>
                  <value>2</value>
                  <description>Open-Drain Mode: 

When GPIODOUT bit 0 is 0: AUXIO[8i+0] is driven low.  

When GPIODOUT bit 0 is 1: AUXIO[8i+0] is tri-stated or pulled. This depends on IOC:IOCFGn.PULL_CTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input Mode:

When GPIODIE bit 0 is 0: AUXIO[8i+0] is enabled for analog signal transfer.

When GPIODIE bit 0 is 1: AUXIO[8i+0] is enabled for digital input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>0</value>
                  <description>Output Mode:

GPIODOUT bit 0 drives AUXIO[8i+0].</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIODIN</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>General Purpose Input Output Data In

This register provides synchronized input data for AUXIO  that are controlled by instance i of AUX_AIODIO. Hence, in formulas below i = 0 for AUX_AIODIO0 and I = 1 for AUX_AIODIO1.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IO7_0</name>
              <description>[7:0] Bit n in this bit vector contains the value for AUXIO[8i+n] when GPIODIE bit n is set. Otherwise, bit n value is old.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIODOUTSET</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>General Purpose Input Output Data Out Set

Set bits in GPIODOUT in instance i of AUX_AIODIO. Hence, in formulas below i = 0 for AUX_AIODIO0 and  i = 1 for AUX_AIODIO1.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IO7_0</name>
              <description>[7:0] Write 1 to bit index n in this bit vector to set GPIODOUT bit n. 

Read value is 0.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIODOUTCLR</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>General Purpose Input Output Data Out Clear

Clear bits in GPIODOUT instance i of AUX_AIODIO. Hence, in formulas below i = 0 for AUX_AIODIO0 and i = 1 for AUX_AIODIO1.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IO7_0</name>
              <description>[7:0] Write 1 to bit index n in this bit vector to clear GPIODOUT bit n.

Read value is 0.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIODOUTTGL</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>General Purpose Input Output Data Out Toggle

Toggle bits in GPIODOUT in instance i of AUX_AIODIO. Hence, in formulas below i = 0 for AUX_AIODIO0 and i = 1 for AUX_AIODIO1.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IO7_0</name>
              <description>[7:0] Write 1 to bit index n in this bit vector to toggle GPIODOUT bit n. 

Read value is 0.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIODIE</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>General Purpose Input Output Digital Input Enable

This register controls input buffers for AUXIO that are controlled by instance i of AUX_AIODIO.  Hence, in formulas below i = 0 for AUX_AIODIO0 and I = 1 for AUX_AIODIO1.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>IO7_0</name>
              <description>[7:0] Write 1 to bit index n in this bit vector to enable digital input buffer for AUXIO[8i+n]. 
Write 0 to bit index n in this bit vector to disable digital input buffer for AUXIO[8i+n].

You must enable the digital input buffer for AUXIO[8i+n] to read the pin value in GPIODIN.  
You must disable the digital input buffer for analog input or pins that float to avoid current leakage.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUX_ANAIF</name>
      <baseAddress>0x400C9000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>AUX Analog Peripheral Control Module</description>
      <registers>
        <register>
          <name>ADCCTL</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>ADC Control

Configuration of ADI_4_AUX:ADC0.SMPL_MODE decides if the ADC trigger starts sampling or conversion.</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>START_POL</name>
              <description>[13:13] Select active polarity for START_SRC event.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FALL</name>
                  <value>1</value>
                  <description>Set ADC trigger on falling edge of event source.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISE</name>
                  <value>0</value>
                  <description>Set ADC trigger on rising edge of event source.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>START_SRC</name>
              <description>[12:8] Select ADC trigger event source from the asynchronous AUX event bus.

Set START_SRC to NO_EVENT&lt;n> if you want to trigger the ADC manually through ADCTRIG.START.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADC_IRQ</name>
                  <value>31</value>
                  <description>AUX_EVCTL:EVSTAT1.ADC_IRQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCU_EV</name>
                  <value>30</value>
                  <description>AUX_EVCTL:EVSTAT1.MCU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACLK_REF</name>
                  <value>29</value>
                  <description>AUX_EVCTL:EVSTAT1.ACLK_REF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO15</name>
                  <value>28</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO14</name>
                  <value>27</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO13</name>
                  <value>26</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO12</name>
                  <value>25</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO11</name>
                  <value>24</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO10</name>
                  <value>23</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO9</name>
                  <value>22</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO8</name>
                  <value>21</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>20</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>19</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>18</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>17</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>15</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>14</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>13</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG_WU</name>
                  <value>12</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_PROG_WU</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_SW</name>
                  <value>11</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_SW</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NO_EVENT1</name>
                  <value>10</value>
                  <description>No event.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NO_EVENT0</name>
                  <value>9</value>
                  <description>No event.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED1</name>
                  <value>8</value>
                  <description>Reserved - Do not use.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESERVED0</name>
                  <value>7</value>
                  <description>Reserved - Do not use.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SMPH_AUTOTAKE_DONE</name>
                  <value>6</value>
                  <description>AUX_EVCTL:EVSTAT0.SMPH_AUTOTAKE_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER1_EV</name>
                  <value>5</value>
                  <description>AUX_EVCTL:EVSTAT0.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER0_EV</name>
                  <value>4</value>
                  <description>AUX_EVCTL:EVSTAT0.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDC_DONE</name>
                  <value>3</value>
                  <description>AUX_EVCTL:EVSTAT0.TDC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>2</value>
                  <description>AUX_EVCTL:EVSTAT0.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>1</value>
                  <description>AUX_EVCTL:EVSTAT0.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_EV</name>
                  <value>0</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_RTC_CH2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[7:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CMD</name>
              <description>[1:0] ADC interface command.

Non-enumerated values are not supported. The written value is returned when read.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FLUSH</name>
                  <value>3</value>
                  <description>Flush ADC FIFO.

You must set CMD to EN or DIS after flush.

System CPU must wait two clock cycles before it sets CMD to EN or DIS.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable ADC interface.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable ADC interface.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ADCFIFOSTAT</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>ADC FIFO Status

FIFO can hold up to four ADC samples.</description>
          <fields>
            <field>
              <name>RESERVED5</name>
              <description>[31:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>[4:4] FIFO overflow flag.

0: FIFO has not overflowed.
1: FIFO has overflowed, this flag is sticky until you flush the FIFO.

When the flag is set, the ADC FIFO write pointer is static. It is not possible to add more samples to the ADC FIFO. Flush FIFO to clear the flag.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>[3:3] FIFO underflow flag.

0: FIFO has not underflowed.
1: FIFO has underflowed, this flag is sticky until you flush the FIFO.

When the flag is set, the ADC FIFO read pointer is static. Read returns the previous sample that was read. Flush FIFO to clear the flag.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>FULL</name>
              <description>[2:2] FIFO full flag.

0: FIFO is not full, there is less than 4 samples in the FIFO. 
1: FIFO is full, there are 4 samples in the FIFO.

When the flag is set, it is not possible to add more samples to the ADC FIFO. An attempt to add samples sets the OVERFLOW flag.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ALMOST_FULL</name>
              <description>[1:1] FIFO almost full flag.

0: There are less than 3 samples in the FIFO, or the FIFO is full. The FULL flag is also asserted in the latter case.
1: There are 3 samples in the FIFO, there is room for one more sample.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EMPTY</name>
              <description>[0:0] FIFO empty flag.

0: FIFO contains one or more samples.
1: FIFO is empty.

When the flag is set, read returns the previous sample that was read and sets the UNDERFLOW flag.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>ADCFIFO</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>ADC FIFO</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[11:0] FIFO data.

Read:
Get oldest ADC sample from FIFO.

Write:
Write dummy sample to FIFO. This is useful for code development when you do not have real ADC samples.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ADCTRIG</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>ADC Trigger</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>START</name>
              <description>[0:0] Manual ADC trigger. 

0: No effect.
1: Single ADC trigger. 

To manually trigger the ADC, you must set ADCCTL.START_SRC to NO_EVENT&lt;n> to avoid conflict with event-driven ADC trigger.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ISRCCTL</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Current Source Control</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESET_N</name>
              <description>[0:0] ISRC reset control.

0: ISRC drives 0 uA.
1: ISRC drives current ADI_4_AUX:ISRC.TRIM to COMPA_IN.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUX_DDI0_OSC</name>
      <baseAddress>0x400CA000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>This is the DDI for the digital block that controls all the analog clock oscillators  (OSC_DIG) and performs qualification of the clocks generated.</description>
      <registers>
        <register>
          <name>CTL0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Control 0
Controls clock source selects</description>
          <fields>
            <field>
              <name>XTAL_IS_24M</name>
              <description>[31:31] Set based on the accurate high frequency XTAL.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>24M</name>
                  <value>1</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>48M</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED30</name>
              <description>[30:30] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>BYPASS_XOSC_LF_CLK_QUAL</name>
              <description>[29:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>BYPASS_RCOSC_LF_CLK_QUAL</name>
              <description>[28:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>DOUBLER_START_DURATION</name>
              <description>[27:26] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>DOUBLER_RESET_DURATION</name>
              <description>[25:25] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>RESERVED23</name>
              <description>[24:23] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>FORCE_KICKSTART_EN</name>
              <description>[22:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>RESERVED17</name>
              <description>[21:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>ALLOW_SCLK_HF_SWITCHING</name>
              <description>[16:16] 0: Default - Switching of HF clock source is disabled .
1: Allows switching of sclk_hf source.

Provided to prevent switching of the SCLK_HF source when running from flash (a long period during switching could corrupt flash). When sclk_hf  switching is disabled, a new source can be started when SCLK_HF_SRC_SEL is changed, but the switch will not occur until this bit is set.  This bit should be set to enable clock switching after STAT0.PENDINGSCLKHFSWITCHING indicates  the new HF clock is ready. When switching completes (also indicated by STAT0.PENDINGSCLKHFSWITCHING)  sclk_hf switching should be disabled to prevent flash corruption.  Switching should not be enabled when running from flash.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>HPOSC_MODE_EN</name>
              <description>[14:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>RESERVED13</name>
              <description>[13:13] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RCOSC_LF_TRIMMED</name>
              <description>[12:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_POWER_MODE</name>
              <description>[11:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>XOSC_LF_DIG_BYPASS</name>
              <description>[10:10] Bypass XOSC_LF and use the digital input clock from AON for the xosc_lf clock.

0: Use 32kHz XOSC as xosc_lf clock source
1: Use digital input (from AON) as xosc_lf clock source.

This bit will only have effect when SCLK_LF_SRC_SEL is selecting the xosc_lf as the sclk_lf source. The muxing performed by this bit is not glitch free. The following procedure must be followed when changing this field to avoid glitches on sclk_lf.

1) Set SCLK_LF_SRC_SEL to select any source other than the xosc_lf clock source.
2) Set or clear this bit to bypass or not bypass the xosc_lf.
3) Set SCLK_LF_SRC_SEL to use xosc_lf.

It is recommended that either the rcosc_hf or xosc_hf (whichever is currently active) be selected as the source in step 1 above. This provides a faster clock change.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CLK_LOSS_EN</name>
              <description>[9:9] Enable clock loss detection and hence the indicators to system controller.  Checks both SCLK_HF and SCLK_LF clock loss indicators.

0: Disable
1: Enable

Clock loss detection must be disabled when changing the sclk_lf source.  STAT0.SCLK_LF_SRC can be polled to determine when a change to a new sclk_lf source has completed.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>ACLK_TDC_SRC_SEL</name>
              <description>[8:7] Source select for aclk_tdc.

00: RCOSC_HF (48MHz)
01: RCOSC_HF (24MHz)
10: XOSC_HF (24MHz)
11: Not used</description>
              <bitWidth>2</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ACLK_REF_SRC_SEL</name>
              <description>[6:5] Source select for aclk_ref

00: RCOSC_HF derived (31.25kHz)
01: XOSC_HF derived (31.25kHz)
10: RCOSC_LF (32kHz)
11: XOSC_LF (32.768kHz)</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>SPARE4</name>
              <description>[4:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SCLK_LF_SRC_SEL</name>
              <description>[3:2] Source select for sclk_lf</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>XOSCLF</name>
                  <value>3</value>
                  <description>Low frequency XOSC</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RCOSCLF</name>
                  <value>2</value>
                  <description>Low frequency RCOSC</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XOSCHFDLF</name>
                  <value>1</value>
                  <description>Low frequency clock derived from High Frequency XOSC</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RCOSCHFDLF</name>
                  <value>0</value>
                  <description>Low frequency clock derived from High Frequency RCOSC</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCLK_MF_SRC_SEL</name>
              <description>[1:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>XCOSCHFDMF</name>
                  <value>1</value>
                  <description>Medium frequency clock derived from high frequency XOSC.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RCOSCHFDMF</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCLK_HF_SRC_SEL</name>
              <description>[0:0] Source select for sclk_hf.  XOSC option is supported for test and debug only and should be used when the XOSC_HF is running.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>XOSC</name>
                  <value>1</value>
                  <description>High frequency XOSC clk</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RCOSC</name>
                  <value>0</value>
                  <description>High frequency RCOSC clock</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CTL1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Control 1
This register contains OSC_DIG configuration</description>
          <fields>
            <field>
              <name>RESERVED23</name>
              <description>[31:23] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>9</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>RCOSCHFCTRIMFRACT</name>
              <description>[22:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RCOSCHFCTRIMFRACT_EN</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>SPARE2</name>
              <description>[16:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_FAST_START</name>
              <description>[1:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RADCEXTCFG</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>RADC External Configuration</description>
          <fields>
            <field>
              <name>HPM_IBIAS_WAIT_CNT</name>
              <description>[31:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>LPM_IBIAS_WAIT_CNT</name>
              <description>[21:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>IDAC_STEP</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RADC_DAC_TH</name>
              <description>[11:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RADC_MODE_IS_SAR</name>
              <description>[5:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[4:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AMPCOMPCTL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Amplitude Compensation Control</description>
          <fields>
            <field>
              <name>SPARE31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>AMPCOMP_REQ_MODE</name>
              <description>[30:30] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>AMPCOMP_FSM_UPDATE_RATE</name>
              <description>[29:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>28</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>250KHZ</name>
                  <value>3</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>500KHZ</name>
                  <value>2</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1MHZ</name>
                  <value>1</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MHZ</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AMPCOMP_SW_CTRL</name>
              <description>[27:27] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>AMPCOMP_SW_EN</name>
              <description>[26:26] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>RESERVED24</name>
              <description>[25:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>IBIAS_OFFSET</name>
              <description>[23:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>IBIAS_INIT</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LPM_IBIAS_WAIT_CNT_FINAL</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CAP_STEP</name>
              <description>[7:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>IBIASCAP_HPTOLP_OL_CNT</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AMPCOMPTH1</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Amplitude Compensation Threshold 1
This register contains threshold values for amplitude compensation algorithm</description>
          <fields>
            <field>
              <name>SPARE24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>HPMRAMP3_LTH</name>
              <description>[23:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>SPARE16</name>
              <description>[17:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>HPMRAMP3_HTH</name>
              <description>[15:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>IBIASCAP_LPTOHP_OL_CNT</name>
              <description>[9:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>HPMRAMP1_TH</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AMPCOMPTH2</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Amplitude Compensation Threshold 2
This register contains threshold values for amplitude compensation algorithm.</description>
          <fields>
            <field>
              <name>LPMUPDATE_LTH</name>
              <description>[31:26] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>SPARE24</name>
              <description>[25:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>LPMUPDATE_HTH</name>
              <description>[23:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>SPARE16</name>
              <description>[17:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>ADC_COMP_AMPTH_LPM</name>
              <description>[15:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>SPARE8</name>
              <description>[9:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADC_COMP_AMPTH_HPM</name>
              <description>[7:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SPARE0</name>
              <description>[1:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ANABYPASSVAL1</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Analog Bypass Values 1</description>
          <fields>
            <field>
              <name>RESERVED20</name>
              <description>[31:20] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_ROW_Q12</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_COLUMN_Q12</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ANABYPASSVAL2</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_IBIASTHERM</name>
              <description>[13:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>14</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ATESTCTL</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Analog Test Control</description>
          <fields>
            <field>
              <name>SPARE30</name>
              <description>[31:30] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>SCLK_LF_AUX_EN</name>
              <description>[29:29] Enable 32 kHz clock to AUX_COMPB.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[28:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ADCDOUBLERNANOAMPCTL</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>ADC Doubler Nanoamp Control</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>NANOAMP_BIAS_ENABLE</name>
              <description>[24:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>SPARE23</name>
              <description>[23:23] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[22:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>ADC_SH_MODE_EN</name>
              <description>[5:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>ADC_SH_VBUF_EN</name>
              <description>[4:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[3:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ADC_IREF_CTRL</name>
              <description>[1:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>XOSCHFCTL</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>XOSCHF Control</description>
          <fields>
            <field>
              <name>RESERVED10</name>
              <description>[31:10] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>22</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PEAK_DET_ITRIM</name>
              <description>[9:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>[7:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>BYPASS</name>
              <description>[6:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[5:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>HP_BUF_ITRIM</name>
              <description>[4:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>LP_BUF_ITRIM</name>
              <description>[1:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>LFOSCCTL</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Low Frequency Oscillator Control</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>XOSCLF_REGULATOR_TRIM</name>
              <description>[23:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>XOSCLF_CMIRRWR_RATIO</name>
              <description>[21:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RESERVED10</name>
              <description>[17:10] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RCOSCLF_RTUNE_TRIM</name>
              <description>[9:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>6P0MEG</name>
                  <value>3</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>6P5MEG</name>
                  <value>2</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>7P0MEG</name>
                  <value>1</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>7P5MEG</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RCOSCLF_CTUNE_TRIM</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RCOSCHFCTL</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>RCOSCHF Control</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RCOSCHF_CTRIM</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[7:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STAT0</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Status 0
This register contains status signals from OSC_DIG</description>
          <fields>
            <field>
              <name>SPARE31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>SCLK_LF_SRC</name>
              <description>[30:29] Indicates source for the sclk_lf</description>
              <bitWidth>2</bitWidth>
              <bitOffset>29</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>XOSCLF</name>
                  <value>3</value>
                  <description>Low frequency XOSC</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RCOSCLF</name>
                  <value>2</value>
                  <description>Low frequency RCOSC</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XOSCHFDLF</name>
                  <value>1</value>
                  <description>Low frequency clock derived from High Frequency XOSC</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RCOSCHFDLF</name>
                  <value>0</value>
                  <description>Low frequency clock derived from High Frequency RCOSC</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCLK_HF_SRC</name>
              <description>[28:28] Indicates source for the sclk_hf</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>XOSC</name>
                  <value>1</value>
                  <description>High frequency XOSC</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RCOSC</name>
                  <value>0</value>
                  <description>High frequency RCOSC clock</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED23</name>
              <description>[27:23] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>RCOSC_HF_EN</name>
              <description>[22:22] RCOSC_HF_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>RCOSC_LF_EN</name>
              <description>[21:21] RCOSC_LF_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>XOSC_LF_EN</name>
              <description>[20:20] XOSC_LF_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CLK_DCDC_RDY</name>
              <description>[19:19] CLK_DCDC_RDY</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CLK_DCDC_RDY_ACK</name>
              <description>[18:18] CLK_DCDC_RDY_ACK</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>SCLK_HF_LOSS</name>
              <description>[17:17] Indicates sclk_hf is lost</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>SCLK_LF_LOSS</name>
              <description>[16:16] Indicates sclk_lf is lost</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_EN</name>
              <description>[15:15] Indicates that XOSC_HF is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>RESERVED14</name>
              <description>[14:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>XB_48M_CLK_EN</name>
              <description>[13:13] Indicates that the 48MHz clock from the  DOUBLER is enabled.

It will be enabled if 24 or 48 MHz crystal is used (enabled in doubler bypass for the 48MHz crystal).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_LP_BUF_EN</name>
              <description>[11:11] XOSC_HF_LP_BUF_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_HP_BUF_EN</name>
              <description>[10:10] XOSC_HF_HP_BUF_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[9:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>ADC_THMET</name>
              <description>[8:8] ADC_THMET</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADC_DATA_READY</name>
              <description>[7:7] indicates when adc_data is ready.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ADC_DATA</name>
              <description>[6:1] adc_data</description>
              <bitWidth>6</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PENDINGSCLKHFSWITCHING</name>
              <description>[0:0] Indicates when sclk_hf is ready to be switched</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STAT1</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Status 1
This register contains status signals from OSC_DIG</description>
          <fields>
            <field>
              <name>RAMPSTATE</name>
              <description>[31:28] AMPCOMP FSM State</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FAST_START_SETTLE</name>
                  <value>14</value>
                  <description>FAST_START_SETTLE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAST_START</name>
                  <value>13</value>
                  <description>FAST_START</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DUMMY_TO_INIT_1</name>
                  <value>12</value>
                  <description>DUMMY_TO_INIT_1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_DEC_W_MEASURE</name>
                  <value>11</value>
                  <description>IDAC_DECREMENT_WITH_MEASURE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IBIAS_INC</name>
                  <value>10</value>
                  <description>IBIAS_INCREMENT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPM_UPDATE</name>
                  <value>9</value>
                  <description>LPM_UPDATE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IBIAS_DEC_W_MEASURE</name>
                  <value>8</value>
                  <description>IBIAS_DECREMENT_WITH_MEASURE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IBIAS_CAP_UPDATE</name>
                  <value>7</value>
                  <description>IBIAS_CAP_UPDATE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDAC_INCREMENT</name>
                  <value>6</value>
                  <description>IDAC_INCREMENT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPM_UPDATE</name>
                  <value>5</value>
                  <description>HPM_UPDATE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPM_RAMP3</name>
                  <value>4</value>
                  <description>HPM_RAMP3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPM_RAMP2</name>
                  <value>3</value>
                  <description>HPM_RAMP2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPM_RAMP1</name>
                  <value>2</value>
                  <description>HPM_RAMP1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INITIALIZATION</name>
                  <value>1</value>
                  <description>INITIALIZATION</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <value>0</value>
                  <description>RESET</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HPM_UPDATE_AMP</name>
              <description>[27:22] OSC amplitude during HPM_UPDATE state.
When amplitude compensation of XOSC_HF is enabled in high performance mode, this value is the amplitude of the crystal oscillations measured by the on-chip oscillator ADC, divided by 15 mV.  For example, a value of 0x20 would indicate that the amplitude of the crystal is approximately 480 mV.  To enable amplitude compensation, AON_WUC OSCCFG must be set to a non-zero value.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>LPM_UPDATE_AMP</name>
              <description>[21:16] OSC amplitude during LPM_UPDATE state
When amplitude compensation of XOSC_HF is enabled in low power mode, this value is the amplitude of the crystal oscillations measured by the on-chip oscillator ADC, divided by 15 mV.  For example, a value of 0x20 would indicate that the amplitude of the crystal is approximately 480 mV.  To enable amplitude compensation, AON_WUC OSCCFG must be set to a non-zero value.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>FORCE_RCOSC_HF</name>
              <description>[15:15] force_rcosc_hf</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>SCLK_HF_EN</name>
              <description>[14:14] SCLK_HF_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>SCLK_MF_EN</name>
              <description>[13:13] SCLK_MF_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>ACLK_ADC_EN</name>
              <description>[12:12] ACLK_ADC_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>ACLK_TDC_EN</name>
              <description>[11:11] ACLK_TDC_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>ACLK_REF_EN</name>
              <description>[10:10] ACLK_REF_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CLK_CHP_EN</name>
              <description>[9:9] CLK_CHP_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>CLK_DCDC_EN</name>
              <description>[8:8] CLK_DCDC_EN</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SCLK_HF_GOOD</name>
              <description>[7:7] SCLK_HF_GOOD</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SCLK_MF_GOOD</name>
              <description>[6:6] SCLK_MF_GOOD</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SCLK_LF_GOOD</name>
              <description>[5:5] SCLK_LF_GOOD</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>ACLK_ADC_GOOD</name>
              <description>[4:4] ACLK_ADC_GOOD</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>ACLK_TDC_GOOD</name>
              <description>[3:3] ACLK_TDC_GOOD</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>ACLK_REF_GOOD</name>
              <description>[2:2] ACLK_REF_GOOD</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CLK_CHP_GOOD</name>
              <description>[1:1] CLK_CHP_GOOD</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_DCDC_GOOD</name>
              <description>[0:0] CLK_DCDC_GOOD</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STAT2</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Status 2
This register contains status signals from AMPCOMP FSM</description>
          <fields>
            <field>
              <name>ADC_DCBIAS</name>
              <description>[31:26] DC Bias read by RADC during SAR mode
The value is an unsigned integer. It is used for debug only.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>HPM_RAMP1_THMET</name>
              <description>[25:25] Indication of threshold is met for hpm_ramp1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>HPM_RAMP2_THMET</name>
              <description>[24:24] Indication of threshold is met for hpm_ramp2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>HPM_RAMP3_THMET</name>
              <description>[23:23] Indication of threshold is met for hpm_ramp3</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>RESERVED16</name>
              <description>[22:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RAMPSTATE</name>
              <description>[15:12] xosc_hf amplitude compensation FSM

This is identical to STAT1.RAMPSTATE. See that description for encoding.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[11:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>AMPCOMP_REQ</name>
              <description>[3:3] ampcomp_req</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_AMPGOOD</name>
              <description>[2:2] amplitude of xosc_hf is within the required threshold (set by DDI). Not used for anything just for debug/status</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_FREQGOOD</name>
              <description>[1:1] frequency of xosc_hf is good to use for the digital clocks</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_RF_FREQGOOD</name>
              <description>[0:0] frequency of xosc_hf is within +/- 20 ppm and xosc_hf is good for radio operations. Used for SW to start synthesizer.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUX_EVCTL</name>
      <baseAddress>0x400C5000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>AUX Event Controller</description>
      <registers>
        <register>
          <name>VECCFG0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Vector Configuration 0

AUX_SCE wakeup vector 0 and 1 configuration</description>
          <fields>
            <field>
              <name>RESERVED15</name>
              <description>[31:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>VEC1_POL</name>
              <description>[14:14] Vector 1 trigger event polarity.

To manually trigger vector 1 execution:
- AUX_SCE must sleep.
- Set VEC1_EV to a known static value.
- Toggle VEC1_POL twice.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FALL</name>
                  <value>1</value>
                  <description>Falling edge triggers vector 1 execution.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISE</name>
                  <value>0</value>
                  <description>Rising edge triggers vector 1 execution.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VEC1_EN</name>
              <description>[13:13] Vector 1 trigger enable.

When enabled, VEC1_EV event with VEC1_POL polarity triggers a jump to vector # 1 when AUX_SCE sleeps.

Lower vectors (0) have priority.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable vector 1 trigger.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable vector 1 trigger.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VEC1_EV</name>
              <description>[12:8] Select vector 1 trigger source event.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADC_IRQ</name>
                  <value>31</value>
                  <description>EVSTAT1.ADC_IRQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCU_EV</name>
                  <value>30</value>
                  <description>EVSTAT1.MCU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACLK_REF</name>
                  <value>29</value>
                  <description>EVSTAT1.ACLK_REF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO15</name>
                  <value>28</value>
                  <description>EVSTAT1.AUXIO15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO14</name>
                  <value>27</value>
                  <description>EVSTAT1.AUXIO14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO13</name>
                  <value>26</value>
                  <description>EVSTAT1.AUXIO13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO12</name>
                  <value>25</value>
                  <description>EVSTAT1.AUXIO12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO11</name>
                  <value>24</value>
                  <description>EVSTAT1.AUXIO11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO10</name>
                  <value>23</value>
                  <description>EVSTAT1.AUXIO10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO9</name>
                  <value>22</value>
                  <description>EVSTAT1.AUXIO9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO8</name>
                  <value>21</value>
                  <description>EVSTAT1.AUXIO8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>20</value>
                  <description>EVSTAT1.AUXIO7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>19</value>
                  <description>EVSTAT1.AUXIO6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>18</value>
                  <description>EVSTAT1.AUXIO5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>17</value>
                  <description>EVSTAT1.AUXIO4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>EVSTAT1.AUXIO3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>15</value>
                  <description>EVSTAT0.AUXIO2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>14</value>
                  <description>EVSTAT0.AUXIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>13</value>
                  <description>EVSTAT0.AUXIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG_WU</name>
                  <value>12</value>
                  <description>EVSTAT0.AON_PROG_WU</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_SW</name>
                  <value>11</value>
                  <description>EVSTAT0.AON_SW</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX1</name>
                  <value>10</value>
                  <description>EVSTAT0.OBSMUX1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX0</name>
                  <value>9</value>
                  <description>EVSTAT0.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_FIFO_ALMOST_FULL</name>
                  <value>8</value>
                  <description>EVSTAT0.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_DONE</name>
                  <value>7</value>
                  <description>EVSTAT0.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SMPH_AUTOTAKE_DONE</name>
                  <value>6</value>
                  <description>EVSTAT0.SMPH_AUTOTAKE_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER1_EV</name>
                  <value>5</value>
                  <description>EVSTAT0.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER0_EV</name>
                  <value>4</value>
                  <description>EVSTAT0.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDC_DONE</name>
                  <value>3</value>
                  <description>EVSTAT0.TDC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>2</value>
                  <description>EVSTAT0.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>1</value>
                  <description>EVSTAT0.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_CH2</name>
                  <value>0</value>
                  <description>EVSTAT0.AON_RTC_CH2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>[7:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>VEC0_POL</name>
              <description>[6:6] Vector 0 trigger event polarity.

To manually trigger vector 0 execution:
- AUX_SCE must sleep.
- Set VEC0_EV to a known static value.
- Toggle VEC0_POL twice.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FALL</name>
                  <value>1</value>
                  <description>Falling edge triggers vector 0 execution.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISE</name>
                  <value>0</value>
                  <description>Rising edge triggers vector 0 execution.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VEC0_EN</name>
              <description>[5:5] Vector 0 trigger enable.

When enabled, VEC0_EV event with VEC0_POL polarity triggers a jump to vector # 0 when AUX_SCE sleeps.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable vector 0 trigger.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable vector 0 trigger.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VEC0_EV</name>
              <description>[4:0] Select vector 0 trigger source event.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADC_IRQ</name>
                  <value>31</value>
                  <description>EVSTAT1.ADC_IRQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCU_EV</name>
                  <value>30</value>
                  <description>EVSTAT1.MCU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACLK_REF</name>
                  <value>29</value>
                  <description>EVSTAT1.ACLK_REF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO15</name>
                  <value>28</value>
                  <description>EVSTAT1.AUXIO15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO14</name>
                  <value>27</value>
                  <description>EVSTAT1.AUXIO14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO13</name>
                  <value>26</value>
                  <description>EVSTAT1.AUXIO13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO12</name>
                  <value>25</value>
                  <description>EVSTAT1.AUXIO12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO11</name>
                  <value>24</value>
                  <description>EVSTAT1.AUXIO11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO10</name>
                  <value>23</value>
                  <description>EVSTAT1.AUXIO10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO9</name>
                  <value>22</value>
                  <description>EVSTAT1.AUXIO9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO8</name>
                  <value>21</value>
                  <description>EVSTAT1.AUXIO8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>20</value>
                  <description>EVSTAT1.AUXIO7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>19</value>
                  <description>EVSTAT1.AUXIO6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>18</value>
                  <description>EVSTAT1.AUXIO5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>17</value>
                  <description>EVSTAT1.AUXIO4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>EVSTAT1.AUXIO3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>15</value>
                  <description>EVSTAT0.AUXIO2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>14</value>
                  <description>EVSTAT0.AUXIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>13</value>
                  <description>EVSTAT0.AUXIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG_WU</name>
                  <value>12</value>
                  <description>EVSTAT0.AON_PROG_WU</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_SW</name>
                  <value>11</value>
                  <description>EVSTAT0.AON_SW</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX1</name>
                  <value>10</value>
                  <description>EVSTAT0.OBSMUX1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX0</name>
                  <value>9</value>
                  <description>EVSTAT0.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_FIFO_ALMOST_FULL</name>
                  <value>8</value>
                  <description>EVSTAT0.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_DONE</name>
                  <value>7</value>
                  <description>EVSTAT0.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SMPH_AUTOTAKE_DONE</name>
                  <value>6</value>
                  <description>EVSTAT0.SMPH_AUTOTAKE_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER1_EV</name>
                  <value>5</value>
                  <description>EVSTAT0.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER0_EV</name>
                  <value>4</value>
                  <description>EVSTAT0.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDC_DONE</name>
                  <value>3</value>
                  <description>EVSTAT0.TDC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>2</value>
                  <description>EVSTAT0.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>1</value>
                  <description>EVSTAT0.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_CH2</name>
                  <value>0</value>
                  <description>EVSTAT0.AON_RTC_CH2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>VECCFG1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Vector Configuration 1

AUX_SCE event vectors 2 and 3 configuration</description>
          <fields>
            <field>
              <name>RESERVED15</name>
              <description>[31:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>VEC3_POL</name>
              <description>[14:14] Vector 3 trigger event polarity.

To manually trigger vector 3 execution:
- AUX_SCE must sleep.
- Set VEC3_EV to a known static value.
- Toggle VEC3_POL twice.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FALL</name>
                  <value>1</value>
                  <description>Falling edge triggers vector 3 execution.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISE</name>
                  <value>0</value>
                  <description>Rising edge triggers vector 3 execution.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VEC3_EN</name>
              <description>[13:13] Vector 3 trigger enable.

When enabled, VEC3_EV event with VEC3_POL polarity triggers a jump to vector # 3 when AUX_SCE sleeps.

Lower vectors (0, 1, and 2) have priority.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable vector 3 trigger.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable vector 3 trigger.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VEC3_EV</name>
              <description>[12:8] Select vector 3 trigger source event.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADC_IRQ</name>
                  <value>31</value>
                  <description>EVSTAT1.ADC_IRQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCU_EV</name>
                  <value>30</value>
                  <description>EVSTAT1.MCU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACLK_REF</name>
                  <value>29</value>
                  <description>EVSTAT1.ACLK_REF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO15</name>
                  <value>28</value>
                  <description>EVSTAT1.AUXIO15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO14</name>
                  <value>27</value>
                  <description>EVSTAT1.AUXIO14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO13</name>
                  <value>26</value>
                  <description>EVSTAT1.AUXIO13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO12</name>
                  <value>25</value>
                  <description>EVSTAT1.AUXIO12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO11</name>
                  <value>24</value>
                  <description>EVSTAT1.AUXIO11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO10</name>
                  <value>23</value>
                  <description>EVSTAT1.AUXIO10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO9</name>
                  <value>22</value>
                  <description>EVSTAT1.AUXIO9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO8</name>
                  <value>21</value>
                  <description>EVSTAT1.AUXIO8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>20</value>
                  <description>EVSTAT1.AUXIO7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>19</value>
                  <description>EVSTAT1.AUXIO6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>18</value>
                  <description>EVSTAT1.AUXIO5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>17</value>
                  <description>EVSTAT1.AUXIO4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>EVSTAT1.AUXIO3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>15</value>
                  <description>EVSTAT0.AUXIO2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>14</value>
                  <description>EVSTAT0.AUXIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>13</value>
                  <description>EVSTAT0.AUXIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG_WU</name>
                  <value>12</value>
                  <description>EVSTAT0.AON_PROG_WU</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_SW</name>
                  <value>11</value>
                  <description>EVSTAT0.AON_SW</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX1</name>
                  <value>10</value>
                  <description>EVSTAT0.OBSMUX1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX0</name>
                  <value>9</value>
                  <description>EVSTAT0.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_FIFO_ALMOST_FULL</name>
                  <value>8</value>
                  <description>EVSTAT0.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_DONE</name>
                  <value>7</value>
                  <description>EVSTAT0.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SMPH_AUTOTAKE_DONE</name>
                  <value>6</value>
                  <description>EVSTAT0.SMPH_AUTOTAKE_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER1_EV</name>
                  <value>5</value>
                  <description>EVSTAT0.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER0_EV</name>
                  <value>4</value>
                  <description>EVSTAT0.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDC_DONE</name>
                  <value>3</value>
                  <description>EVSTAT0.TDC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>2</value>
                  <description>EVSTAT0.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>1</value>
                  <description>EVSTAT0.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_CH2</name>
                  <value>0</value>
                  <description>EVSTAT0.AON_RTC_CH2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>[7:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>VEC2_POL</name>
              <description>[6:6] Vector 2 trigger event polarity.

To manually trigger vector 2 execution:
- AUX_SCE must sleep.
- Set VEC2_EV to a known static value.
- Toggle VEC2_POL twice.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FALL</name>
                  <value>1</value>
                  <description>Falling edge triggers vector 2 execution.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISE</name>
                  <value>0</value>
                  <description>Rising edge triggers vector 2 execution.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VEC2_EN</name>
              <description>[5:5] Vector 2 trigger enable.

When enabled, VEC2_EV event with VEC2_POL polarity triggers a jump to vector # 2 when AUX_SCE sleeps.

Lower vectors (0 and 1) have priority.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable vector 2 trigger.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable vector 2 trigger.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VEC2_EV</name>
              <description>[4:0] Select vector 2 trigger source event.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADC_IRQ</name>
                  <value>31</value>
                  <description>EVSTAT1.ADC_IRQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCU_EV</name>
                  <value>30</value>
                  <description>EVSTAT1.MCU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACLK_REF</name>
                  <value>29</value>
                  <description>EVSTAT1.ACLK_REF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO15</name>
                  <value>28</value>
                  <description>EVSTAT1.AUXIO15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO14</name>
                  <value>27</value>
                  <description>EVSTAT1.AUXIO14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO13</name>
                  <value>26</value>
                  <description>EVSTAT1.AUXIO13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO12</name>
                  <value>25</value>
                  <description>EVSTAT1.AUXIO12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO11</name>
                  <value>24</value>
                  <description>EVSTAT1.AUXIO11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO10</name>
                  <value>23</value>
                  <description>EVSTAT1.AUXIO10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO9</name>
                  <value>22</value>
                  <description>EVSTAT1.AUXIO9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO8</name>
                  <value>21</value>
                  <description>EVSTAT1.AUXIO8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>20</value>
                  <description>EVSTAT1.AUXIO7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>19</value>
                  <description>EVSTAT1.AUXIO6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>18</value>
                  <description>EVSTAT1.AUXIO5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>17</value>
                  <description>EVSTAT1.AUXIO4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>EVSTAT1.AUXIO3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>15</value>
                  <description>EVSTAT0.AUXIO2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>14</value>
                  <description>EVSTAT0.AUXIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>13</value>
                  <description>EVSTAT0.AUXIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG_WU</name>
                  <value>12</value>
                  <description>EVSTAT0.AON_PROG_WU</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_SW</name>
                  <value>11</value>
                  <description>EVSTAT0.AON_SW</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX1</name>
                  <value>10</value>
                  <description>EVSTAT0.OBSMUX1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX0</name>
                  <value>9</value>
                  <description>EVSTAT0.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_FIFO_ALMOST_FULL</name>
                  <value>8</value>
                  <description>EVSTAT0.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_DONE</name>
                  <value>7</value>
                  <description>EVSTAT0.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SMPH_AUTOTAKE_DONE</name>
                  <value>6</value>
                  <description>EVSTAT0.SMPH_AUTOTAKE_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER1_EV</name>
                  <value>5</value>
                  <description>EVSTAT0.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER0_EV</name>
                  <value>4</value>
                  <description>EVSTAT0.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDC_DONE</name>
                  <value>3</value>
                  <description>EVSTAT0.TDC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>2</value>
                  <description>EVSTAT0.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>1</value>
                  <description>EVSTAT0.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_CH2</name>
                  <value>0</value>
                  <description>EVSTAT0.AON_RTC_CH2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SCEWEVSEL</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Sensor Controller Engine Wait Event Selection

Configuration of this register controls bit index 7 in AUX_SCE:WUSTAT.EV_SIGNALS. This bit can be used by AUX_SCE WEV0, WEV1, BEV0 and BEV1 instructions</description>
          <fields>
            <field>
              <name>RESERVED5</name>
              <description>[31:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>WEV7_EV</name>
              <description>[4:0] Select event source to connect to AUX_SCE:WUSTAT.EV_SIGNALS bit 7.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADC_IRQ</name>
                  <value>31</value>
                  <description>EVSTAT1.ADC_IRQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCU_EV</name>
                  <value>30</value>
                  <description>EVSTAT1.MCU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACLK_REF</name>
                  <value>29</value>
                  <description>EVSTAT1.ACLK_REF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO15</name>
                  <value>28</value>
                  <description>EVSTAT1.AUXIO15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO14</name>
                  <value>27</value>
                  <description>EVSTAT1.AUXIO14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO13</name>
                  <value>26</value>
                  <description>EVSTAT1.AUXIO13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO12</name>
                  <value>25</value>
                  <description>EVSTAT1.AUXIO12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO11</name>
                  <value>24</value>
                  <description>EVSTAT1.AUXIO11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO10</name>
                  <value>23</value>
                  <description>EVSTAT1.AUXIO10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO9</name>
                  <value>22</value>
                  <description>EVSTAT1.AUXIO9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO8</name>
                  <value>21</value>
                  <description>EVSTAT1.AUXIO8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>20</value>
                  <description>EVSTAT1.AUXIO7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>19</value>
                  <description>EVSTAT1.AUXIO6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>18</value>
                  <description>EVSTAT1.AUXIO5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>17</value>
                  <description>EVSTAT1.AUXIO4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>EVSTAT1.AUXIO3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>15</value>
                  <description>EVSTAT0.AUXIO2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>14</value>
                  <description>EVSTAT0.AUXIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>13</value>
                  <description>EVSTAT0.AUXIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG_WU</name>
                  <value>12</value>
                  <description>EVSTAT0.AON_PROG_WU</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_SW</name>
                  <value>11</value>
                  <description>EVSTAT0.AON_SW</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX1</name>
                  <value>10</value>
                  <description>EVSTAT0.OBSMUX1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX0</name>
                  <value>9</value>
                  <description>EVSTAT0.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_FIFO_ALMOST_FULL</name>
                  <value>8</value>
                  <description>EVSTAT0.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_DONE</name>
                  <value>7</value>
                  <description>EVSTAT0.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SMPH_AUTOTAKE_DONE</name>
                  <value>6</value>
                  <description>EVSTAT0.SMPH_AUTOTAKE_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER1_EV</name>
                  <value>5</value>
                  <description>EVSTAT0.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER0_EV</name>
                  <value>4</value>
                  <description>EVSTAT0.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDC_DONE</name>
                  <value>3</value>
                  <description>EVSTAT0.TDC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>2</value>
                  <description>EVSTAT0.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>1</value>
                  <description>EVSTAT0.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_CH2</name>
                  <value>0</value>
                  <description>EVSTAT0.AON_RTC_CH2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EVTOAONFLAGS</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Events To AON Flags

This register contains a collection of event flags routed to AON_EVENT. 

To clear an event flag, write to EVTOAONFLAGSCLR or write 0 to event flag in this register.</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TIMER1_EV</name>
              <description>[8:8] This event flag is set when level selected by EVTOAONPOL.TIMER1_EV occurs on EVSTAT0.TIMER1_EV.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TIMER0_EV</name>
              <description>[7:7] This event flag is set when level selected by EVTOAONPOL.TIMER0_EV occurs on EVSTAT0.TIMER0_EV.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TDC_DONE</name>
              <description>[6:6] This event flag is set when level selected by EVTOAONPOL.TDC_DONE occurs on EVSTAT0.TDC_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>ADC_DONE</name>
              <description>[5:5] This event flag is set when level selected by EVTOAONPOL.ADC_DONE occurs on EVSTAT0.ADC_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>AUX_COMPB</name>
              <description>[4:4] This event flag is set when edge selected by EVTOAONPOL.AUX_COMPB occurs on EVSTAT0.AUX_COMPB.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>AUX_COMPA</name>
              <description>[3:3] This event flag is set when edge selected by EVTOAONPOL.AUX_COMPA occurs on EVSTAT0.AUX_COMPA.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SWEV2</name>
              <description>[2:2] This event flag is set when software writes a 1 to SWEVSET.SWEV2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SWEV1</name>
              <description>[1:1] This event flag is set when software writes a 1 to SWEVSET.SWEV1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SWEV0</name>
              <description>[0:0] This event flag is set when software writes a 1 to SWEVSET.SWEV0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EVTOAONPOL</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Events To AON Polarity

Event source polarity configuration for EVTOAONFLAGS.</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TIMER1_EV</name>
              <description>[8:8] Select the level of EVSTAT0.TIMER1_EV that sets EVTOAONFLAGS.TIMER1_EV.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER0_EV</name>
              <description>[7:7] Select the level of EVSTAT0.TIMER0_EV that sets EVTOAONFLAGS.TIMER0_EV.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TDC_DONE</name>
              <description>[6:6] Select level of EVSTAT0.TDC_DONE that sets EVTOAONFLAGS.TDC_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC_DONE</name>
              <description>[5:5] Select the level of  EVSTAT0.ADC_DONE that sets EVTOAONFLAGS.ADC_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUX_COMPB</name>
              <description>[4:4] Select the edge of  EVSTAT0.AUX_COMPB that sets EVTOAONFLAGS.AUX_COMPB.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Falling edge</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>Rising edge</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUX_COMPA</name>
              <description>[3:3] Select the edge of  EVSTAT0.AUX_COMPA that sets EVTOAONFLAGS.AUX_COMPA.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Falling edge</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>Rising edge</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[2:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Direct Memory Access Control</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>REQ_MODE</name>
              <description>[2:2] UDMA0 Request mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SINGLE</name>
                  <value>1</value>
                  <description>Single requests are generated on UDMA0 channel 7 when the condition configured in SEL is met.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BURST</name>
                  <value>0</value>
                  <description>Burst requests are generated on UDMA0 channel 7 when the condition configured in SEL is met.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN</name>
              <description>[1:1] uDMA ADC interface enable.

0: Disable UDMA0 interface to ADC.
1: Enable UDMA0 interface to ADC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SEL</name>
              <description>[0:0] Select FIFO watermark level required to trigger a UDMA0 transfer of ADC FIFO data.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FIFO_ALMOST_FULL</name>
                  <value>1</value>
                  <description>UDMA0 trigger event will be generated when the ADC FIFO is almost full (3/4 full).</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FIFO_NOT_EMPTY</name>
                  <value>0</value>
                  <description>UDMA0 trigger event will be generated when there are samples in the ADC FIFO.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SWEVSET</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Software Event Set

Set software event flags from AUX domain to AON and MCU domains. CPUs in MCU domain can read the event flags from EVTOAONFLAGS and clear them in EVTOAONFLAGSCLR. 

Use of these event flags is software-defined.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SWEV2</name>
              <description>[2:2] Software event flag 2.

0: No effect.
1: Set software event flag 2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SWEV1</name>
              <description>[1:1] Software event flag 1.

0: No effect.
1: Set software event flag 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SWEV0</name>
              <description>[0:0] Software event flag 0.

0: No effect.
1: Set software event flag 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EVSTAT0</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Event Status 0

Register holds events 0 thru 15 of the 32-bit event bus that is synchronous to AUX clock. The following subscribers use the asynchronous version of events in this register.
- AUX_ANAIF.
- AUX_TDC.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>AUXIO2</name>
              <description>[15:15] AUXIO2   pin level, read value corresponds to AUX_AIODIO0:GPIODIN bit 2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>AUXIO1</name>
              <description>[14:14] AUXIO1   pin level, read value corresponds to AUX_AIODIO0:GPIODIN bit 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>AUXIO0</name>
              <description>[13:13] AUXIO0   pin level, read value corresponds to AUX_AIODIO0:GPIODIN bit 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>AON_PROG_WU</name>
              <description>[12:12] AON_EVENT:AUXWUSEL.WU2_EV OR AON_EVENT:AUXWUSEL.WU1_EV OR AON_EVENT:AUXWUSEL.WU0_EV</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>AON_SW</name>
              <description>[11:11] AON_WUC:AUXCTL.SWEV</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OBSMUX1</name>
              <description>[10:10] Observation input 1 from IOC. 
This event is configured by IOC:OBSAUXOUTPUT.SEL1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>OBSMUX0</name>
              <description>[9:9] Observation input 0 from IOC. 
This event is configured by IOC:OBSAUXOUTPUT.SEL0 and can be overridden by IOC:OBSAUXOUTPUT.SEL_MISC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>ADC_FIFO_ALMOST_FULL</name>
              <description>[8:8] AUX_ANAIF:ADCFIFOSTAT.ALMOST_FULL</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADC_DONE</name>
              <description>[7:7] AUX_ANAIF ADC conversion done event.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SMPH_AUTOTAKE_DONE</name>
              <description>[6:6] See AUX_SMPH:AUTOTAKE.SMPH_ID for description.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TIMER1_EV</name>
              <description>[5:5] AUX_TIMER1_EV event, see AUX_TIMER:T1TARGET for description.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TIMER0_EV</name>
              <description>[4:4] AUX_TIMER0_EV event, see AUX_TIMER:T0TARGET for description.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TDC_DONE</name>
              <description>[3:3] AUX_TDC:STAT.DONE</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>AUX_COMPB</name>
              <description>[2:2] Comparator B output</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AUX_COMPA</name>
              <description>[1:1] Comparator A output</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>AON_RTC_CH2</name>
              <description>[0:0] AON_RTC:EVFLAGS.CH2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EVSTAT1</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Event Status 1

Current event source levels, 31:16</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>ADC_IRQ</name>
              <description>[15:15] The logical function for this event is configurable.

When DMACTL.EN = 1 : 
   Event = UDMA0 Channel 7 done event     OR     AUX_ANAIF:ADCFIFOSTAT.OVERFLOW      OR      AUX_ANAIF:ADCFIFOSTAT.UNDERFLOW

When DMACTL.EN = 0 :
   Event = (NOT AUX_ANAIF:ADCFIFOSTAT.EMPTY)      OR      AUX_ANAIF:ADCFIFOSTAT.OVERFLOW      OR      AUX_ANAIF:ADCFIFOSTAT.UNDERFLOW  

Bit 7 in UDMA0:DONEMASK must be 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>MCU_EV</name>
              <description>[14:14] Event from EVENT configured by EVENT:AUXSEL0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>ACLK_REF</name>
              <description>[13:13] TDC reference clock.
It is configured by DDI_0_OSC:CTL0.ACLK_REF_SRC_SEL and enabled by AUX_WUC:REFCLKCTL.REQ.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>AUXIO15</name>
              <description>[12:12] AUXIO15 pin level, read value corresponds to AUX_AIODIO1:GPIODIN bit 7.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>AUXIO14</name>
              <description>[11:11] AUXIO14 pin level, read value corresponds to AUX_AIODIO1:GPIODIN bit 6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>AUXIO13</name>
              <description>[10:10] AUXIO13 pin level, read value corresponds to AUX_AIODIO1:GPIODIN bit 5.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>AUXIO12</name>
              <description>[9:9] AUXIO12 pin level, read value corresponds to AUX_AIODIO1:GPIODIN bit 4.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>AUXIO11</name>
              <description>[8:8] AUXIO11 pin level, read value corresponds to AUX_AIODIO1:GPIODIN bit 3.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AUXIO10</name>
              <description>[7:7] AUXIO10 pin level, read value corresponds to AUX_AIODIO1:GPIODIN bit 2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>AUXIO9</name>
              <description>[6:6] AUXIO9   pin level, read value corresponds to AUX_AIODIO1:GPIODIN bit 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>AUXIO8</name>
              <description>[5:5] AUXIO8   pin level, read value corresponds to AUX_AIODIO1:GPIODIN bit 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>AUXIO7</name>
              <description>[4:4] AUXIO7   pin level, read value corresponds to AUX_AIODIO0:GPIODIN bit 7.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>AUXIO6</name>
              <description>[3:3] AUXIO6   pin level, read value corresponds to AUX_AIODIO0:GPIODIN bit 6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>AUXIO5</name>
              <description>[2:2] AUXIO5   pin level, read value corresponds to AUX_AIODIO0:GPIODIN bit 5.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AUXIO4</name>
              <description>[1:1] AUXIO4   pin level, read value corresponds to AUX_AIODIO0:GPIODIN bit 4.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>AUXIO3</name>
              <description>[0:0] AUXIO3   pin level, read value corresponds to AUX_AIODIO0:GPIODIN bit 3.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EVTOMCUPOL</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Event To MCU Polarity

Event source polarity configuration for EVTOMCUFLAGS.</description>
          <fields>
            <field>
              <name>RESERVED11</name>
              <description>[31:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>ADC_IRQ</name>
              <description>[10:10] Select the event source level that sets EVTOMCUFLAGS.ADC_IRQ.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OBSMUX0</name>
              <description>[9:9] Select the event source level that sets EVTOMCUFLAGS.OBSMUX0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC_FIFO_ALMOST_FULL</name>
              <description>[8:8] Select the event source level that sets EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADC_DONE</name>
              <description>[7:7] Select the event source level that sets EVTOMCUFLAGS.ADC_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPH_AUTOTAKE_DONE</name>
              <description>[6:6] Select the event source level that sets EVTOMCUFLAGS.SMPH_AUTOTAKE_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER1_EV</name>
              <description>[5:5] Select the event source level that sets EVTOMCUFLAGS.TIMER1_EV.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER0_EV</name>
              <description>[4:4] Select the event source level that sets EVTOMCUFLAGS.TIMER0_EV.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TDC_DONE</name>
              <description>[3:3] Select the event source level that sets EVTOMCUFLAGS.TDC_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUX_COMPB</name>
              <description>[2:2] Select the event source level that sets EVTOMCUFLAGS.AUX_COMPB.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUX_COMPA</name>
              <description>[1:1] Select the event source level that sets EVTOMCUFLAGS.AUX_COMPA.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AON_WU_EV</name>
              <description>[0:0] Select the event source level that sets EVTOMCUFLAGS.AON_WU_EV.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>Low level</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>High level</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EVTOMCUFLAGS</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Events to MCU Flags

This register contains a collection of event flags routed to MCU domain. 

To clear an event flag, write to EVTOMCUFLAGSCLR or write 0 to event flag in this register. Follow procedure described in AUX_SYSIF:WUCLR to clear AUX_WU_EV event flag.</description>
          <fields>
            <field>
              <name>RESERVED11</name>
              <description>[31:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>ADC_IRQ</name>
              <description>[10:10] This event flag is set when level selected by EVTOMCUPOL.ADC_IRQ occurs on EVSTAT0.ADC_IRQ.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>OBSMUX0</name>
              <description>[9:9] This event flag is set when level selected by EVTOMCUPOL.MCU_OBSMUX0 occurs on EVSTAT0.MCU_OBSMUX0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>ADC_FIFO_ALMOST_FULL</name>
              <description>[8:8] This event flag is set when level selected by EVTOMCUPOL.ADC_FIFO_ALMOST_FULL occurs on EVSTAT0.ADC_FIFO_ALMOST_FULL.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADC_DONE</name>
              <description>[7:7] This event flag is set when level selected by EVTOMCUPOL.ADC_DONE occurs on EVSTAT0.ADC_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SMPH_AUTOTAKE_DONE</name>
              <description>[6:6] This event flag is set when level selected by EVTOMCUPOL.SMPH_AUTOTAKE_DONE occurs on EVSTAT0.SMPH_AUTOTAKE_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TIMER1_EV</name>
              <description>[5:5] This event flag is set when level selected by EVTOMCUPOL.TIMER1_EV occurs on EVSTAT0.TIMER1_EV.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TIMER0_EV</name>
              <description>[4:4] This event flag is set when level selected by EVTOMCUPOL.TIMER0_EV occurs on EVSTAT0.TIMER0_EV.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TDC_DONE</name>
              <description>[3:3] This event flag is set when level selected by EVTOMCUPOL.TDC_DONE occurs on EVSTAT0.TDC_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>AUX_COMPB</name>
              <description>[2:2] This event flag is set when edge selected by EVTOMCUPOL.AUX_COMPB occurs on EVSTAT0.AUX_COMPB.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AUX_COMPA</name>
              <description>[1:1] This event flag is set when edge selected by EVTOMCUPOL.AUX_COMPA occurs on EVSTAT0.AUX_COMPA.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>AON_WU_EV</name>
              <description>[0:0] This event flag is set when level selected by EVTOMCUPOL.AON_WU_EV occurs on the reduction-OR of the AUX_EVCTL:EVSTAT0.RTC_CH2_EV, AUX_EVCTL:EVSTAT0.AON_SW, and AUX_EVCTL:EVSTAT0.AON_PROG_WU events.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>COMBEVTOMCUMASK</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Combined Event To MCU Mask

Select event flags in EVTOMCUFLAGS that contribute to the AUX_COMB event to EVENT and system CPU.

The AUX_COMB event is high as long as one or more of the included event flags are set.</description>
          <fields>
            <field>
              <name>RESERVED11</name>
              <description>[31:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>ADC_IRQ</name>
              <description>[10:10] EVTOMCUFLAGS.ADC_IRQ contribution to the AUX_COMB event.

0: Exclude.
1: Include.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>OBSMUX0</name>
              <description>[9:9] EVTOMCUFLAGS.MCU_OBSMUX0 contribution to the AUX_COMB event.

0: Exclude.
1: Include.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>ADC_FIFO_ALMOST_FULL</name>
              <description>[8:8] EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL contribution to the AUX_COMB event.

0: Exclude.
1: Include.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADC_DONE</name>
              <description>[7:7] EVTOMCUFLAGS.ADC_DONE contribution to the AUX_COMB event.

0: Exclude.
1: Include.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SMPH_AUTOTAKE_DONE</name>
              <description>[6:6] EVTOMCUFLAGS.SMPH_AUTOTAKE_DONE contribution to the AUX_COMB event.

0: Exclude.
1: Include.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TIMER1_EV</name>
              <description>[5:5] EVTOMCUFLAGS.TIMER1_EV contribution to the AUX_COMB event.

0: Exclude.
1: Include.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TIMER0_EV</name>
              <description>[4:4] EVTOMCUFLAGS.TIMER0_EV contribution to the AUX_COMB event.

0: Exclude.
1: Include.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TDC_DONE</name>
              <description>[3:3] EVTOMCUFLAGS.TDC_DONE contribution to the AUX_COMB event.

0: Exclude.
1: Include.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>AUX_COMPB</name>
              <description>[2:2] EVTOMCUFLAGS.AUX_COMPB contribution to the AUX_COMB event.

0: Exclude
1: Include.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AUX_COMPA</name>
              <description>[1:1] EVTOMCUFLAGS.AUX_COMPA contribution to the AUX_COMB event.

0: Exclude.
1: Include.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>AON_WU_EV</name>
              <description>[0:0] EVTOMCUFLAGS.AON_WU_EV contribution to the AUX_COMB event.

0: Exclude.
1: Include.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>VECFLAGS</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Vector Flags

If a vector flag becomes 1 and AUX_SCE sleeps, AUX_SCE will wake up and execute the corresponding vector. The vector with the lowest index will execute first if multiple vectors flags are set. AUX_SCE must return to sleep to execute the next vector.

During execution of a vector, AUX_SCE must clear the vector flag that triggered execution. Write 1 to bit index n in VECFLAGSCLR to clear vector flag n.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>VEC3</name>
              <description>[3:3] Vector flag 3.

The vector flag is set if the edge selected VECCFG1.VEC3_POL occurs on the event selected in VECCFG1.VEC3_EV.

The flag is cleared by writing a 0 to this bit, or (preferably) a 1 to VECFLAGSCLR.VEC3.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>VEC2</name>
              <description>[2:2] Vector flag 2.

The vector flag is set if the edge selected VECCFG1.VEC2_POL occurs on the event selected in VECCFG1.VEC2_EV.

The flag is cleared by writing a 0 to this bit, or (preferably) a 1 to VECFLAGSCLR.VEC2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>VEC1</name>
              <description>[1:1] Vector flag 1.

The vector flag is set if the edge selected VECCFG0.VEC1_POL occurs on the event selected in VECCFG0.VEC1_EV.

The flag is cleared by writing a 0 to this bit, or (preferably) a 1 to VECFLAGSCLR.VEC1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>VEC0</name>
              <description>[0:0] Vector flag 0.

The vector flag is set if the edge selected VECCFG0.VEC0_POL occurs on the event selected in VECCFG0.VEC0_EV.

The flag is cleared by writing a 0 to this bit, or (preferably) a 1 to VECFLAGSCLR.VEC0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EVTOMCUFLAGSCLR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Events To MCU Flags Clear

Clear event flags in EVTOMCUFLAGS. 

In order to clear a level sensitive event flag, the event must be deasserted.</description>
          <fields>
            <field>
              <name>RESERVED11</name>
              <description>[31:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>ADC_IRQ</name>
              <description>[10:10] Write 1 to clear EVTOMCUFLAGS.ADC_IRQ.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>OBSMUX0</name>
              <description>[9:9] Write 1 to clear EVTOMCUFLAGS.MCU_OBSMUX0.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>ADC_FIFO_ALMOST_FULL</name>
              <description>[8:8] Write 1 to clear EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADC_DONE</name>
              <description>[7:7] Write 1 to clear EVTOMCUFLAGS.ADC_DONE.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SMPH_AUTOTAKE_DONE</name>
              <description>[6:6] Write 1 to clear EVTOMCUFLAGS.SMPH_AUTOTAKE_DONE.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TIMER1_EV</name>
              <description>[5:5] Write 1 to clear EVTOMCUFLAGS.TIMER1_EV.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TIMER0_EV</name>
              <description>[4:4] Write 1 to clear EVTOMCUFLAGS.TIMER0_EV.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TDC_DONE</name>
              <description>[3:3] Write 1 to clear EVTOMCUFLAGS.TDC_DONE.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>AUX_COMPB</name>
              <description>[2:2] Write 1 to clear EVTOMCUFLAGS.AUX_COMPB.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AUX_COMPA</name>
              <description>[1:1] Write 1 to clear EVTOMCUFLAGS.AUX_COMPA.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>AON_WU_EV</name>
              <description>[0:0] Write 1 to clear EVTOMCUFLAGS.AON_WU_EV.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EVTOAONFLAGSCLR</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Events To AON Clear

Clear event flags in EVTOAONFLAGS. 

In order to clear a level sensitive event flag, the event must be deasserted.</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TIMER1_EV</name>
              <description>[8:8] Write 1 to clear EVTOAONFLAGS.TIMER1_EV.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TIMER0_EV</name>
              <description>[7:7] Write 1 to clear EVTOAONFLAGS.TIMER0_EV.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TDC_DONE</name>
              <description>[6:6] Write 1 to clear EVTOAONFLAGS.TDC_DONE.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>ADC_DONE</name>
              <description>[5:5] Write 1 to clear EVTOAONFLAGS.ADC_DONE.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>AUX_COMPB</name>
              <description>[4:4] Write 1 to clear EVTOAONFLAGS.AUX_COMPB.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>AUX_COMPA</name>
              <description>[3:3] Write 1 to clear EVTOAONFLAGS.AUX_COMPA.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SWEV2</name>
              <description>[2:2] Write 1 to clear EVTOAONFLAGS.SWEV2.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SWEV1</name>
              <description>[1:1] Write 1 to clear EVTOAONFLAGS.SWEV1.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SWEV0</name>
              <description>[0:0] Write 1 to clear EVTOAONFLAGS.SWEV0.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>VECFLAGSCLR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Vector Flags Clear

Strobes for clearing flags in VECFLAGS.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>VEC3</name>
              <description>[3:3] Clear vector flag 3.

0: No effect.
1: Clear VECFLAGS.VEC3.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>VEC2</name>
              <description>[2:2] Clear vector flag 2.

0: No effect.
1: Clear VECFLAGS.VEC2.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>VEC1</name>
              <description>[1:1] Clear vector flag 1.

0: No effect.
1: Clear VECFLAGS.VEC1.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>VEC0</name>
              <description>[0:0] Clear vector flag 0.

0: No effect.
1: Clear VECFLAGS.VEC0.

Read value is 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUX_SCE</name>
      <baseAddress>0x400E1000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>AUX Sensor Control Engine Control Module</description>
      <registers>
        <register>
          <name>CTL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FORCE_EV_LOW</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>FORCE_EV_HIGH</name>
              <description>[23:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RESET_VECTOR</name>
              <description>[11:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>[7:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>DBG_FREEZE_EN</name>
              <description>[6:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>FORCE_WU_LOW</name>
              <description>[5:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>FORCE_WU_HIGH</name>
              <description>[4:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESTART</name>
              <description>[3:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SINGLE_STEP</name>
              <description>[2:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SUSPEND</name>
              <description>[1:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FETCHSTAT</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>OPCODE</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PC</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CPUSTAT</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>BUS_ERROR</name>
              <description>[11:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>SLEEP</name>
              <description>[10:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>WEV</name>
              <description>[9:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>SELF_STOP</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[7:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>V_FLAG</name>
              <description>[3:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>C_FLAG</name>
              <description>[2:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>N_FLAG</name>
              <description>[1:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>Z_FLAG</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>WUSTAT</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED18</name>
              <description>[31:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>14</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EXC_VECTOR</name>
              <description>[17:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[15:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>WU_SIGNAL</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EV_SIGNALS</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>REG1_0</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>REG1</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>REG0</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>REG3_2</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>REG3</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>REG2</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>REG5_4</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>REG5</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>REG4</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>REG7_6</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>REG7</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>REG6</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>LOOPADDR</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>STOP</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>START</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>LOOPCNT</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ITER_LEFT</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUX_SMPH</name>
      <baseAddress>0x400C8000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>AUX Semaphore Controller</description>
      <registers>
        <register>
          <name>SMPH0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Semaphore 0</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Request or release of semaphore.

Request by read:

0: Semaphore not available.
1: Semaphore granted.

Release by write:

0: Do not use.
1: Release semaphore.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Semaphore 1</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Request or release of semaphore.

Request by read:

0: Semaphore not available.
1: Semaphore granted.

Release by write:

0: Do not use.
1: Release semaphore.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH2</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Semaphore 2</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Request or release of semaphore.

Request by read:

0: Semaphore not available.
1: Semaphore granted.

Release by write:

0: Do not use.
1: Release semaphore.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH3</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Semaphore 3</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Request or release of semaphore.

Request by read:

0: Semaphore not available.
1: Semaphore granted.

Release by write:

0: Do not use.
1: Release semaphore.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH4</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Semaphore 4</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Request or release of semaphore.

Request by read:

0: Semaphore not available.
1: Semaphore granted.

Release by write:

0: Do not use.
1: Release semaphore.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH5</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Semaphore 5</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Request or release of semaphore.

Request by read:

0: Semaphore not available.
1: Semaphore granted.

Release by write:

0: Do not use.
1: Release semaphore.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH6</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Semaphore 6</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Request or release of semaphore.

Request by read:

0: Semaphore not available.
1: Semaphore granted.

Release by write:

0: Do not use.
1: Release semaphore.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH7</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Semaphore 7</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Request or release of semaphore.

Request by read:

0: Semaphore not available.
1: Semaphore granted.

Release by write:

0: Do not use.
1: Release semaphore.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>AUTOTAKE</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Auto Take

Sticky Request for Single Semaphore.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SMPH_ID</name>
              <description>[2:0] Write the semaphore ID,0x0-0x7, to SMPH_ID to request this semaphore until it is granted. 

When semaphore SMPH_ID is granted, event  AUX_EVCTL:EVSTAT0.AUX_SMPH_AUTOTAKE_DONE becomes 1. 

The event becomes 0 when software releases the semaphore or writes a new value to SMPH_ID.

To avoid corrupted semaphores: 
- Usage of this functionality must be restricted to one CPU core. 
- Software must wait until AUX_EVCTL:EVSTAT0.AUX_SMPH_AUTOTAKE_DONE is 1 before it writes a new value to SMPH_ID.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUX_TDCIF</name>
      <baseAddress>0x400C4000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>AUX Time To Digital Converter</description>
      <registers>
        <register>
          <name>CTL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Control</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CMD</name>
              <description>[1:0] TDC commands.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ABORT</name>
                  <value>3</value>
                  <description>Force TDC state machine back to IDLE state.

Never write this command while AUX_TDC:STAT.STATE equals CLR_CNT or WAIT_CLR_CNT_DONE.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RUN</name>
                  <value>2</value>
                  <description>Asynchronous counter start.

The counter starts to count when the start event is high. To achieve precise edge-to-edge measurements you must ensure that the start event is low for at least 420 ns after you write this command.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RUN_SYNC_START</name>
                  <value>1</value>
                  <description>Synchronous counter start.

The counter looks for the opposite edge of the selected start event before it starts to count when the selected edge occurs. This guarantees an edge-triggered start and is recommended for frequency measurements.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR_RESULT</name>
                  <value>0</value>
                  <description>Clear STAT.SAT, STAT.DONE, and RESULT.VALUE. 

This is not needed as prerequisite for a measurement. Reliable clear is only guaranteed from IDLE state.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STAT</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Status</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SAT</name>
              <description>[7:7] TDC measurement saturation flag.

0: Conversion has not saturated.
1: Conversion stopped due to saturation.

This field is cleared when a new measurement is started or when CLR_RESULT is written to CTL.CMD.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>DONE</name>
              <description>[6:6] TDC measurement complete flag.

0: TDC measurement has not yet completed.
1: TDC measurement has completed.

This field clears when a new TDC measurement starts or when you write CLR_RESULT to CTL.CMD.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>STATE</name>
              <description>[5:0] TDC state machine status.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FORCE_STOP</name>
                  <value>46</value>
                  <description>Current state is TDC_FORCESTOP.
You wrote ABORT to CTL.CMD to abort the TDC measurement.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>START_FALL</name>
                  <value>30</value>
                  <description>Current state is TDC_WAIT_STARTFALL. 
The fast-counter circuit waits for a falling edge on the start event.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_CLR_CNT_DONE</name>
                  <value>22</value>
                  <description>Current state is TDC_STATE_WAIT_CLRCNT_DONE. 
The state machine waits for fast-counter circuit to finish reset.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POR</name>
                  <value>15</value>
                  <description>Current state is TDC_STATE_POR. 
This is the reset state.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GET_RESULT</name>
                  <value>14</value>
                  <description>Current state is TDC_STATE_GETRESULTS.
The state machine copies the counter value from the fast-counter circuit.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_STOP_CNTDWN</name>
                  <value>12</value>
                  <description>Current state is TDC_STATE_WAIT_STOPCNTDOWN.
The fast-counter circuit looks for the stop condition. It will ignore a number of stop events configured in TRIGCNTLOAD.CNT.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_STOP</name>
                  <value>8</value>
                  <description>Current state is TDC_STATE_WAIT_STOP.
The state machine waits for the fast-counter circuit to stop.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR_CNT</name>
                  <value>7</value>
                  <description>Current state is TDC_STATE_CLRCNT. The fast-counter circuit is reset.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IDLE</name>
                  <value>6</value>
                  <description>Current state is TDC_STATE_IDLE. 
This is the default state after reset and abortion. State will change when you write CTL.CMD to either RUN_SYNC_START or RUN.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_START_STOP_CNT_EN</name>
                  <value>4</value>
                  <description>Current state is TDC_STATE_WAIT_STARTSTOPCNTEN.
The fast-counter circuit looks for the start condition. The state machine waits for the fast-counter to increment.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_START</name>
                  <value>0</value>
                  <description>Current state is TDC_STATE_WAIT_START. 
The fast-counter circuit looks for the start condition. The state machine waits for the fast-counter to increment.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6</resetValue>
        </register>
        <register>
          <name>RESULT</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Result

Result of last TDC conversion</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>VALUE</name>
              <description>[24:0] TDC conversion result.

The result of the TDC conversion is given in number of clock edges of the clock source selected in DDI_0_OSC:CTL0.ACLK_TDC_SRC_SEL. Both rising and falling edges are counted.

If TDC counter saturates, VALUE is slightly higher than SATCFG.LIMIT, as it takes a non-zero time to stop the measurement. Hence, the maximum value of this field becomes slightly higher than 2^24 if you configure SATCFG.LIMIT to R24.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x2</resetValue>
        </register>
        <register>
          <name>SATCFG</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Saturation Configuration</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>LIMIT</name>
              <description>[3:0] Saturation limit.

The flag STAT.SAT is set when the TDC counter saturates.

Values not enumerated are not supported</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>R24</name>
                  <value>15</value>
                  <description>Result bit 24: TDC conversion saturates and stops when RESULT.VALUE[24] is set.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>R23</name>
                  <value>14</value>
                  <description>Result bit 23: TDC conversion saturates and stops when RESULT.VALUE[23] is set.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>R22</name>
                  <value>13</value>
                  <description>Result bit 22: TDC conversion saturates and stops when RESULT.VALUE[22] is set.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>R21</name>
                  <value>12</value>
                  <description>Result bit 21: TDC conversion saturates and stops when RESULT.VALUE[21] is set.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>R20</name>
                  <value>11</value>
                  <description>Result bit 20: TDC conversion saturates and stops when RESULT.VALUE[20] is set.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>R19</name>
                  <value>10</value>
                  <description>Result bit 19: TDC conversion saturates and stops when RESULT.VALUE[19] is set.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>R18</name>
                  <value>9</value>
                  <description>Result bit 18: TDC conversion saturates and stops when RESULT.VALUE[18] is set.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>R17</name>
                  <value>8</value>
                  <description>Result bit 17: TDC conversion saturates and stops when RESULT.VALUE[17] is set.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>R16</name>
                  <value>7</value>
                  <description>Result bit 16: TDC conversion saturates and stops when RESULT.VALUE[16] is set.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>R15</name>
                  <value>6</value>
                  <description>Result bit 15: TDC conversion saturates and stops when RESULT.VALUE[15] is set.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>R14</name>
                  <value>5</value>
                  <description>Result bit 14: TDC conversion saturates and stops when RESULT.VALUE[14] is set.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>R13</name>
                  <value>4</value>
                  <description>Result bit 13: TDC conversion saturates and stops when RESULT.VALUE[13] is set.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>R12</name>
                  <value>3</value>
                  <description>Result bit 12: TDC conversion saturates and stops when RESULT.VALUE[12] is set.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0xF</resetValue>
        </register>
        <register>
          <name>TRIGSRC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Trigger Source

Select source and polarity for TDC start and stop events. See the Technical Reference Manual for event timing requirements.</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>STOP_POL</name>
              <description>[13:13] Polarity of stop source.

Change only while STAT.STATE is IDLE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>TDC conversion stops when low level is detected.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>TDC conversion stops when high level is detected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP_SRC</name>
              <description>[12:8] Select stop source from the asynchronous AUX event bus.

Change only while STAT.STATE is IDLE.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TDC_PRE</name>
                  <value>31</value>
                  <description>Select TDC Prescaler event which is generated by configuration of PRECTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCU_EV</name>
                  <value>30</value>
                  <description>AUX_EVCTL:EVSTAT1.MCU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACLK_REF</name>
                  <value>29</value>
                  <description>AUX_EVCTL:EVSTAT1.ACLK_REF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO15</name>
                  <value>28</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO14</name>
                  <value>27</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO13</name>
                  <value>26</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO12</name>
                  <value>25</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO11</name>
                  <value>24</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO10</name>
                  <value>23</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO9</name>
                  <value>22</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO8</name>
                  <value>21</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>20</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>19</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>18</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>17</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>15</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>14</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>13</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG_WU</name>
                  <value>12</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_PROG_WU</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_SW</name>
                  <value>11</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_SW</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX1</name>
                  <value>10</value>
                  <description>AUX_EVCTL:EVSTAT0.OBSMUX1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX0</name>
                  <value>9</value>
                  <description>AUX_EVCTL:EVSTAT0.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_FIFO_ALMOST_FULL</name>
                  <value>8</value>
                  <description>AUX_EVCTL:EVSTAT0.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_DONE</name>
                  <value>7</value>
                  <description>AUX_EVCTL:EVSTAT0.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SMPH_AUTOTAKE_DONE</name>
                  <value>6</value>
                  <description>AUX_EVCTL:EVSTAT0.SMPH_AUTOTAKE_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER1_EV</name>
                  <value>5</value>
                  <description>AUX_EVCTL:EVSTAT0.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER0_EV</name>
                  <value>4</value>
                  <description>AUX_EVCTL:EVSTAT0.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ISRC_RESET</name>
                  <value>3</value>
                  <description>AUX_ANAIF:ISRCCTL.RESET_N</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>2</value>
                  <description>AUX_EVCTL:EVSTAT0.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>1</value>
                  <description>AUX_EVCTL:EVSTAT0.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_CH2</name>
                  <value>0</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_RTC_CH2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>START_POL</name>
              <description>[5:5] Polarity of start source.

Change only while STAT.STATE is IDLE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>1</value>
                  <description>TDC conversion starts when low level is detected.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>0</value>
                  <description>TDC conversion starts when high level is detected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>START_SRC</name>
              <description>[4:0] Select start source from the asynchronous AUX event bus.

Change only while STAT.STATE is IDLE.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TDC_PRE</name>
                  <value>31</value>
                  <description>Select TDC Prescaler event which is generated by configuration of PRECTL.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCU_EV</name>
                  <value>30</value>
                  <description>AUX_EVCTL:EVSTAT1.MCU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACLK_REF</name>
                  <value>29</value>
                  <description>AUX_EVCTL:EVSTAT1.ACLK_REF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO15</name>
                  <value>28</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO14</name>
                  <value>27</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO13</name>
                  <value>26</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO12</name>
                  <value>25</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO11</name>
                  <value>24</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO10</name>
                  <value>23</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO9</name>
                  <value>22</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO8</name>
                  <value>21</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>20</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>19</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>18</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>17</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>15</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>14</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>13</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG_WU</name>
                  <value>12</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_PROG_WU</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_SW</name>
                  <value>11</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_SW</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX1</name>
                  <value>10</value>
                  <description>AUX_EVCTL:EVSTAT0.OBSMUX1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX0</name>
                  <value>9</value>
                  <description>AUX_EVCTL:EVSTAT0.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_FIFO_ALMOST_FULL</name>
                  <value>8</value>
                  <description>AUX_EVCTL:EVSTAT0.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_DONE</name>
                  <value>7</value>
                  <description>AUX_EVCTL:EVSTAT0.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SMPH_AUTOTAKE_DONE</name>
                  <value>6</value>
                  <description>AUX_EVCTL:EVSTAT0.SMPH_AUTOTAKE_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER1_EV</name>
                  <value>5</value>
                  <description>AUX_EVCTL:EVSTAT0.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER0_EV</name>
                  <value>4</value>
                  <description>AUX_EVCTL:EVSTAT0.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ISRC_RESET</name>
                  <value>3</value>
                  <description>AUX_ANAIF:ISRCCTL.RESET_N</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>2</value>
                  <description>AUX_EVCTL:EVSTAT0.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>1</value>
                  <description>AUX_EVCTL:EVSTAT0.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_CH2</name>
                  <value>0</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_RTC_CH2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TRIGCNT</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Trigger Counter

Stop-counter control and status.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CNT</name>
              <description>[15:0] Number of stop events to ignore when AUX_TDC:TRIGCNTCFG.EN is 1.

Read CNT to get the remaining number of stop events to ignore during a TDC measurement.  

Write CNT to update the remaining number of stop events to ignore during a TDC measurement. The TDC measurement ignores updates of CNT if there are no more stop events left to ignore.

When AUX_TDC:TRIGCNTCFG.EN is 1, TRIGCNTLOAD.CNT is loaded into CNT at the start of the measurement.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TRIGCNTLOAD</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Trigger Counter Load

Stop-counter load.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CNT</name>
              <description>[15:0] Number of stop events to ignore when AUX_TDC:TRIGCNTCFG.EN is 1.

To measure frequency of an event source: 
- Set start event equal to stop event.
- Set CNT to number of periods to measure. Both 0 and 1 values measures a single event source period.

To measure pulse width of an event source:
- Set start event source equal to stop event source.
- Select different polarity for start and stop event.
- Set CNT to 0.

To measure time from the start event to the Nth stop event when N > 1:
- Select different start and stop event source.
- Set CNT to (N-1). 

See the Technical Reference Manual for event timing requirements. 

When AUX_TDC:TRIGCNTCFG.EN is 1, CNT is loaded into TRIGCNT.CNT at the start of the measurement.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TRIGCNTCFG</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Trigger Counter Configuration

Stop-counter configuration.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] Enable stop-counter.

0: Disable stop-counter.
1: Enable stop-counter.

Change only while STAT.STATE is IDLE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PRECTL</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Prescaler Control

The prescaler can be used to count events that are faster than the AUX clock frequency. 
It can be used to:
- count pulses on a specified event from the asynchronous event bus.
- prescale a specified event from the asynchronous event bus. 

To use the prescaler output as an event source in TDC measurements you must set both TRIGSRC.START_SRC and TRIGSRC.STOP_SRC to AUX_TDC_PRE.

It is recommended to use the prescaler when the signal frequency to measure exceeds 1/10th of the AUX clock frequency.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESET_N</name>
              <description>[7:7] Prescaler reset.

0: Reset prescaler.
1: Release reset of prescaler.

AUX_TDC_PRE event becomes 0 when you reset the prescaler.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RATIO</name>
              <description>[6:6] Prescaler ratio. 

This controls how often the AUX_TDC_PRE event is generated by the prescaler.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIV64</name>
                  <value>1</value>
                  <description>Prescaler divides input by 64. 

AUX_TDC_PRE event has a rising edge for every 64 rising edges of the input. AUX_TDC_PRE event toggles on every 32nd rising edge of the input.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV16</name>
                  <value>0</value>
                  <description>Prescaler divides input by 16. 

AUX_TDC_PRE event has a rising edge for every 16 rising edges of the input. AUX_TDC_PRE event toggles on every 8th rising edge of the input.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[5:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>SRC</name>
              <description>[4:0] Prescaler event source. 

Select an event from the asynchronous AUX event bus to connect to the prescaler input. 

Configure only while RESET_N is 0.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADC_IRQ</name>
                  <value>31</value>
                  <description>AUX_EVCTL:EVSTAT1.ADC_IRQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCU_EV</name>
                  <value>30</value>
                  <description>AUX_EVCTL:EVSTAT1.MCU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACLK_REF</name>
                  <value>29</value>
                  <description>AUX_EVCTL:EVSTAT1.ACLK_REF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO15</name>
                  <value>28</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO14</name>
                  <value>27</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO13</name>
                  <value>26</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO12</name>
                  <value>25</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO11</name>
                  <value>24</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO10</name>
                  <value>23</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO9</name>
                  <value>22</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO8</name>
                  <value>21</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>20</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>19</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>18</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>17</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>15</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>14</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>13</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG_WU</name>
                  <value>12</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_PROG_WU</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_SW</name>
                  <value>11</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_SW</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX1</name>
                  <value>10</value>
                  <description>AUX_EVCTL:EVSTAT0.OBSMUX1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX0</name>
                  <value>9</value>
                  <description>AUX_EVCTL:EVSTAT0.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_FIFO_ALMOST_FULL</name>
                  <value>8</value>
                  <description>AUX_EVCTL:EVSTAT0.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_DONE</name>
                  <value>7</value>
                  <description>AUX_EVCTL:EVSTAT0.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SMPH_AUTOTAKE_DONE</name>
                  <value>6</value>
                  <description>AUX_EVCTL:EVSTAT0.SMPH_AUTOTAKE_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER1_EV</name>
                  <value>5</value>
                  <description>AUX_EVCTL:EVSTAT0.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER0_EV</name>
                  <value>4</value>
                  <description>AUX_EVCTL:EVSTAT0.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ISRC_RESET</name>
                  <value>3</value>
                  <description>AUX_ANAIF:ISRCCTL.RESET_N</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>2</value>
                  <description>AUX_EVCTL:EVSTAT0.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>1</value>
                  <description>AUX_EVCTL:EVSTAT0.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_CH2</name>
                  <value>0</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_RTC_CH2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1F</resetValue>
        </register>
        <register>
          <name>PRECNT</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Prescaler Counter</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CNT</name>
              <description>[15:0] Prescaler counter value.

Write a value to CNT to capture the value of the 16-bit prescaler counter into CNT. Read CNT to get the captured value. 

The read value gets 1 LSB uncertainty if the event source level rises when you release the reset.

You must capture the prescaler counter value when the event source level is stable, either high or low:
- Disable AUX I/O input buffer to clamp AUXIO event low.
- Disable COMPA to clamp AUX_COMPA event low. 
The read value can in general get 1 LSB uncertainty when you gate the event source asynchronously.

Please note the following:
- The prescaler counter is reset to 2 by PRECTL.RESET_N.
- The captured value is 2 when the number of rising edges on prescaler input is less than 3. Otherwise, captured value equals number of event pulses - 1.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUX_TIMER</name>
      <baseAddress>0x400C7000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>AUX Timer</description>
      <registers>
        <register>
          <name>T0CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Timer 0 Configuration</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>TICK_SRC_POL</name>
              <description>[13:13] Tick source polarity for Timer 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FALL</name>
                  <value>1</value>
                  <description>Count on falling edges of TICK_SRC.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISE</name>
                  <value>0</value>
                  <description>Count on rising edges of TICK_SRC.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TICK_SRC</name>
              <description>[12:8] Select Timer 0 tick source from the synchronous event bus.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADC_IRQ</name>
                  <value>31</value>
                  <description>AUX_EVCTL:EVSTAT1.ADC_IRQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCU_EVENT</name>
                  <value>30</value>
                  <description>AUX_EVCTL:EVSTAT1.MCU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACLK_REF</name>
                  <value>29</value>
                  <description>AUX_EVCTL:EVSTAT1.ACLK_REF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO15</name>
                  <value>28</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO14</name>
                  <value>27</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO13</name>
                  <value>26</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO12</name>
                  <value>25</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO11</name>
                  <value>24</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO10</name>
                  <value>23</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO9</name>
                  <value>22</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO8</name>
                  <value>21</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>20</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>19</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>18</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>17</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>15</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>14</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>13</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG_WU</name>
                  <value>12</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_PROG_WU</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_SW</name>
                  <value>11</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_SW</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX1</name>
                  <value>10</value>
                  <description>AUX_EVCTL:EVSTAT0.OBSMUX1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX0</name>
                  <value>9</value>
                  <description>AUX_EVCTL:EVSTAT0.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_4KHZ</name>
                  <value>8</value>
                  <description>AON_RTC:SUBSEC.VALUE bit 19. AON_RTC:CTL.RTC_4KHZ_EN enables this event.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_DONE</name>
                  <value>7</value>
                  <description>AUX_EVCTL:EVSTAT0.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SMPH_AUTOTAKE_DONE</name>
                  <value>6</value>
                  <description>AUX_EVCTL:EVSTAT0.SMPH_AUTOTAKE_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER1_EV</name>
                  <value>5</value>
                  <description>AUX_EVCTL:EVSTAT0.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDC_DONE</name>
                  <value>3</value>
                  <description>AUX_EVCTL:EVSTAT0.TDC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>2</value>
                  <description>AUX_EVCTL:EVSTAT0.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>1</value>
                  <description>AUX_EVCTL:EVSTAT0.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_EV</name>
                  <value>0</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_RTC_CH2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRE</name>
              <description>[7:4] Prescaler division ratio is 2^PRE:

0x0: Divide by 1.
0x1: Divide by 2.
0x2: Divide by 4.
... 
0xF: Divide by 32,768.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[3:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MODE</name>
              <description>[1:1] Timer 0 mode.

Configure source for Timer 0 prescaler.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TICK</name>
                  <value>1</value>
                  <description>Use event set by TICK_SRC as source for prescaler.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <value>0</value>
                  <description>Use AUX clock as source for prescaler.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RELOAD</name>
              <description>[0:0] Timer 0 reload mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CONT</name>
                  <value>1</value>
                  <description>Continuous mode.

Timer 0 restarts when the counter value becomes equal to or greater than ( T0TARGET.VALUE - 1).</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MAN</name>
                  <value>0</value>
                  <description>Manual mode.

Timer 0 stops and T0CTL.EN becomes 0 when the counter value becomes equal to or greater than T0TARGET.VALUE.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>T1CFG</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Timer 1 Configuration</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>TICK_SRC_POL</name>
              <description>[13:13] Tick source polarity for Timer 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FALL</name>
                  <value>1</value>
                  <description>Count on falling edges of TICK_SRC.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISE</name>
                  <value>0</value>
                  <description>Count on rising edges of TICK_SRC.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TICK_SRC</name>
              <description>[12:8] Select Timer 1 tick source from the synchronous event bus.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ADC_IRQ</name>
                  <value>31</value>
                  <description>AUX_EVCTL:EVSTAT1.ADC_IRQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCU_EVENT</name>
                  <value>30</value>
                  <description>AUX_EVCTL:EVSTAT1.MCU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACLK_REF</name>
                  <value>29</value>
                  <description>AUX_EVCTL:EVSTAT1.ACLK_REF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO15</name>
                  <value>28</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO15</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO14</name>
                  <value>27</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO14</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO13</name>
                  <value>26</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO13</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO12</name>
                  <value>25</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO12</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO11</name>
                  <value>24</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO11</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO10</name>
                  <value>23</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO10</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO9</name>
                  <value>22</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO9</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO8</name>
                  <value>21</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO7</name>
                  <value>20</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO6</name>
                  <value>19</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO5</name>
                  <value>18</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO4</name>
                  <value>17</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO3</name>
                  <value>16</value>
                  <description>AUX_EVCTL:EVSTAT1.AUXIO3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO2</name>
                  <value>15</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO1</name>
                  <value>14</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUXIO0</name>
                  <value>13</value>
                  <description>AUX_EVCTL:EVSTAT0.AUXIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG_WU</name>
                  <value>12</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_PROG_WU</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_SW</name>
                  <value>11</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_SW</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX1</name>
                  <value>10</value>
                  <description>AUX_EVCTL:EVSTAT0.OBSMUX1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OBSMUX0</name>
                  <value>9</value>
                  <description>AUX_EVCTL:EVSTAT0.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_4KHZ</name>
                  <value>8</value>
                  <description>AON_RTC:SUBSEC.VALUE bit 19. AON_RTC:CTL.RTC_4KHZ_EN enables this event.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADC_DONE</name>
                  <value>7</value>
                  <description>AUX_EVCTL:EVSTAT0.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SMPH_AUTOTAKE_DONE</name>
                  <value>6</value>
                  <description>AUX_EVCTL:EVSTAT0.SMPH_AUTOTAKE_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMER0_EV</name>
                  <value>4</value>
                  <description>AUX_EVCTL:EVSTAT0.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDC_DONE</name>
                  <value>3</value>
                  <description>AUX_EVCTL:EVSTAT0.TDC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>2</value>
                  <description>AUX_EVCTL:EVSTAT0.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>1</value>
                  <description>AUX_EVCTL:EVSTAT0.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RTC_CH2_EV</name>
                  <value>0</value>
                  <description>AUX_EVCTL:EVSTAT0.AON_RTC_CH2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PRE</name>
              <description>[7:4] Prescaler division ratio is 2^PRE:

0x0: Divide by 1.
0x1: Divide by 2.
0x2: Divide by 4.
... 
0xF: Divide by 32,768.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[3:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MODE</name>
              <description>[1:1] Timer 1 mode.

Configure source for Timer 1 prescaler.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TICK</name>
                  <value>1</value>
                  <description>Use event set by TICK_SRC as source for prescaler.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <value>0</value>
                  <description>Use AUX clock as source for prescaler.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RELOAD</name>
              <description>[0:0] Timer 1 reload mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CONT</name>
                  <value>1</value>
                  <description>Continuous mode.

Timer 1 restarts when the counter value becomes equal to or greater than ( T1TARGET.VALUE - 1).</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MAN</name>
                  <value>0</value>
                  <description>Manual mode.

Timer 1 stops and T1CTL.EN becomes 0 when the counter value becomes equal to or greater than T1TARGET.VALUE.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>T0CTL</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Timer 0 Control</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] Timer 0 enable.

0: Disable Timer 0.
1: Enable Timer 0.

The counter restarts from 0 when you enable Timer 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>T0TARGET</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Timer 0 Target</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VALUE</name>
              <description>[15:0] Timer 0 target value.

Manual Reload Mode:
- Timer 0 increments until the counter value becomes equal to or greater than VALUE. 
- AUX_TIMER0_EV pulses high for 1 AUX clock period when the counter value is equal to or greater than VALUE.

Note: When VALUE is 0, Timer 0 counts to 1. AUX_TIMER0_EV pulses high for 1 AUX clock period.

Continuous Reload Mode:
- Timer 0 increments until the counter value becomes equal to or greater than ( VALUE - 1), then restarts from 0.
- AUX_TIMER0_EV pulses high for 1 AUX clock period when the counter value is 0, except for when you enable the timer.

Note: When VALUE is less than 2, Timer 0 counter value remains 0. AUX_TIMER0_EV goes high and remains high 1 AUX clock period after you enable the timer.


It is allowed to update the VALUE while the timer runs.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>T1TARGET</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Timer 1 Target

Timer 1 counter target value</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VALUE</name>
              <description>[7:0] Timer 1 target value.

Manual Reload Mode:
- Timer 1 increments until the counter value becomes equal to or greater than VALUE. 
- AUX_TIMER1_EV pulses high for 1 AUX clock period when the counter value is equal to or greater than VALUE.

Note: When VALUE is 0, Timer 1 counts to 1. AUX_TIMER1_EV pulses high for 1 AUX clock period.

Continuous Reload Mode:
- Timer 1 increments until the counter value becomes equal to or greater than ( VALUE - 1), then restarts from 0.
- AUX_TIMER1_EV pulses high for 1 AUX clock period when the counter value is 0, except for when you enable the timer.

Note: When VALUE is less than 2, Timer 1 counter value remains 0. AUX_TIMER1_EV goes high and remains high 1 AUX clock period after you enable the timer.


It is allowed to update the VALUE while the timer runs.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>T1CTL</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Timer 1 Control</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] Timer 1 enable.

0: Disable Timer 1.
1: Enable Timer 1.

The counter restarts from 0 when you enable Timer 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>AUX_WUC</name>
      <baseAddress>0x400C6000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>AUX Wake-up controller</description>
      <registers>
        <register>
          <name>MODCLKEN0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Module Clock Enable

Clock enable for each module in the AUX domain

For use by the system CPU

The settings in this register are OR'ed with the corresponding settings in MODCLKEN1. This allows the system CPU and AUX_SCE to request clocks independently. Settings take effect immediately.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AUX_ADI4</name>
              <description>[7:7] Enables (1) or disables (0) clock for AUX_ADI4.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>System CPU has requested clock for AUX_ADI4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>System CPU has not requested clock for AUX_ADI4</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUX_DDI0_OSC</name>
              <description>[6:6] Enables (1) or disables (0) clock for AUX_DDI0_OSC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>System CPU has requested clock for AUX_DDI0_OSC</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>System CPU has not requested clock for AUX_DDI0_OSC</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TDC</name>
              <description>[5:5] Enables (1) or disables (0) clock for AUX_TDCIF. 

Note that the TDC counter and reference clock sources must be requested separately using TDCCLKCTL and REFCLKCTL, respectively.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>System CPU has requested clock for TDC</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>System CPU has not requested clock for TDC</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ANAIF</name>
              <description>[4:4] Enables (1) or disables (0) clock for AUX_ANAIF.

Note that the ADC internal clock must be requested separately using ADCCLKCTL.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>System CPU has requested clock for ANAIF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>System CPU has not requested clock for ANAIF</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER</name>
              <description>[3:3] Enables (1) or disables (0) clock for AUX_TIMER.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>System CPU has requested clock for TIMER</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>System CPU has not requested clock for TIMER</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AIODIO1</name>
              <description>[2:2] Enables (1) or disables (0) clock for AUX_AIODIO1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>System CPU has requested clock for AIODIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>System CPU has not requested clock for AIODIO1</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AIODIO0</name>
              <description>[1:1] Enables (1) or disables (0) clock for AUX_AIODIO0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>System CPU has requested clock for AIODIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>System CPU has not requested clock for AIODIO0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPH</name>
              <description>[0:0] Enables (1) or disables (0) clock for AUX_SMPH.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>System CPU has requested clock for SMPH</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>System CPU has not requested clock for SMPH</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PWROFFREQ</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Power Off Request

Requests power off request for the AUX domain. When powered off, the power supply and clock is disabled. This may only be used when taking the entire device into shutdown mode (i.e. with full device reset when resuming operation).

Power off is prevented if AON_WUC:AUXCTL.AUX_FORCE_ON has been set, or if MCUBUSCTL.DISCONNECT_REQ has been cleared.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>REQ</name>
              <description>[0:0] Power off request

0: No action
1: Request to power down AUX. Once set, this bit shall not be cleared. The bit will be reset again when AUX is powered up again.

The request will only happen if AONCTLSTAT.AUX_FORCE_ON = 0 and MCUBUSSTAT.DISCONNECTED=1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PWRDWNREQ</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Power Down Request

Request from AUX for system to enter power down. When system is in power down there is limited current supply available and the clock source is set by AON_WUC:AUXCLK.PWR_DWN_SRC</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>REQ</name>
              <description>[0:0] Power down request

0: Request for system to be in active mode
1: Request for system to be in power down mode

When REQ is 1 one shall assume that the system is in power down, and that current supply is limited. When setting REQ = 0, one shall assume that the system is in power down until  PWRDWNACK.ACK = 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PWRDWNACK</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Power Down Acknowledgment</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ACK</name>
              <description>[0:0] Power down acknowledgment. Indicates whether the power down request given by PWRDWNREQ.REQ is captured by the AON domain or not

0: AUX can assume that the system is in active mode
1: The request for power down is acknowledged and the AUX must act like the system is in power down mode and power supply is limited

The system CPU cannot use this bit since the bus bridge between MCU domain and AUX domain is always disconnected when this bit is set. For AUX_SCE use only</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CLKLFREQ</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Low Frequency Clock Request</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>REQ</name>
              <description>[0:0] Low frequency request 

0: Request clock frequency to be controlled by AON_WUC:AUXCLK and the system state
1: Request low frequency clock SCLK_LF as the clock source for AUX

This bit must not be modified unless CLKLFACK.ACK matches the current value</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CLKLFACK</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Low Frequency Clock Acknowledgment</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ACK</name>
              <description>[0:0] Acknowledgment of CLKLFREQ.REQ

0: Acknowledgement that clock frequency is controlled by AON_WUC:AUXCLK and the system state
1: Acknowledgement that the low frequency clock SCLK_LF is the clock source for AUX</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>WUEVFLAGS</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Wake-up Event Flags

Status of wake-up events from the AON domain

The event flags are cleared by setting the corresponding bits in WUEVCLR</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>AON_RTC_CH2</name>
              <description>[2:2] Indicates pending event from AON_RTC_CH2 compare. Note that this flag will be set whenever the AON_RTC_CH2 event happens, but that does not mean that this event is a wake-up event. To make the AON_RTC_CH2 a wake-up event for the AUX domain configure it as a wake-up event in AON_EVENT:AUXWUSEL.WU0_EV, AON_EVENT:AUXWUSEL.WU1_EV or AON_EVENT:AUXWUSEL.WU2_EV.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AON_SW</name>
              <description>[1:1] Indicates pending event triggered by system CPU writing a 1 to AON_WUC:AUXCTL.SWEV.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>AON_PROG_WU</name>
              <description>[0:0] Indicates pending event triggered by the sources selected in AON_EVENT:AUXWUSEL.WU0_EV, AON_EVENT:AUXWUSEL.WU1_EV and AON_EVENT:AUXWUSEL.WU2_EV.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>WUEVCLR</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Wake-up Event Clear

Clears wake-up events from the AON domain</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>AON_RTC_CH2</name>
              <description>[2:2] Set to clear the WUEVFLAGS.AON_RTC_CH2 wake-up event. Note that if RTC channel 2 is also set as source for AON_PROG_WU this field can also clear WUEVFLAGS.AON_PROG_WU

This bit must remain set until WUEVFLAGS.AON_RTC_CH2 returns to 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AON_SW</name>
              <description>[1:1] Set to clear the WUEVFLAGS.AON_SW wake-up event. 

This bit must remain set until WUEVFLAGS.AON_SW returns to 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>AON_PROG_WU</name>
              <description>[0:0] Set to clear the WUEVFLAGS.AON_PROG_WU wake-up event. Note only if an IO event is selected as wake-up event, is it possible to use this field to clear the source. Other sources cannot be cleared using this field.

The IO pin needs to be assigned to AUX in the IOC and the input enable for the pin needs to be set in AIODIO0 or AIODIO1 for this clearing to take effect.

This bit must remain set until WUEVFLAGS.AON_PROG_WU returns to 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ADCCLKCTL</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>ADC Clock Control

Controls the ADC internal clock

Note that the ADC command and data interface requires MODCLKEN0.ANAIF or MODCLKEN1.ANAIF also to be set</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ACK</name>
              <description>[1:1] Acknowledges the last value written to REQ.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>REQ</name>
              <description>[0:0] Enables(1) or disables (0) the ADC internal clock.

This bit must not be modified unless ACK matches the current value.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TDCCLKCTL</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>TDC Clock Control

Controls the TDC counter clock source, which steps the TDC counter value

The source of this clock is controlled by OSC_DIG:CTL0.ACLK_TDC_SRC_SEL.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ACK</name>
              <description>[1:1] Acknowledges the last value written to REQ.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>REQ</name>
              <description>[0:0] Enables(1) or disables (0) the TDC counter clock source.

This bit must not be modified unless ACK matches the current value.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>REFCLKCTL</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Reference Clock Control

Controls the TDC reference clock source, which is to be compared against the TDC counter clock. 

The source of this clock is controlled by OSC_DIG:CTL0.ACLK_REF_SRC_SEL.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ACK</name>
              <description>[1:1] Acknowledges the last value written to REQ.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>REQ</name>
              <description>[0:0] Enables(1) or disables (0) the TDC reference clock source.

This bit must not be modified unless ACK matches the current value.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RTCSUBSECINC0</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Real Time Counter Sub Second Increment 0

New value for the real-time counter (AON_RTC) sub-second increment value, part corresponding to AON_RTC:SUBSECINC bits 15:0.

After setting INC15_0 and RTCSUBSECINC1.INC23_16, the value is loaded into AON_RTC:SUBSECINC.VALUEINC by setting RTCSUBSECINCCTL.UPD_REQ.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>INC15_0</name>
              <description>[15:0] Bits 15:0 of the RTC sub-second increment value.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RTCSUBSECINC1</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Real Time Counter Sub Second Increment 1

New value for the real-time counter (AON_RTC) sub-second increment value, part corresponding to AON_RTC:SUBSECINC bits 23:16.

After setting RTCSUBSECINC0.INC15_0 and INC23_16, the value is loaded into AON_RTC:SUBSECINC.VALUEINC by setting RTCSUBSECINCCTL.UPD_REQ.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>INC23_16</name>
              <description>[7:0] Bits 23:16 of the RTC sub-second increment value.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RTCSUBSECINCCTL</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Real Time Counter Sub Second Increment Control</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>UPD_ACK</name>
              <description>[1:1] Acknowledgment of the UPD_REQ.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>UPD_REQ</name>
              <description>[0:0] Signal that a new real time counter sub second increment value is available

0: New sub second increment is not available
1: New sub second increment is available

This bit must not be modified unless UPD_ACK matches the current value.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MCUBUSCTL</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>MCU Bus Control

Controls the connection between the AUX domain bus and the MCU domain bus.

The buses must be disconnected to allow power-down or power-off of the AUX domain.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DISCONNECT_REQ</name>
              <description>[0:0] Requests the AUX domain bus to be disconnected from the MCU domain bus. The request has no effect when AON_WUC:AUX_CTL.AUX_FORCE_ON is set.

The disconnection status can be monitored through MCUBUSSTAT. Note however that this register cannot be read by the system CPU while disconnected.

It is recommended that this bit is set and remains set after initial power-up, and that the system CPU uses AON_WUC:AUX_CTL.AUX_FORCE_ON to connect/disconnect the bus.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MCUBUSSTAT</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>MCU Bus Status

Indicates the connection state of the AUX domain and MCU domain buses.

Note that this register cannot be read from the MCU domain while disconnected, and is therefore only useful for the AUX_SCE.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DISCONNECTED</name>
              <description>[1:1] Indicates whether the AUX domain and MCU domain buses are currently disconnected (1) or connected (0).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DISCONNECT_ACK</name>
              <description>[0:0] Acknowledges reception of the bus disconnection request, by matching the value of MCUBUSCTL.DISCONNECT_REQ. 

Note that if AON_WUC:AUXCTL.AUX_FORCE_ON = 1 a reconnect to the MCU domain bus will be made regardless of the state of MCUBUSCTL.DISCONNECT_REQ</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AONCTLSTAT</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>AON Domain Control Status

Status of AUX domain control from AON_WUC.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AUX_FORCE_ON</name>
              <description>[1:1] Status of AON_WUC:AUX_CTL.AUX_FORCE_ON.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SCE_RUN_EN</name>
              <description>[0:0] Status of AON_WUC:AUX_CTL.SCE_RUN_EN.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AUXIOLATCH</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>AUX Input Output Latch

Controls latching of signals between AUX_AIODIO0/AUX_AIODIO1 and AON_IOC.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] Opens (1) or closes (0) the AUX_AIODIO0/AUX_AIODIO1 signal latching.

At startup, set EN = TRANSP before configuring AUX_AIODIO0/AUX_AIODIO1 and subsequently selecting AUX mode in the AON_IOC.

When powering off the AUX domain (using PWROFFREQ.REQ), set EN = STATIC in advance preserve the current state (mode and output value) of the I/O pins.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TRANSP</name>
                  <value>1</value>
                  <description>Latches are transparent ( open )</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STATIC</name>
                  <value>0</value>
                  <description>Latches are static ( closed )</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MODCLKEN1</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Module Clock Enable 1

Clock enable for each module in the AUX domain, for use by the AUX_SCE. Settings take effect immediately.

The settings in this register are OR'ed with the corresponding settings in MODCLKEN0. This allows system CPU and AUX_SCE to request clocks independently.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AUX_ADI4</name>
              <description>[7:7] Enables (1) or disables (0) clock for AUX_ADI4.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>AUX_SCE has requested clock for AUX_ADI4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>AUX_SCE has not requested clock for AUX_ADI4</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AUX_DDI0_OSC</name>
              <description>[6:6] Enables (1) or disables (0) clock for AUX_DDI0_OSC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>AUX_SCE has requested clock for AUX_DDI0_OSC</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>AUX_SCE has not requested clock for AUX_DDI0_OSC</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TDC</name>
              <description>[5:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>ANAIF</name>
              <description>[4:4] Enables (1) or disables (0) clock for AUX_ANAIF.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>AUX_SCE has requested clock for ANAIF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>AUX_SCE has not requested clock for ANAIF</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TIMER</name>
              <description>[3:3] Enables (1) or disables (0) clock for AUX_TIMER.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>AUX_SCE has requested clock for TIMER</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>AUX_SCE has not requested clock for TIMER</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AIODIO1</name>
              <description>[2:2] Enables (1) or disables (0) clock for AUX_AIODIO1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>AUX_SCE has requested clock for AIODIO1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>AUX_SCE has not requested clock for AIODIO1</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AIODIO0</name>
              <description>[1:1] Enables (1) or disables (0) clock for AUX_AIODIO0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>AUX_SCE has requested clock for AIODIO0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>AUX_SCE has not requested clock for AIODIO0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPH</name>
              <description>[0:0] Enables (1) or disables (0) clock for AUX_SMPH.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>AUX_SCE has requested clock for SMPH</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>AUX_SCE has not requested clock for SMPH</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CCFG</name>
      <baseAddress>0x50003000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Customer configuration area (CCFG)</description>
      <registers>
        <register>
          <name>RESERVED_0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>EXT_LF_CLK</name>
          <addressOffset>0xfa8</addressOffset>
          <size>32</size>
          <description>Extern LF clock configuration</description>
          <fields>
            <field>
              <name>DIO</name>
              <description>[31:24] Unsigned integer, selecting the DIO to supply external 32kHz clock as SCLK_LF when MODE_CONF.SCLK_LF_OPTION is set to EXTERNAL. The selected DIO will be marked as reserved by the pin driver (TI-RTOS environment) and hence not selectable for other usage.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RTC_INCREMENT</name>
              <description>[23:0] Unsigned integer, defining the input frequency of the external clock and is written to AON_RTC:SUBSECINC.VALUEINC. Defined as follows: EXT_LF_CLK.RTC_INCREMENT = 2^38/InputClockFrequency in Hertz (e.g.: RTC_INCREMENT=0x800000 for InputClockFrequency=32768 Hz)</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>MODE_CONF_1</name>
          <addressOffset>0xfac</addressOffset>
          <size>32</size>
          <description>Mode Configuration 1</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>ALT_DCDC_VMIN</name>
              <description>[23:20] Minimum voltage for when DC/DC should be used if alternate DC/DC setting is enabled (SIZE_AND_DIS_FLAGS.DIS_ALT_DCDC_SETTING=0).
Voltage = (28 + ALT_DCDC_VMIN) / 16.
0: 1.75V
1: 1.8125V
...
14: 2.625V
15: 2.6875V

NOTE! The DriverLib function SysCtrl_DCDC_VoltageConditionalControl() must be called regularly to apply this field (handled automatically if using TI RTOS!).</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>ALT_DCDC_DITHER_EN</name>
              <description>[19:19] Enable DC/DC dithering if alternate DC/DC setting is enabled (SIZE_AND_DIS_FLAGS.DIS_ALT_DCDC_SETTING=0).
0: Dither disable
1: Dither enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>ALT_DCDC_IPEAK</name>
              <description>[18:16] Inductor peak current if alternate DC/DC setting is enabled (SIZE_AND_DIS_FLAGS.DIS_ALT_DCDC_SETTING=0). Assuming 10uH external inductor!
Peak current = 31 + ( 4 * ALT_DCDC_IPEAK ) :
0: 31mA (min)
...
4: 47mA
...
7: 59mA (max)</description>
              <bitWidth>3</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DELTA_IBIAS_INIT</name>
              <description>[15:12] Signed delta value for IBIAS_INIT. Delta value only applies if SIZE_AND_DIS_FLAGS.DIS_XOSC_OVR=0.
See FCFG1:AMPCOMP_CTRL1.IBIAS_INIT</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DELTA_IBIAS_OFFSET</name>
              <description>[11:8] Signed delta value for IBIAS_OFFSET. Delta value only applies if SIZE_AND_DIS_FLAGS.DIS_XOSC_OVR=0.
See FCFG1:AMPCOMP_CTRL1.IBIAS_OFFSET</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>XOSC_MAX_START</name>
              <description>[7:0] Unsigned value of maximum XOSC startup time (worst case) in units of 100us. Value only applies if SIZE_AND_DIS_FLAGS.DIS_XOSC_OVR=0.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFBFFFF</resetValue>
        </register>
        <register>
          <name>SIZE_AND_DIS_FLAGS</name>
          <addressOffset>0xfb0</addressOffset>
          <size>32</size>
          <description>CCFG Size and Disable Flags</description>
          <fields>
            <field>
              <name>SIZE_OF_CCFG</name>
              <description>[31:16] Total size of CCFG in bytes.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DISABLE_FLAGS</name>
              <description>[15:4] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DIS_TCXO</name>
              <description>[3:3] Disable TCXO.
0: TCXO functionality enabled.
1: TCXO functionality disabled.
Note:
An external TCXO is required if DIS_TCXO = 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DIS_GPRAM</name>
              <description>[2:2] Disable GPRAM (or use the 8K VIMS RAM as CACHE RAM).
0: GPRAM is enabled and hence CACHE disabled.
1: GPRAM is disabled and instead CACHE is enabled (default).
Notes:
- Disabling CACHE will reduce CPU execution speed (up to 60%).
- GPRAM is 8 K-bytes in size and located at 0x11000000-0x11001FFF if enabled.
See:
VIMS:CTL.MODE</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DIS_ALT_DCDC_SETTING</name>
              <description>[1:1] Disable alternate DC/DC settings. 
0: Enable alternate DC/DC settings.
1: Disable alternate DC/DC settings.
See:
MODE_CONF_1.ALT_DCDC_VMIN
MODE_CONF_1.ALT_DCDC_DITHER_EN
MODE_CONF_1.ALT_DCDC_IPEAK

NOTE! The DriverLib function SysCtrl_DCDC_VoltageConditionalControl() must be called regularly to apply this field (handled automatically if using TI RTOS!).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIS_XOSC_OVR</name>
              <description>[0:0] Disable XOSC override functionality.
0: Enable XOSC override functionality.
1: Disable XOSC override functionality.
See:
MODE_CONF_1.DELTA_IBIAS_INIT
MODE_CONF_1.DELTA_IBIAS_OFFSET
MODE_CONF_1.XOSC_MAX_START</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>MODE_CONF</name>
          <addressOffset>0xfb4</addressOffset>
          <size>32</size>
          <description>Mode Configuration 0</description>
          <fields>
            <field>
              <name>VDDR_TRIM_SLEEP_DELTA</name>
              <description>[31:28] Signed delta value to apply to the
VDDR_TRIM_SLEEP target, minus one. See FCFG1:VOLT_TRIM.VDDR_TRIM_SLEEP_H.
0x8 (-8) : Delta = -7
...
0xF (-1) : Delta = 0
0x0 (0) : Delta = +1
...
0x7 (7) : Delta = +8</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>DCDC_RECHARGE</name>
              <description>[27:27] DC/DC during recharge in powerdown.
0: Use the DC/DC during recharge in powerdown.
1: Do not use the DC/DC during recharge in powerdown (default).

NOTE! The DriverLib function SysCtrl_DCDC_VoltageConditionalControl() must be called regularly to apply this field (handled automatically if using TI RTOS!).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>DCDC_ACTIVE</name>
              <description>[26:26] DC/DC in active mode.
0: Use the DC/DC during active mode.
1: Do not use the DC/DC during active mode (default).

NOTE! The DriverLib function SysCtrl_DCDC_VoltageConditionalControl() must be called regularly to apply this field (handled automatically if using TI RTOS!).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>VDDR_EXT_LOAD</name>
              <description>[25:25] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>VDDS_BOD_LEVEL</name>
              <description>[24:24] VDDS BOD level.
0: VDDS BOD level is 2.0 V (necessary for maximum PA output power on CC13x0).
1: VDDS BOD level is 1.8 V (or 1.7 V for external regulator mode) (default).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>SCLK_LF_OPTION</name>
              <description>[23:22] Select source for SCLK_LF.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RCOSC_LF</name>
                  <value>3</value>
                  <description>Low frequency RCOSC (default)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XOSC_LF</name>
                  <value>2</value>
                  <description>32.768kHz low frequency XOSC</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTERNAL_LF</name>
                  <value>1</value>
                  <description>External low frequency clock on DIO defined by EXT_LF_CLK.DIO. The RTC tick speed AON_RTC:SUBSECINC is updated to EXT_LF_CLK.RTC_INCREMENT (done in the trimDevice() xxWare boot function). External clock must always be running when the chip is in standby for VDDR recharge timing.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>XOSC_HF_DLF</name>
                  <value>0</value>
                  <description>31.25kHz clock derived from 24MHz XOSC (dividing by 768 in HW). The RTC tick speed [AON_RTC.SUBSECINC.*] is updated to 0x8637BD, corresponding to a 31.25kHz clock (done in the trimDevice() xxWare boot function). Standby power mode is not supported when using this clock source.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VDDR_TRIM_SLEEP_TC</name>
              <description>[21:21] 0x1: VDDR_TRIM_SLEEP_DELTA is not temperature compensated
0x0: RTOS/driver temperature compensates VDDR_TRIM_SLEEP_DELTA every time standby mode is entered. This improves low-temperature RCOSC_LF frequency stability in standby mode.

When temperature compensation is performed, the delta is calculates this way:
Delta = max (delta, min(8, floor(62-temp)/8))
Here, delta is given by VDDR_TRIM_SLEEP_DELTA, and temp is the current temperature in degrees C.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>RTC_COMP</name>
              <description>[20:20] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>XOSC_FREQ</name>
              <description>[19:18] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>18</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>24M</name>
                  <value>3</value>
                  <description>24 MHz XOSC_HF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>48M</name>
                  <value>2</value>
                  <description>48 MHz XOSC_HF</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPOSC</name>
                  <value>1</value>
                  <description>HPOSC</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>XOSC_CAP_MOD</name>
              <description>[17:17] Enable modification (delta) to XOSC cap-array. Value specified in XOSC_CAPARRAY_DELTA.
0: Apply cap-array delta
1: Do not apply cap-array delta (default)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>HF_COMP</name>
              <description>[16:16] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>XOSC_CAPARRAY_DELTA</name>
              <description>[15:8] Signed 8-bit value, directly modifying trimmed XOSC cap-array step value. Enabled by XOSC_CAP_MOD.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VDDR_CAP</name>
              <description>[7:0] Unsigned 8-bit integer, representing the minimum decoupling capacitance (worst case) on VDDR, in units of 100nF. This should take into account capacitor tolerance and voltage dependent capacitance variation. This bit affects the recharge period calculation when going into powerdown or standby.
 
NOTE! If using the following functions this field must be configured (used by TI RTOS):
SysCtrlSetRechargeBeforePowerDown() SysCtrlAdjustRechargeAfterPowerDown()</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>VOLT_LOAD_0</name>
          <addressOffset>0xfb8</addressOffset>
          <size>32</size>
          <description>Voltage Load 0
Enabled by MODE_CONF.VDDR_EXT_LOAD.</description>
          <fields>
            <field>
              <name>VDDR_EXT_TP45</name>
              <description>[31:24] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>VDDR_EXT_TP25</name>
              <description>[23:16] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VDDR_EXT_TP5</name>
              <description>[15:8] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VDDR_EXT_TM15</name>
              <description>[7:0] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>VOLT_LOAD_1</name>
          <addressOffset>0xfbc</addressOffset>
          <size>32</size>
          <description>Voltage Load 1
Enabled by MODE_CONF.VDDR_EXT_LOAD.</description>
          <fields>
            <field>
              <name>VDDR_EXT_TP125</name>
              <description>[31:24] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>VDDR_EXT_TP105</name>
              <description>[23:16] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VDDR_EXT_TP85</name>
              <description>[15:8] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VDDR_EXT_TP65</name>
              <description>[7:0] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>RTC_OFFSET</name>
          <addressOffset>0xfc0</addressOffset>
          <size>32</size>
          <description>Real Time Clock Offset
Enabled by MODE_CONF.RTC_COMP.</description>
          <fields>
            <field>
              <name>RTC_COMP_P0</name>
              <description>[31:16] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RTC_COMP_P1</name>
              <description>[15:8] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RTC_COMP_P2</name>
              <description>[7:0] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>FREQ_OFFSET</name>
          <addressOffset>0xfc4</addressOffset>
          <size>32</size>
          <description>Frequency Offset</description>
          <fields>
            <field>
              <name>HF_COMP_P0</name>
              <description>[31:16] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>HF_COMP_P1</name>
              <description>[15:8] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>HF_COMP_P2</name>
              <description>[7:0] Reserved for future use. Software should not rely on the value of a reserved. Writing any other value than the reset/default value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>IEEE_MAC_0</name>
          <addressOffset>0xfc8</addressOffset>
          <size>32</size>
          <description>IEEE MAC Address 0</description>
          <fields>
            <field>
              <name>ADDR</name>
              <description>[31:0] Bits[31:0] of the 64-bits custom IEEE MAC address.
If different from 0xFFFFFFFF then the value of this field is applied; otherwise use value from FCFG.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>IEEE_MAC_1</name>
          <addressOffset>0xfcc</addressOffset>
          <size>32</size>
          <description>IEEE MAC Address 1</description>
          <fields>
            <field>
              <name>ADDR</name>
              <description>[31:0] Bits[63:32] of the 64-bits custom IEEE MAC address.
If different from 0xFFFFFFFF then the value of this field is applied; otherwise use value from FCFG.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>IEEE_BLE_0</name>
          <addressOffset>0xfd0</addressOffset>
          <size>32</size>
          <description>IEEE BLE Address 0</description>
          <fields>
            <field>
              <name>ADDR</name>
              <description>[31:0] Bits[31:0] of the 64-bits custom IEEE BLE address.
If different from 0xFFFFFFFF then the value of this field is applied; otherwise use value from FCFG.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>IEEE_BLE_1</name>
          <addressOffset>0xfd4</addressOffset>
          <size>32</size>
          <description>IEEE BLE Address 1</description>
          <fields>
            <field>
              <name>ADDR</name>
              <description>[31:0] Bits[63:32] of the 64-bits custom IEEE BLE address.
If different from 0xFFFFFFFF then the value of this field is applied; otherwise use value from FCFG.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>BL_CONFIG</name>
          <addressOffset>0xfd8</addressOffset>
          <size>32</size>
          <description>Bootloader Configuration
Configures the functionality of the ROM boot loader.
If both the boot loader is enabled by the BOOTLOADER_ENABLE field and the boot loader backdoor is enabled by the BL_ENABLE field it is possible to force entry of the ROM boot loader even if a valid image is present in flash.</description>
          <fields>
            <field>
              <name>BOOTLOADER_ENABLE</name>
              <description>[31:24] Bootloader enable. Boot loader can be accessed if IMAGE_VALID_CONF.IMAGE_VALID is non-zero or BL_ENABLE is enabled (and conditions for boot loader backdoor are met).
0xC5: Boot loader is enabled.
Any other value: Boot loader is disabled.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[23:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>BL_LEVEL</name>
              <description>[16:16] Sets the active level of the selected DIO number BL_PIN_NUMBER if boot loader backdoor is enabled by the BL_ENABLE field.
0: Active low.
1: Active high.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>BL_PIN_NUMBER</name>
              <description>[15:8] DIO number that is level checked if the boot loader backdoor is enabled by the BL_ENABLE field.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BL_ENABLE</name>
              <description>[7:0] Enables the boot loader backdoor.
0xC5: Boot loader backdoor is enabled.
Any other value: Boot loader backdoor is disabled.

NOTE! Boot loader must be enabled (see BOOTLOADER_ENABLE) if boot loader backdoor is enabled.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xC5FFFFFF</resetValue>
        </register>
        <register>
          <name>ERASE_CONF</name>
          <addressOffset>0xfdc</addressOffset>
          <size>32</size>
          <description>Erase Configuration</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>CHIP_ERASE_DIS_N</name>
              <description>[8:8] Chip erase.
This bit controls if a chip erase requested through the JTAG WUC TAP will be ignored in a following boot caused by a reset of the MCU VD.
A successful chip erase operation will force the content of the flash main bank back to the state as it was when delivered by TI. 
0: Disable. Any chip erase request detected during boot will be ignored.
1: Enable. Any chip erase request detected during boot will be performed by the boot FW.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>BANK_ERASE_DIS_N</name>
              <description>[0:0] Bank erase.
This bit controls if the ROM serial boot loader will accept a received Bank Erase command (COMMAND_BANK_ERASE).
A successful Bank Erase operation will erase all main bank sectors not protected by write protect configuration bits in CCFG.
0: Disable the boot loader bank erase function.
1: Enable the boot loader bank erase function.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>CCFG_TI_OPTIONS</name>
          <addressOffset>0xfe0</addressOffset>
          <size>32</size>
          <description>TI Options</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TI_FA_ENABLE</name>
              <description>[7:0] TI Failure Analysis.
0xC5: Enable the functionality of unlocking the TI FA (TI Failure Analysis) option with the unlock code.
All other values: Disable the functionality of unlocking the TI FA option with the unlock code.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFC5</resetValue>
        </register>
        <register>
          <name>CCFG_TAP_DAP_0</name>
          <addressOffset>0xfe4</addressOffset>
          <size>32</size>
          <description>Test Access Points Enable 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CPU_DAP_ENABLE</name>
              <description>[23:16] Enable CPU DAP.
0xC5: Main CPU DAP access is enabled during power-up/system-reset by ROM boot FW.
Any other value: Main CPU DAP access will remain disabled out of power-up/system-reset.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PRCM_TAP_ENABLE</name>
              <description>[15:8] Enable PRCM TAP.
0xC5: PRCM TAP access is enabled during power-up/system-reset by ROM boot FW if enabled by corresponding configuration value in FCFG1 defined by TI.
Any other value: PRCM TAP access will remain disabled out of power-up/system-reset.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TEST_TAP_ENABLE</name>
              <description>[7:0] Enable Test TAP.
0xC5: TEST TAP access is enabled during power-up/system-reset by ROM boot FW if enabled by corresponding configuration value in FCFG1 defined by TI.
Any other value: TEST TAP access will remain disabled out of power-up/system-reset.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFC5C5C5</resetValue>
        </register>
        <register>
          <name>CCFG_TAP_DAP_1</name>
          <addressOffset>0xfe8</addressOffset>
          <size>32</size>
          <description>Test Access Points Enable 1</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PBIST2_TAP_ENABLE</name>
              <description>[23:16] Enable PBIST2 TAP.
0xC5: PBIST2 TAP access is enabled during power-up/system-reset by ROM boot FW if enabled by corresponding configuration value in FCFG1 defined by TI.
Any other value: PBIST2 TAP access will remain disabled out of power-up/system-reset.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PBIST1_TAP_ENABLE</name>
              <description>[15:8] Enable PBIST1 TAP.
0xC5: PBIST1 TAP access is enabled during power-up/system-reset by ROM boot FW if enabled by corresponding configuration value in FCFG1 defined by TI.
Any other value: PBIST1 TAP access will remain disabled out of power-up/system-reset.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>WUC_TAP_ENABLE</name>
              <description>[7:0] Enable WUC TAP
0xC5: WUC TAP access is enabled during power-up/system-reset by ROM boot FW if enabled by corresponding configuration value in FCFG1 defined by TI.
Any other value: WUC TAP access will remain disabled out of power-up/system-reset.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFC5C5C5</resetValue>
        </register>
        <register>
          <name>IMAGE_VALID_CONF</name>
          <addressOffset>0xfec</addressOffset>
          <size>32</size>
          <description>Image Valid</description>
          <fields>
            <field>
              <name>IMAGE_VALID</name>
              <description>[31:0] This field must have a value of 0x00000000 in order for enabling the boot sequence to transfer control to a flash image.
A non-zero value forces the boot sequence to call the boot loader.

For CC2640R2:
This field must have the address value of the start of the flash vector table in order for enabling the boot sequence to transfer control to a flash image.
Any illegal vector table start address value forces the boot sequence to call the boot loader.
Note that if any other legal vector table start address value than 0x0 is selected the PRCM:WARMRESET.WR_TO_PINRESET must be set to 1.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>CCFG_PROT_31_0</name>
          <addressOffset>0xff0</addressOffset>
          <size>32</size>
          <description>Protect Sectors 0-31
Each bit write protects one 4KB flash sector from being both programmed and erased. Bit must be set to 0 in order to enable sector write protect.</description>
          <fields>
            <field>
              <name>WRT_PROT_SEC_31</name>
              <description>[31:31] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_30</name>
              <description>[30:30] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_29</name>
              <description>[29:29] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_28</name>
              <description>[28:28] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_27</name>
              <description>[27:27] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_26</name>
              <description>[26:26] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_25</name>
              <description>[25:25] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_24</name>
              <description>[24:24] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_23</name>
              <description>[23:23] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_22</name>
              <description>[22:22] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_21</name>
              <description>[21:21] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_20</name>
              <description>[20:20] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_19</name>
              <description>[19:19] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_18</name>
              <description>[18:18] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_17</name>
              <description>[17:17] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_16</name>
              <description>[16:16] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_15</name>
              <description>[15:15] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_14</name>
              <description>[14:14] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_13</name>
              <description>[13:13] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_12</name>
              <description>[12:12] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_11</name>
              <description>[11:11] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_10</name>
              <description>[10:10] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_9</name>
              <description>[9:9] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_8</name>
              <description>[8:8] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_7</name>
              <description>[7:7] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_6</name>
              <description>[6:6] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_5</name>
              <description>[5:5] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_4</name>
              <description>[4:4] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_3</name>
              <description>[3:3] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_2</name>
              <description>[2:2] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_1</name>
              <description>[1:1] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_0</name>
              <description>[0:0] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>CCFG_PROT_63_32</name>
          <addressOffset>0xff4</addressOffset>
          <size>32</size>
          <description>Protect Sectors 32-63
Each bit write protects one 4KB flash sector from being both programmed and erased. Bit must be set to 0 in order to enable sector write protect. Not in use by CC26x0 and CC13x0.</description>
          <fields>
            <field>
              <name>WRT_PROT_SEC_63</name>
              <description>[31:31] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_62</name>
              <description>[30:30] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_61</name>
              <description>[29:29] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_60</name>
              <description>[28:28] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_59</name>
              <description>[27:27] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_58</name>
              <description>[26:26] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_57</name>
              <description>[25:25] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_56</name>
              <description>[24:24] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_55</name>
              <description>[23:23] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_54</name>
              <description>[22:22] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_53</name>
              <description>[21:21] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_52</name>
              <description>[20:20] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_51</name>
              <description>[19:19] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_50</name>
              <description>[18:18] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_49</name>
              <description>[17:17] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_48</name>
              <description>[16:16] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_47</name>
              <description>[15:15] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_46</name>
              <description>[14:14] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_45</name>
              <description>[13:13] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_44</name>
              <description>[12:12] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_43</name>
              <description>[11:11] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_42</name>
              <description>[10:10] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_41</name>
              <description>[9:9] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_40</name>
              <description>[8:8] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_39</name>
              <description>[7:7] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_38</name>
              <description>[6:6] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_37</name>
              <description>[5:5] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_36</name>
              <description>[4:4] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_35</name>
              <description>[3:3] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_34</name>
              <description>[2:2] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_33</name>
              <description>[1:1] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_32</name>
              <description>[0:0] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>CCFG_PROT_95_64</name>
          <addressOffset>0xff8</addressOffset>
          <size>32</size>
          <description>Protect Sectors 64-95
Each bit write protects one flash sector from being both programmed and erased. Bit must be set to 0 in order to enable sector write protect. Not in use by CC26x0 and CC13x0.</description>
          <fields>
            <field>
              <name>WRT_PROT_SEC_95</name>
              <description>[31:31] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_94</name>
              <description>[30:30] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_93</name>
              <description>[29:29] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_92</name>
              <description>[28:28] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_91</name>
              <description>[27:27] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_90</name>
              <description>[26:26] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_89</name>
              <description>[25:25] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_88</name>
              <description>[24:24] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_87</name>
              <description>[23:23] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_86</name>
              <description>[22:22] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_85</name>
              <description>[21:21] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_84</name>
              <description>[20:20] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_83</name>
              <description>[19:19] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_82</name>
              <description>[18:18] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_81</name>
              <description>[17:17] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_80</name>
              <description>[16:16] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_79</name>
              <description>[15:15] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_78</name>
              <description>[14:14] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_77</name>
              <description>[13:13] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_76</name>
              <description>[12:12] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_75</name>
              <description>[11:11] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_74</name>
              <description>[10:10] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_73</name>
              <description>[9:9] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_72</name>
              <description>[8:8] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_71</name>
              <description>[7:7] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_70</name>
              <description>[6:6] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_69</name>
              <description>[5:5] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_68</name>
              <description>[4:4] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_67</name>
              <description>[3:3] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_66</name>
              <description>[2:2] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_65</name>
              <description>[1:1] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_64</name>
              <description>[0:0] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>CCFG_PROT_127_96</name>
          <addressOffset>0xffc</addressOffset>
          <size>32</size>
          <description>Protect Sectors 96-127
Each bit write protects one flash sector from being both programmed and erased. Bit must be set to 0 in order to enable sector write protect. Not in use by CC26x0 and CC13x0.</description>
          <fields>
            <field>
              <name>WRT_PROT_SEC_127</name>
              <description>[31:31] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_126</name>
              <description>[30:30] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_125</name>
              <description>[29:29] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_124</name>
              <description>[28:28] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_123</name>
              <description>[27:27] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_122</name>
              <description>[26:26] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_121</name>
              <description>[25:25] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_120</name>
              <description>[24:24] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_119</name>
              <description>[23:23] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_118</name>
              <description>[22:22] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_117</name>
              <description>[21:21] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_116</name>
              <description>[20:20] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_115</name>
              <description>[19:19] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_114</name>
              <description>[18:18] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_113</name>
              <description>[17:17] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_112</name>
              <description>[16:16] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_111</name>
              <description>[15:15] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_110</name>
              <description>[14:14] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_109</name>
              <description>[13:13] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_108</name>
              <description>[12:12] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_107</name>
              <description>[11:11] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_106</name>
              <description>[10:10] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_105</name>
              <description>[9:9] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_104</name>
              <description>[8:8] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_103</name>
              <description>[7:7] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_102</name>
              <description>[6:6] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_101</name>
              <description>[5:5] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_100</name>
              <description>[4:4] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_99</name>
              <description>[3:3] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_98</name>
              <description>[2:2] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_97</name>
              <description>[1:1] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>WRT_PROT_SEC_96</name>
              <description>[0:0] 0: Sector protected</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPU_DWT</name>
      <baseAddress>0xE0001000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Cortex-M's Data watchpoint and Trace (DWT)</description>
      <registers>
        <register>
          <name>CTRL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Control
Use the DWT Control Register to enable the DWT unit.</description>
          <fields>
            <field>
              <name>RESERVED26</name>
              <description>[31:26] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>NOCYCCNT</name>
              <description>[25:25] When set, CYCCNT is not supported.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>NOPRFCNT</name>
              <description>[24:24] When set, FOLDCNT, LSUCNT, SLEEPCNT, EXCCNT, and CPICNT are not supported.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED23</name>
              <description>[23:23] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>CYCEVTENA</name>
              <description>[22:22] Enables Cycle count event. Emits an event when the POSTCNT counter triggers it. See CYCTAP and POSTPRESET for details. This event is only emitted if PCSAMPLEENA is disabled. PCSAMPLEENA overrides the setting of this bit. 

0: Cycle count events disabled
1: Cycle count events enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>FOLDEVTENA</name>
              <description>[21:21] Enables Folded instruction count event. Emits an event when FOLDCNT overflows (every 256 cycles of folded instructions). A folded instruction is one that does not incur even one cycle to execute. For example, an IT instruction is folded away and so does not use up one cycle.

0: Folded instruction count events disabled.
1: Folded instruction count events enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>LSUEVTENA</name>
              <description>[20:20] Enables LSU count event. Emits an event when LSUCNT overflows (every 256 cycles of LSU operation). LSU counts include all LSU costs after the initial cycle for the instruction.

0: LSU count events disabled.
1: LSU count events enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>SLEEPEVTENA</name>
              <description>[19:19] Enables Sleep count event. Emits an event when SLEEPCNT overflows (every 256 cycles that the processor is sleeping).

0: Sleep count events disabled.
1: Sleep count events enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EXCEVTENA</name>
              <description>[18:18] Enables Interrupt overhead event. Emits an event when EXCCNT overflows (every 256 cycles of interrupt overhead).

0x0: Interrupt overhead event disabled.
0x1: Interrupt overhead event enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>CPIEVTENA</name>
              <description>[17:17] Enables CPI count event. Emits an event when CPICNT overflows (every 256 cycles of multi-cycle instructions).

0: CPI counter events disabled.
1: CPI counter events enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>EXCTRCENA</name>
              <description>[16:16] Enables Interrupt event tracing.

0: Interrupt event trace disabled.
1: Interrupt event trace enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED13</name>
              <description>[15:13] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PCSAMPLEENA</name>
              <description>[12:12] Enables PC Sampling event. A PC sample event is emitted when the POSTCNT counter triggers it. See CYCTAP and POSTPRESET for details. Enabling this bit overrides CYCEVTENA.

0: PC Sampling event disabled.
1: Sampling event enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>SYNCTAP</name>
              <description>[11:10] Selects a synchronization packet rate. CYCCNTENA and CPU_ITM:TCR.SYNCENA must also be enabled for this feature.
Synchronization packets (if enabled) are generated on tap transitions (0 to1 or 1 to 0).</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT28</name>
                  <value>3</value>
                  <description>Tap at bit 28 of CYCCNT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT26</name>
                  <value>2</value>
                  <description>Tap at bit 26 of CYCCNT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT24</name>
                  <value>1</value>
                  <description>Tap at bit 24 of CYCCNT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disabled. No synchronization packets</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CYCTAP</name>
              <description>[9:9] Selects a tap on CYCCNT. These are spaced at bits [6] and [10]. When the selected bit in CYCCNT changes from 0 to 1 or 1 to 0, it emits into the POSTCNT, post-scalar counter. That counter then counts down. On a bit change when post-scalar is 0, it triggers an event for PC sampling or cycle count event (see details in CYCEVTENA).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT10</name>
                  <value>1</value>
                  <description>Selects bit [10] to tap</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT6</name>
                  <value>0</value>
                  <description>Selects bit [6] to tap</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>POSTCNT</name>
              <description>[8:5] Post-scalar counter for CYCTAP. When the selected tapped bit changes from 0 to 1 or 1 to 0, the post scalar counter is down-counted when not 0. If 0, it triggers an event for PCSAMPLEENA or CYCEVTENA use. It also reloads with the value from POSTPRESET.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>POSTPRESET</name>
              <description>[4:1] Reload value for post-scalar counter POSTCNT. When 0, events are triggered on each tap change (a power of 2). If this field has a non-0 value, it forms a count-down value, to be reloaded into POSTCNT each time it reaches 0. For example, a value 1 in this register means an event is formed every other tap change.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CYCCNTENA</name>
              <description>[0:0] Enable CYCCNT, allowing it to increment and generate synchronization and count events. If NOCYCCNT = 1, this bit reads zero and ignore writes.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x40000000</resetValue>
        </register>
        <register>
          <name>CYCCNT</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Current PC Sampler Cycle Count
This register is used to count the number of core cycles. This counter can measure elapsed execution time. This is a free-running counter (this counter will not advance in power modes where free-running clock to CPU stops). The counter has three functions: 

1: When CTRL.PCSAMPLEENA = 1, the PC is sampled and emitted when the selected tapped bit changes value (0 to 1 or 1 to 0) and any post-scalar value counts to 0. 
2: When CTRL.CYCEVTENA = 1 , (and CTRL.PCSAMPLEENA = 0), an event is emitted when the selected tapped bit changes value (0 to 1 or 1 to 0) and any post-scalar value counts to 0. 
3: Applications and debuggers can use the counter to measure elapsed execution time. By subtracting a start and an end time, an application can measure time between in-core clocks (other than when Halted in debug). This is valid to 2^32 core clock cycles (for example, almost 89.5 seconds at 48MHz).</description>
          <fields>
            <field>
              <name>CYCCNT</name>
              <description>[31:0] Current PC Sampler Cycle Counter count value. When enabled, this counter counts the number of core cycles, except when the core is halted. The cycle counter is a free running counter, counting upwards (this counter will not advance in power modes where free-running clock to CPU stops). It wraps around to 0 on overflow. The debugger must initialize this to 0 when first enabling.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CPICNT</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>CPI Count
This register is used to count the total number of instruction cycles beyond the first cycle.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CPICNT</name>
              <description>[7:0] Current CPI counter value. Increments on the additional cycles (the first cycle is not counted) required to execute all instructions except those recorded by LSUCNT. This counter also increments on all instruction fetch stalls. If CTRL.CPIEVTENA is set, an event is emitted when the counter overflows. This counter initializes to 0 when it is enabled using CTRL.CPIEVTENA.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EXCCNT</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Exception Overhead Count
This register is used to count the total cycles spent in interrupt processing.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXCCNT</name>
              <description>[7:0] Current interrupt overhead counter value. Counts the total cycles spent in interrupt processing (for example entry stacking, return unstacking, pre-emption). An event is emitted on counter overflow (every 256 cycles). This counter initializes to 0 when it is enabled using CTRL.EXCEVTENA.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SLEEPCNT</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Sleep Count
This register is used to count the total number of cycles during which the processor is sleeping.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SLEEPCNT</name>
              <description>[7:0] Sleep counter. Counts the number of cycles during which the processor is sleeping. An event is emitted on counter overflow (every 256 cycles). This counter initializes to 0 when it is enabled using CTRL.SLEEPEVTENA. Note that the sleep counter is clocked using CPU's free-running clock. In some power modes the free-running clock to CPU is gated to minimize power consumption. This means that the sleep counter will be invalid in these power modes.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>LSUCNT</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>LSU Count
This register is used to count the total number of cycles during which the processor is processing an LSU operation beyond the first cycle.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>LSUCNT</name>
              <description>[7:0] LSU counter. This counts the total number of cycles that the processor is processing an LSU operation. The initial execution cost of the instruction is not counted. For example, an LDR that takes two cycles to complete increments this counter one cycle. Equivalently, an LDR that stalls for two cycles (i.e. takes four cycles to execute), increments this counter three times. An event is emitted on counter overflow (every 256 cycles). This counter initializes to 0 when it is enabled using CTRL.LSUEVTENA.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FOLDCNT</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Fold Count
This register is used to count the total number of folded instructions. The counter increments on each instruction which takes 0 cycles.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FOLDCNT</name>
              <description>[7:0] This counts the total number folded instructions. This counter initializes to 0 when it is enabled using CTRL.FOLDEVTENA.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PCSR</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Program Counter Sample
This register is used to enable coarse-grained software profiling using a debug agent, without changing the currently executing code. If the core is not in debug state, the value returned is the instruction address of a recently executed instruction. If the core is in debug state, the value returned is 0xFFFFFFFF.</description>
          <fields>
            <field>
              <name>EIASAMPLE</name>
              <description>[31:0] Execution instruction address sample, or 0xFFFFFFFF if the core is halted.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>COMP0</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Comparator 0
This register is used to write the reference value for comparator 0.</description>
          <fields>
            <field>
              <name>COMP</name>
              <description>[31:0] Reference value to compare against PC or the data address as given by FUNCTION0. Comparator 0 can also compare against the value of the PC Sampler Counter (CYCCNT).</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MASK0</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Mask 0
Use the DWT Mask Registers 0 to apply a mask to data addresses when matching against COMP0.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MASK</name>
              <description>[3:0] Mask on data address when matching against COMP0. This is the size of the ignore mask. That is, DWT matching is performed as:(ADDR ANDed with (0xFFFF left bit-shifted by MASK)) == COMP0. However, the actual comparison is slightly more complex to enable matching an address wherever it appears on a bus. So, if COMP0 is 3, this matches a word access of 0, because 3 would be within the word.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FUNCTION0</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Function 0
Use the DWT Function Registers 0 to control the operation of the comparator 0. This comparator can:
1. Match against either the PC or the data address. This is controlled by CYCMATCH. This function is only available for comparator 0 (COMP0). 
2. Emit data or PC couples, trigger the ETM, or generate a watchpoint depending on the operation defined by FUNCTION.</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>MATCHED</name>
              <description>[24:24] This bit is set when the comparator matches, and indicates that the operation defined by FUNCTION has occurred since this bit was last read. This bit is cleared on read.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED8</name>
              <description>[23:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CYCMATCH</name>
              <description>[7:7] This bit is only available in comparator 0. When set, COMP0 will compare against the cycle counter (CYCCNT).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[6:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>EMITRANGE</name>
              <description>[5:5] Emit range field. This bit permits emitting offset when range match occurs. PC sampling is not supported when emit range is enabled. 
This field only applies for: FUNCTION = 1, 2, 3, 12, 13, 14, and 15.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[4:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>FUNCTION</name>
              <description>[3:0] Function settings. 

0x0: Disabled
0x1: EMITRANGE = 0, sample and emit PC through ITM. EMITRANGE = 1, emit address offset through ITM
0x2: EMITRANGE = 0, emit data through ITM on read and write. EMITRANGE = 1, emit data and address offset through ITM on read or write.
0x3: EMITRANGE = 0, sample PC and data value through ITM on read or write. EMITRANGE = 1, emit address offset and data value through ITM on read or write.
0x4: Watchpoint on PC match.
0x5: Watchpoint on read.
0x6: Watchpoint on write.
0x7: Watchpoint on read or write.
0x8: ETM trigger on PC match
0x9: ETM trigger on read
0xA: ETM trigger on write
0xB: ETM trigger on read or write
0xC: EMITRANGE = 0, sample data for read transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) for read transfers
0xD: EMITRANGE = 0, sample data for write transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) for write transfers
0xE: EMITRANGE = 0, sample PC + data for read transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) + data for read transfers
0xF: EMITRANGE = 0, sample PC + data for write transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) + data for write transfers

Note 1: If the ETM is not fitted, then ETM trigger is not possible. 
Note 2: Data value is only sampled for accesses that do not fault (MPU or bus fault). The PC is sampled irrespective of any faults. The PC is only sampled for the first address of a burst. 
Note 3: PC match is not recommended for watchpoints because it stops after the instruction. It mainly guards and triggers the ETM.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>COMP1</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Comparator 1
This register is used to write the reference value for comparator 1.</description>
          <fields>
            <field>
              <name>COMP</name>
              <description>[31:0] Reference value to compare against PC or the data address as given by  FUNCTION1. 
Comparator 1 can also compare data values. So this register can contain reference values for data matching.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MASK1</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Mask 1
Use the DWT Mask Registers 1 to apply a mask to data addresses when matching against COMP1.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MASK</name>
              <description>[3:0] Mask on data address when matching against COMP1. This is the size of the ignore mask. That is, DWT matching is performed as:(ADDR ANDed with (0xFFFF left bit-shifted by MASK)) == COMP1. However, the actual comparison is slightly more complex to enable matching an address wherever it appears on a bus. So, if COMP1 is 3, this matches a word access of 0, because 3 would be within the word.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FUNCTION1</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Function 1
Use the DWT Function Registers 1 to control the operation of the comparator 1. This comparator can:
1. Perform data value comparisons if associated address comparators have performed an address match. This function is only available for comparator 1 (COMP1). 
2. Emit data or PC couples, trigger the ETM, or generate a watchpoint depending on the operation defined by FUNCTION.</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>MATCHED</name>
              <description>[24:24] This bit is set when the comparator matches, and indicates that the operation defined by FUNCTION has occurred since this bit was last read. This bit is cleared on read.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED20</name>
              <description>[23:20] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>DATAVADDR1</name>
              <description>[19:16] Identity of a second linked address comparator for data value matching when DATAVMATCH == 1 and LNK1ENA == 1.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DATAVADDR0</name>
              <description>[15:12] Identity of a linked address comparator for data value matching when DATAVMATCH == 1.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DATAVSIZE</name>
              <description>[11:10] Defines the size of the data in the COMP1 register that is to be matched:

0x0: Byte
0x1: Halfword
0x2: Word
0x3: Unpredictable.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>LNK1ENA</name>
              <description>[9:9] Read only bit-field only supported in comparator 1.

0: DATAVADDR1 not supported
1: DATAVADDR1 supported (enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DATAVMATCH</name>
              <description>[8:8] Data match feature:

0: Perform address comparison
1: Perform data value compare. The comparators given by DATAVADDR0 and DATAVADDR1 provide the address for the data comparison. The FUNCTION setting for the comparators given by DATAVADDR0 and DATAVADDR1 are overridden and those comparators only provide the address match for the data comparison.

This bit is only available in comparator 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>EMITRANGE</name>
              <description>[5:5] Emit range field. This bit permits emitting offset when range match occurs. PC sampling is not supported when emit range is enabled. 
This field only applies for: FUNCTION = 1, 2, 3, 12, 13, 14, and 15.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[4:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>FUNCTION</name>
              <description>[3:0] Function settings:

0x0: Disabled
0x1: EMITRANGE = 0, sample and emit PC through ITM. EMITRANGE = 1, emit address offset through ITM
0x2: EMITRANGE = 0, emit data through ITM on read and write. EMITRANGE = 1, emit data and address offset through ITM on read or write.
0x3: EMITRANGE = 0, sample PC and data value through ITM on read or write. EMITRANGE = 1, emit address offset and data value through ITM on read or write.
0x4: Watchpoint on PC match.
0x5: Watchpoint on read.
0x6: Watchpoint on write.
0x7: Watchpoint on read or write.
0x8: ETM trigger on PC match
0x9: ETM trigger on read
0xA: ETM trigger on write
0xB: ETM trigger on read or write
0xC: EMITRANGE = 0, sample data for read transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) for read transfers
0xD: EMITRANGE = 0, sample data for write transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) for write transfers
0xE: EMITRANGE = 0, sample PC + data for read transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) + data for read transfers
0xF: EMITRANGE = 0, sample PC + data for write transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) + data for write transfers

Note 1: If the ETM is not fitted, then ETM trigger is not possible. 
Note 2: Data value is only sampled for accesses that do not fault (MPU or bus fault). The PC is sampled irrespective of any faults. The PC is only sampled for the first address of a burst. 
Note 3: FUNCTION is overridden for comparators given by DATAVADDR0 and DATAVADDR1 if DATAVMATCH is also set. The comparators given by DATAVADDR0 and DATAVADDR1 can then only perform address comparator matches for comparator 1 data matches. 
Note 4: If the data matching functionality is not included during implementation it is not possible to set DATAVADDR0, DATAVADDR1, or DATAVMATCH. This means that the data matching functionality is not available in the implementation. Test the availability of data matching by writing and reading DATAVMATCH. If it is not settable then data matching is unavailable. 
Note 5: PC match is not recommended for watchpoints because it stops after the instruction. It mainly guards and triggers the ETM.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x200</resetValue>
        </register>
        <register>
          <name>COMP2</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Comparator 2
This register is used to write the reference value for comparator 2.</description>
          <fields>
            <field>
              <name>COMP</name>
              <description>[31:0] Reference value to compare against PC or the data address as given by FUNCTION2.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MASK2</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Mask 2
Use the DWT Mask Registers 2 to apply a mask to data addresses when matching against COMP2.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MASK</name>
              <description>[3:0] Mask on data address when matching against COMP2. This is the size of the ignore mask. That is, DWT matching is performed as:(ADDR ANDed with (0xFFFF left bit-shifted by MASK)) == COMP2. However, the actual comparison is slightly more complex to enable matching an address wherever it appears on a bus. So, if COMP2 is 3, this matches a word access of 0, because 3 would be within the word.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FUNCTION2</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Function 2
Use the DWT Function Registers 2 to control the operation of the comparator 2. This comparator can emit data or PC couples, trigger the ETM, or generate a watchpoint depending on the operation defined by FUNCTION.</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>MATCHED</name>
              <description>[24:24] This bit is set when the comparator matches, and indicates that the operation defined by FUNCTION has occurred since this bit was last read. This bit is cleared on read.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[23:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>EMITRANGE</name>
              <description>[5:5] Emit range field. This bit permits emitting offset when range match occurs. PC sampling is not supported when emit range is enabled. 
This field only applies for: FUNCTION = 1, 2, 3, 12, 13, 14, and 15.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[4:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>FUNCTION</name>
              <description>[3:0] Function settings. 

0x0: Disabled
0x1: EMITRANGE = 0, sample and emit PC through ITM. EMITRANGE = 1, emit address offset through ITM
0x2: EMITRANGE = 0, emit data through ITM on read and write. EMITRANGE = 1, emit data and address offset through ITM on read or write.
0x3: EMITRANGE = 0, sample PC and data value through ITM on read or write. EMITRANGE = 1, emit address offset and data value through ITM on read or write.
0x4: Watchpoint on PC match.
0x5: Watchpoint on read.
0x6: Watchpoint on write.
0x7: Watchpoint on read or write.
0x8: ETM trigger on PC match
0x9: ETM trigger on read
0xA: ETM trigger on write
0xB: ETM trigger on read or write
0xC: EMITRANGE = 0, sample data for read transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) for read transfers
0xD: EMITRANGE = 0, sample data for write transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) for write transfers
0xE: EMITRANGE = 0, sample PC + data for read transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) + data for read transfers
0xF: EMITRANGE = 0, sample PC + data for write transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) + data for write transfers

Note 1: If the ETM is not fitted, then ETM trigger is not possible. 
Note 2: Data value is only sampled for accesses that do not fault (MPU or bus fault). The PC is sampled irrespective of any faults. The PC is only sampled for the first address of a burst. 
Note 3: PC match is not recommended for watchpoints because it stops after the instruction. It mainly guards and triggers the ETM.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>COMP3</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>Comparator 3
This register is used to write the reference value for comparator 3.</description>
          <fields>
            <field>
              <name>COMP</name>
              <description>[31:0] Reference value to compare against PC or the data address as given by FUNCTION3.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MASK3</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Mask 3
Use the DWT Mask Registers 3 to apply a mask to data addresses when matching against COMP3.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MASK</name>
              <description>[3:0] Mask on data address when matching against COMP3. This is the size of the ignore mask. That is, DWT matching is performed as:(ADDR ANDed with (0xFFFF left bit-shifted by MASK)) == COMP3. However, the actual comparison is slightly more complex to enable matching an address wherever it appears on a bus. So, if COMP3 is 3, this matches a word access of 0, because 3 would be within the word.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FUNCTION3</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>Function 3
Use the DWT Function Registers 3 to control the operation of the comparator 3. This comparator can emit data or PC couples, trigger the ETM, or generate a watchpoint depending on the operation defined by FUNCTION.</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>MATCHED</name>
              <description>[24:24] This bit is set when the comparator matches, and indicates that the operation defined by FUNCTION has occurred since this bit was last read. This bit is cleared on read.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[23:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>EMITRANGE</name>
              <description>[5:5] Emit range field. This bit permits emitting offset when range match occurs. PC sampling is not supported when emit range is enabled. 
This field only applies for: FUNCTION = 1, 2, 3, 12, 13, 14, and 15.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[4:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>FUNCTION</name>
              <description>[3:0] Function settings. 

0x0: Disabled
0x1: EMITRANGE = 0, sample and emit PC through ITM. EMITRANGE = 1, emit address offset through ITM
0x2: EMITRANGE = 0, emit data through ITM on read and write. EMITRANGE = 1, emit data and address offset through ITM on read or write.
0x3: EMITRANGE = 0, sample PC and data value through ITM on read or write. EMITRANGE = 1, emit address offset and data value through ITM on read or write.
0x4: Watchpoint on PC match.
0x5: Watchpoint on read.
0x6: Watchpoint on write.
0x7: Watchpoint on read or write.
0x8: ETM trigger on PC match
0x9: ETM trigger on read
0xA: ETM trigger on write
0xB: ETM trigger on read or write
0xC: EMITRANGE = 0, sample data for read transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) for read transfers
0xD: EMITRANGE = 0, sample data for write transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) for write transfers
0xE: EMITRANGE = 0, sample PC + data for read transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) + data for read transfers
0xF: EMITRANGE = 0, sample PC + data for write transfers. EMITRANGE = 1, sample Daddr (lower 16 bits) + data for write transfers

Note 1: If the ETM is not fitted, then ETM trigger is not possible. 
Note 2: Data value is only sampled for accesses that do not fault (MPU or bus fault). The PC is sampled irrespective of any faults. The PC is only sampled for the first address of a burst. 
Note 3: PC match is not recommended for watchpoints because it stops after the instruction. It mainly guards and triggers the ETM.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPU_FPB</name>
      <baseAddress>0xE0002000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Cortex-M's Flash Patch and Breakpoint (FPB)</description>
      <registers>
        <register>
          <name>CTRL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Control
This register is used to enable the flash patch block.</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>NUM_CODE2</name>
              <description>[13:12] Number of full banks of code comparators, sixteen comparators per bank. Where less than sixteen code comparators are provided, the bank count is zero, and the number present indicated by NUM_CODE1. This read only field contains 3'b000 to indicate 0 banks for Cortex-M processor.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>NUM_LIT</name>
              <description>[11:8] Number of literal slots field.

0x0: No literal slots
0x2: Two literal slots</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>NUM_CODE1</name>
              <description>[7:4] Number of code slots field.

0x0: No code slots
0x2: Two code slots
0x6: Six code slots</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[3:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>KEY</name>
              <description>[1:1] Key field. In order to write to this register, this bit-field must be written to '1'. This bit always reads 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ENABLE</name>
              <description>[0:0] Flash patch unit enable bit

0x0: Flash patch unit disabled
0x1: Flash patch unit enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x260</resetValue>
        </register>
        <register>
          <name>REMAP</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Remap
This register provides the remap base address location where a matched addresses are remapped. The three most significant bits and the five least significant bits of the remap base address are hard-coded to 3'b001 and 5'b00000 respectively. The remap base address must be in system space and is it required to be 8-word aligned, with one word allocated to each of the eight FPB comparators.</description>
          <fields>
            <field>
              <name>RESERVED29</name>
              <description>[31:29] This field always reads 3'b001. Writing to this field is ignored.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>REMAP</name>
              <description>[28:5] Remap base address field.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[4:0] This field always reads 0. Writing to this field is ignored.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x20000000</resetValue>
        </register>
        <register>
          <name>COMP0</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Comparator 0</description>
          <fields>
            <field>
              <name>REPLACE</name>
              <description>[31:30] This selects what happens when the COMP address is matched. Address remapping only takes place for the 0x0 setting.

0x0: Remap to remap address. See REMAP.REMAP
0x1: Set BKPT on lower halfword, upper is unaffected
0x2: Set BKPT on upper halfword, lower is unaffected
0x3: Set BKPT on both lower and upper halfwords.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RESERVED29</name>
              <description>[29:29] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>COMP</name>
              <description>[28:2] Comparison address.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[1:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ENABLE</name>
              <description>[0:0] Compare and remap enable comparator 0. CTRL.ENABLE must also be set to enable comparisons.

0x0: Compare and remap for comparator 0 disabled
0x1: Compare and remap for comparator 0 enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>COMP1</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Comparator 1</description>
          <fields>
            <field>
              <name>REPLACE</name>
              <description>[31:30] This selects what happens when the COMP address is matched. Address remapping only takes place for the 0x0 setting.

0x0: Remap to remap address. See REMAP.REMAP
0x1: Set BKPT on lower halfword, upper is unaffected
0x2: Set BKPT on upper halfword, lower is unaffected
0x3: Set BKPT on both lower and upper halfwords.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RESERVED29</name>
              <description>[29:29] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>COMP</name>
              <description>[28:2] Comparison address.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[1:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ENABLE</name>
              <description>[0:0] Compare and remap enable comparator 1. CTRL.ENABLE must also be set to enable comparisons.

0x0: Compare and remap for comparator 1 disabled
0x1: Compare and remap for comparator 1 enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>COMP2</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Comparator 2</description>
          <fields>
            <field>
              <name>REPLACE</name>
              <description>[31:30] This selects what happens when the COMP address is matched. Address remapping only takes place for the 0x0 setting.

0x0: Remap to remap address. See REMAP.REMAP
0x1: Set BKPT on lower halfword, upper is unaffected
0x2: Set BKPT on upper halfword, lower is unaffected
0x3: Set BKPT on both lower and upper halfwords.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RESERVED29</name>
              <description>[29:29] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>COMP</name>
              <description>[28:2] Comparison address.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[1:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ENABLE</name>
              <description>[0:0] Compare and remap enable comparator 2. CTRL.ENABLE must also be set to enable comparisons.

0x0: Compare and remap for comparator 2 disabled
0x1: Compare and remap for comparator 2 enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>COMP3</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Comparator 3</description>
          <fields>
            <field>
              <name>REPLACE</name>
              <description>[31:30] This selects what happens when the COMP address is matched. Address remapping only takes place for the 0x0 setting.

0x0: Remap to remap address. See REMAP.REMAP
0x1: Set BKPT on lower halfword, upper is unaffected
0x2: Set BKPT on upper halfword, lower is unaffected
0x3: Set BKPT on both lower and upper halfwords.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RESERVED29</name>
              <description>[29:29] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>COMP</name>
              <description>[28:2] Comparison address.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[1:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ENABLE</name>
              <description>[0:0] Compare and remap enable comparator 3. CTRL.ENABLE must also be set to enable comparisons.

0x0: Compare and remap for comparator 3 disabled
0x1: Compare and remap for comparator 3 enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>COMP4</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Comparator 4</description>
          <fields>
            <field>
              <name>REPLACE</name>
              <description>[31:30] This selects what happens when the COMP address is matched. Address remapping only takes place for the 0x0 setting.

0x0: Remap to remap address. See REMAP.REMAP
0x1: Set BKPT on lower halfword, upper is unaffected
0x2: Set BKPT on upper halfword, lower is unaffected
0x3: Set BKPT on both lower and upper halfwords.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RESERVED29</name>
              <description>[29:29] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>COMP</name>
              <description>[28:2] Comparison address.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[1:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ENABLE</name>
              <description>[0:0] Compare and remap enable comparator 4. CTRL.ENABLE must also be set to enable comparisons.

0x0: Compare and remap for comparator 4 disabled
0x1: Compare and remap for comparator 4 enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>COMP5</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Comparator 5</description>
          <fields>
            <field>
              <name>REPLACE</name>
              <description>[31:30] This selects what happens when the COMP address is matched. Address remapping only takes place for the 0x0 setting.

0x0: Remap to remap address. See REMAP.REMAP
0x1: Set BKPT on lower halfword, upper is unaffected
0x2: Set BKPT on upper halfword, lower is unaffected
0x3: Set BKPT on both lower and upper halfwords.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RESERVED29</name>
              <description>[29:29] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>COMP</name>
              <description>[28:2] Comparison address.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[1:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ENABLE</name>
              <description>[0:0] Compare and remap enable comparator 5. CTRL.ENABLE must also be set to enable comparisons.

0x0: Compare and remap for comparator 5 disabled
0x1: Compare and remap for comparator 5 enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>COMP6</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Comparator 6</description>
          <fields>
            <field>
              <name>REPLACE</name>
              <description>[31:30] This selects what happens when the COMP address is matched. Comparator 6 is a literal comparator and the only supported setting is 0x0. Other settings will be ignored.

0x0: Remap to remap address. See REMAP.REMAP
0x1: Set BKPT on lower halfword, upper is unaffected
0x2: Set BKPT on upper halfword, lower is unaffected
0x3: Set BKPT on both lower and upper halfwords.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RESERVED29</name>
              <description>[29:29] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>COMP</name>
              <description>[28:2] Comparison address.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[1:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ENABLE</name>
              <description>[0:0] Compare and remap enable comparator 6. CTRL.ENABLE must also be set to enable comparisons.

0x0: Compare and remap for comparator 6 disabled
0x1: Compare and remap for comparator 6 enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>COMP7</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Comparator 7</description>
          <fields>
            <field>
              <name>REPLACE</name>
              <description>[31:30] This selects what happens when the COMP address is matched. Comparator 7 is a literal comparator and the only supported setting is 0x0. Other settings will be ignored.

0x0: Remap to remap address. See REMAP.REMAP
0x1: Set BKPT on lower halfword, upper is unaffected
0x2: Set BKPT on upper halfword, lower is unaffected
0x3: Set BKPT on both lower and upper halfwords.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RESERVED29</name>
              <description>[29:29] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>COMP</name>
              <description>[28:2] Comparison address.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[1:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ENABLE</name>
              <description>[0:0] Compare and remap enable comparator 7. CTRL.ENABLE must also be set to enable comparisons.

0x0: Compare and remap for comparator 7 disabled
0x1: Compare and remap for comparator 7 enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPU_ITM</name>
      <baseAddress>0xE0000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Cortex-M's Instrumentation Trace Macrocell (ITM)</description>
      <registers>
        <register>
          <name>STIM0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Stimulus Port 0</description>
          <fields>
            <field>
              <name>STIM0</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA0 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Stimulus Port 1</description>
          <fields>
            <field>
              <name>STIM1</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA1 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM2</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Stimulus Port 2</description>
          <fields>
            <field>
              <name>STIM2</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA2 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM3</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Stimulus Port 3</description>
          <fields>
            <field>
              <name>STIM3</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA3 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM4</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Stimulus Port 4</description>
          <fields>
            <field>
              <name>STIM4</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA4 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM5</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Stimulus Port 5</description>
          <fields>
            <field>
              <name>STIM5</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA5 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM6</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Stimulus Port 6</description>
          <fields>
            <field>
              <name>STIM6</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA6 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM7</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Stimulus Port 7</description>
          <fields>
            <field>
              <name>STIM7</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA7 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM8</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Stimulus Port 8</description>
          <fields>
            <field>
              <name>STIM8</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA8 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM9</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Stimulus Port 9</description>
          <fields>
            <field>
              <name>STIM9</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA9 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM10</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Stimulus Port 10</description>
          <fields>
            <field>
              <name>STIM10</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA10 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM11</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Stimulus Port 11</description>
          <fields>
            <field>
              <name>STIM11</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA11 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM12</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Stimulus Port 12</description>
          <fields>
            <field>
              <name>STIM12</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA12 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM13</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Stimulus Port 13</description>
          <fields>
            <field>
              <name>STIM13</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA13 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM14</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Stimulus Port 14</description>
          <fields>
            <field>
              <name>STIM14</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA14 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM15</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Stimulus Port 15</description>
          <fields>
            <field>
              <name>STIM15</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA15 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM16</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Stimulus Port 16</description>
          <fields>
            <field>
              <name>STIM16</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA16 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM17</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Stimulus Port 17</description>
          <fields>
            <field>
              <name>STIM17</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA17 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM18</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Stimulus Port 18</description>
          <fields>
            <field>
              <name>STIM18</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA18 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM19</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Stimulus Port 19</description>
          <fields>
            <field>
              <name>STIM19</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA19 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM20</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>Stimulus Port 20</description>
          <fields>
            <field>
              <name>STIM20</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA20 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM21</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Stimulus Port 21</description>
          <fields>
            <field>
              <name>STIM21</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA21 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM22</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>Stimulus Port 22</description>
          <fields>
            <field>
              <name>STIM22</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA22 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM23</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Stimulus Port 23</description>
          <fields>
            <field>
              <name>STIM23</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA23 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM24</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>Stimulus Port 24</description>
          <fields>
            <field>
              <name>STIM24</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA24 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM25</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>Stimulus Port 25</description>
          <fields>
            <field>
              <name>STIM25</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA25 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM26</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>Stimulus Port 26</description>
          <fields>
            <field>
              <name>STIM26</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA26 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM27</name>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <description>Stimulus Port 27</description>
          <fields>
            <field>
              <name>STIM27</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA27 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM28</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>Stimulus Port 28</description>
          <fields>
            <field>
              <name>STIM28</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA28 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM29</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>Stimulus Port 29</description>
          <fields>
            <field>
              <name>STIM29</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA29 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM30</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>Stimulus Port 30</description>
          <fields>
            <field>
              <name>STIM30</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA30 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIM31</name>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <description>Stimulus Port 31</description>
          <fields>
            <field>
              <name>STIM31</name>
              <description>[31:0] A write to this location causes data to be written into the FIFO if TER.STIMENA31 is set. Reading from the stimulus port returns the FIFO status in bit [0]: 0 = full, 1 = not full. The polled FIFO interface does not provide an atomic read-modify-write, so it's users responsibility to ensure exclusive read-modify-write if this ITM port is used concurrently by interrupts or other threads.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TER</name>
          <addressOffset>0xe00</addressOffset>
          <size>32</size>
          <description>Trace Enable
Use the Trace Enable Register to generate trace data by writing to the corresponding stimulus port. Note: Privileged writes are accepted to this register if TCR.ITMENA is set. User writes are accepted to this register if TCR.ITMENA is set and the appropriate privilege mask is cleared. Privileged access to the stimulus ports enables an RTOS kernel to guarantee instrumentation slots or bandwidth as required.</description>
          <fields>
            <field>
              <name>STIMENA31</name>
              <description>[31:31] Bit mask to enable tracing on ITM stimulus port 31.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>STIMENA30</name>
              <description>[30:30] Bit mask to enable tracing on ITM stimulus port 30.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>STIMENA29</name>
              <description>[29:29] Bit mask to enable tracing on ITM stimulus port 29.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>STIMENA28</name>
              <description>[28:28] Bit mask to enable tracing on ITM stimulus port 28.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>STIMENA27</name>
              <description>[27:27] Bit mask to enable tracing on ITM stimulus port 27.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>STIMENA26</name>
              <description>[26:26] Bit mask to enable tracing on ITM stimulus port 26.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>STIMENA25</name>
              <description>[25:25] Bit mask to enable tracing on ITM stimulus port 25.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>STIMENA24</name>
              <description>[24:24] Bit mask to enable tracing on ITM stimulus port 24.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>STIMENA23</name>
              <description>[23:23] Bit mask to enable tracing on ITM stimulus port 23.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>STIMENA22</name>
              <description>[22:22] Bit mask to enable tracing on ITM stimulus port 22.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>STIMENA21</name>
              <description>[21:21] Bit mask to enable tracing on ITM stimulus port 21.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>STIMENA20</name>
              <description>[20:20] Bit mask to enable tracing on ITM stimulus port 20.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>STIMENA19</name>
              <description>[19:19] Bit mask to enable tracing on ITM stimulus port 19.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>STIMENA18</name>
              <description>[18:18] Bit mask to enable tracing on ITM stimulus port 18.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>STIMENA17</name>
              <description>[17:17] Bit mask to enable tracing on ITM stimulus port 17.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>STIMENA16</name>
              <description>[16:16] Bit mask to enable tracing on ITM stimulus port 16.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>STIMENA15</name>
              <description>[15:15] Bit mask to enable tracing on ITM stimulus port 15.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>STIMENA14</name>
              <description>[14:14] Bit mask to enable tracing on ITM stimulus port 14.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>STIMENA13</name>
              <description>[13:13] Bit mask to enable tracing on ITM stimulus port 13.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>STIMENA12</name>
              <description>[12:12] Bit mask to enable tracing on ITM stimulus port 12.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>STIMENA11</name>
              <description>[11:11] Bit mask to enable tracing on ITM stimulus port 11.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>STIMENA10</name>
              <description>[10:10] Bit mask to enable tracing on ITM stimulus port 10.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>STIMENA9</name>
              <description>[9:9] Bit mask to enable tracing on ITM stimulus port 9.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>STIMENA8</name>
              <description>[8:8] Bit mask to enable tracing on ITM stimulus port 8.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>STIMENA7</name>
              <description>[7:7] Bit mask to enable tracing on ITM stimulus port 7.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>STIMENA6</name>
              <description>[6:6] Bit mask to enable tracing on ITM stimulus port 6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>STIMENA5</name>
              <description>[5:5] Bit mask to enable tracing on ITM stimulus port 5.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>STIMENA4</name>
              <description>[4:4] Bit mask to enable tracing on ITM stimulus port 4.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>STIMENA3</name>
              <description>[3:3] Bit mask to enable tracing on ITM stimulus port 3.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>STIMENA2</name>
              <description>[2:2] Bit mask to enable tracing on ITM stimulus port 2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>STIMENA1</name>
              <description>[1:1] Bit mask to enable tracing on ITM stimulus port 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STIMENA0</name>
              <description>[0:0] Bit mask to enable tracing on ITM stimulus port 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TPR</name>
          <addressOffset>0xe40</addressOffset>
          <size>32</size>
          <description>Trace Privilege
This register is used to enable an operating system to control which stimulus ports are accessible by user code. This register can only be used in privileged mode.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>PRIVMASK</name>
              <description>[3:0] Bit mask to enable unprivileged (User) access to ITM stimulus ports:

Bit [0] enables stimulus ports 0, 1, ..., and 7.
Bit [1] enables stimulus ports 8, 9, ..., and 15.
Bit [2] enables stimulus ports 16, 17, ..., and 23.
Bit [3] enables stimulus ports 24, 25, ..., and 31.

0: User access allowed to stimulus ports
1: Privileged access only to stimulus ports</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TCR</name>
          <addressOffset>0xe80</addressOffset>
          <size>32</size>
          <description>Trace Control
Use this register to configure and control ITM transfers. This register can only be written in privilege mode. DWT is not enabled in the ITM block. However, DWT stimulus entry into the FIFO is controlled by DWTENA. If DWT requires timestamping, the TSENA bit must be set.</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>BUSY</name>
              <description>[23:23] Set when ITM events present and being drained.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>ATBID</name>
              <description>[22:16] Trace Bus ID for CoreSight system. Optional identifier for multi-source trace stream formatting. If multi-source trace is in use, this field must be written with a non-zero value.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED10</name>
              <description>[15:10] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TSPRESCALE</name>
              <description>[9:8] Timestamp prescaler</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIV64</name>
                  <value>3</value>
                  <description>Divide by 64</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV16</name>
                  <value>2</value>
                  <description>Divide by 16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV4</name>
                  <value>1</value>
                  <description>Divide by 4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOPRESCALING</name>
                  <value>0</value>
                  <description>No prescaling</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[7:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>SWOENA</name>
              <description>[4:4] Enables asynchronous clocking of the timestamp counter (when TSENA = 1). If TSENA = 0, writing this bit to 1 does not enable asynchronous clocking of the timestamp counter.

0x0: Mode disabled. Timestamp counter uses system clock from the core and counts continuously.
0x1: Timestamp counter uses lineout (data related) clock from TPIU interface. The timestamp counter is held in reset while the output line is idle.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DWTENA</name>
              <description>[3:3] Enables the DWT stimulus (hardware event packet emission to the TPIU from the DWT)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SYNCENA</name>
              <description>[2:2] Enables synchronization packet transmission for a synchronous TPIU.
CPU_DWT:CTRL.SYNCTAP must be configured for the correct synchronization speed.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TSENA</name>
              <description>[1:1] Enables differential timestamps. Differential timestamps are emitted when a packet is written to the FIFO with a non-zero timestamp counter, and when the timestamp counter overflows. Timestamps are emitted during idle times after a fixed number of two million cycles. This provides a time reference for packets and inter-packet gaps. If SWOENA (bit [4]) is set, timestamps are triggered by activity on the internal trace bus only. In this case there is no regular timestamp output when the ITM is idle.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ITMENA</name>
              <description>[0:0] Enables ITM. This is the master enable, and must be set before ITM Stimulus and Trace Enable registers can be written.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>LAR</name>
          <addressOffset>0xfb0</addressOffset>
          <size>32</size>
          <description>Lock Access 
This register is used to prevent write accesses to the Control Registers: TER, TPR and TCR.</description>
          <fields>
            <field>
              <name>LOCK_ACCESS</name>
              <description>[31:0] A privileged write of 0xC5ACCE55 enables more write access to Control Registers TER, TPR and TCR. An invalid write removes write access.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>LSR</name>
          <addressOffset>0xfb4</addressOffset>
          <size>32</size>
          <description>Lock Status
Use this register to enable write accesses to the Control Register.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>BYTEACC</name>
              <description>[2:2] Reads 0 which means 8-bit lock access is not be implemented.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ACCESS</name>
              <description>[1:1] Write access to component is blocked. All writes are ignored, reads are permitted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PRESENT</name>
              <description>[0:0] Indicates that a lock mechanism exists for this component.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPU_SCS</name>
      <baseAddress>0xE000E000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Cortex-M's System Control Space (SCS)</description>
      <registers>
        <register>
          <name>RESERVED000</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ICTR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Interrupt Control Type
Read this register to see the number of interrupt lines that the NVIC supports.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>INTLINESNUM</name>
              <description>[2:0] Total number of interrupt lines in groups of 32.

0: 0...32
1: 33...64
2: 65...96
3: 97...128
4: 129...160
5: 161...192
6: 193...224
7: 225...256</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>ACTLR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Auxiliary Control
This register is used to disable certain aspects of functionality within the processor</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DISFOLD</name>
              <description>[2:2] Disables folding of IT instruction.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DISDEFWBUF</name>
              <description>[1:1] Disables write buffer use during default memory map accesses. This causes all bus faults to be precise bus faults but decreases the performance of the processor because the stores to memory have to complete before the next instruction can be executed.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DISMCYCINT</name>
              <description>[0:0] Disables interruption of multi-cycle instructions. This increases the interrupt latency of the processor becuase LDM/STM completes before interrupt stacking occurs.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STCSR</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>SysTick Control and Status
This register enables the SysTick features and returns status flags related to SysTick.</description>
          <fields>
            <field>
              <name>RESERVED17</name>
              <description>[31:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>COUNTFLAG</name>
              <description>[16:16] Returns 1 if timer counted to 0 since last time this was read. Clears on read by application of any part of the SysTick Control and Status Register. If read by the debugger using the DAP, this bit is cleared on read-only if the MasterType bit in the **AHB-AP** Control Register is set to 0. Otherwise, COUNTFLAG is not changed by the debugger read.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[15:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>13</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CLKSOURCE</name>
              <description>[2:2] Clock source:

0: External reference clock.
1: Core clock

External clock is not available in this device. Writes to this field will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TICKINT</name>
              <description>[1:1] 0: Counting down to zero does not pend the SysTick handler. Software can use COUNTFLAG to determine if the SysTick handler has ever counted to zero.
1: Counting down to zero pends the SysTick handler.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ENABLE</name>
              <description>[0:0] Enable SysTick counter

0: Counter disabled
1: Counter operates in a multi-shot way. That is, counter loads with the Reload value STRVR.RELOAD and then begins counting down. On reaching 0, it sets COUNTFLAG to 1 and optionally pends the SysTick handler, based on TICKINT. It then loads STRVR.RELOAD again, and begins counting.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x4</resetValue>
        </register>
        <register>
          <name>STRVR</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>SysTick Reload Value
This register is used to specify the start value to load into the current value register STCVR.CURRENT when the counter reaches 0. It can be any value between 1 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and STCSR.COUNTFLAG are activated when counting from 1 to 0.</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RELOAD</name>
              <description>[23:0] Value to load into the SysTick Current Value Register STCVR.CURRENT when the counter reaches 0.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STCVR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>SysTick Current Value
Read from this register returns the current value of SysTick counter. Writing to this register resets the SysTick counter (as well as  STCSR.COUNTFLAG).</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CURRENT</name>
              <description>[23:0] Current value at the time the register is accessed. No read-modify-write protection is provided, so change with care. Writing to it with any value clears the register to 0. Clearing this register also clears STCSR.COUNTFLAG.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STCR</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>SysTick Calibration Value
Used to enable software to scale to any required speed using divide and multiply.</description>
          <fields>
            <field>
              <name>NOREF</name>
              <description>[31:31] Reads as one. Indicates that no separate reference clock is provided.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>SKEW</name>
              <description>[30:30] Reads as one. The calibration value is not exactly 10ms because of clock frequency. This could affect its suitability as a software real time clock.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RESERVED24</name>
              <description>[29:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>TENMS</name>
              <description>[23:0] An optional Reload value to be used for 10ms (100Hz) timing, subject to system clock skew errors. The value read is valid only when core clock is at 48MHz.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xC0075300</resetValue>
        </register>
        <register>
          <name>NVIC_ISER0</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>Irq 0 to 31 Set Enable
This register is used to enable interrupts and determine which interrupts are currently enabled.</description>
          <fields>
            <field>
              <name>SETENA31</name>
              <description>[31:31] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 31 (See EVENT:CPUIRQSEL31.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>SETENA30</name>
              <description>[30:30] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 30 (See EVENT:CPUIRQSEL30.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>SETENA29</name>
              <description>[29:29] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 29 (See EVENT:CPUIRQSEL29.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>SETENA28</name>
              <description>[28:28] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 28 (See EVENT:CPUIRQSEL28.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>SETENA27</name>
              <description>[27:27] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 27 (See EVENT:CPUIRQSEL27.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>SETENA26</name>
              <description>[26:26] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 26 (See EVENT:CPUIRQSEL26.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>SETENA25</name>
              <description>[25:25] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 25 (See EVENT:CPUIRQSEL25.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>SETENA24</name>
              <description>[24:24] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 24 (See EVENT:CPUIRQSEL24.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>SETENA23</name>
              <description>[23:23] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 23 (See EVENT:CPUIRQSEL23.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>SETENA22</name>
              <description>[22:22] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 22 (See EVENT:CPUIRQSEL22.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>SETENA21</name>
              <description>[21:21] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 21 (See EVENT:CPUIRQSEL21.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>SETENA20</name>
              <description>[20:20] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 20 (See EVENT:CPUIRQSEL20.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>SETENA19</name>
              <description>[19:19] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 19 (See EVENT:CPUIRQSEL19.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>SETENA18</name>
              <description>[18:18] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 18 (See EVENT:CPUIRQSEL18.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>SETENA17</name>
              <description>[17:17] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 17 (See EVENT:CPUIRQSEL17.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>SETENA16</name>
              <description>[16:16] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 16 (See EVENT:CPUIRQSEL16.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SETENA15</name>
              <description>[15:15] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 15 (See EVENT:CPUIRQSEL15.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>SETENA14</name>
              <description>[14:14] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 14 (See EVENT:CPUIRQSEL14.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>SETENA13</name>
              <description>[13:13] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 13 (See EVENT:CPUIRQSEL13.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>SETENA12</name>
              <description>[12:12] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 12 (See EVENT:CPUIRQSEL12.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>SETENA11</name>
              <description>[11:11] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 11 (See EVENT:CPUIRQSEL11.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>SETENA10</name>
              <description>[10:10] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 10 (See EVENT:CPUIRQSEL10.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>SETENA9</name>
              <description>[9:9] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 9 (See EVENT:CPUIRQSEL9.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>SETENA8</name>
              <description>[8:8] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 8 (See EVENT:CPUIRQSEL8.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SETENA7</name>
              <description>[7:7] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 7 (See EVENT:CPUIRQSEL7.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SETENA6</name>
              <description>[6:6] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 6 (See EVENT:CPUIRQSEL6.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SETENA5</name>
              <description>[5:5] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 5 (See EVENT:CPUIRQSEL5.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>SETENA4</name>
              <description>[4:4] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 4 (See EVENT:CPUIRQSEL4.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SETENA3</name>
              <description>[3:3] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 3 (See EVENT:CPUIRQSEL3.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SETENA2</name>
              <description>[2:2] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 2 (See EVENT:CPUIRQSEL2.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SETENA1</name>
              <description>[1:1] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 1 (See EVENT:CPUIRQSEL1.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SETENA0</name>
              <description>[0:0] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 0 (See EVENT:CPUIRQSEL0.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_ISER1</name>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <description>Irq 32 to 63 Set Enable
This register is used to enable interrupts and determine which interrupts are currently enabled.</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SETENA33</name>
              <description>[1:1] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 33 (See EVENT:CPUIRQSEL33.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SETENA32</name>
              <description>[0:0] Writing 0 to this bit has no effect, writing 1 to this bit enables the interrupt number 32 (See EVENT:CPUIRQSEL32.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED0</name>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_ICER0</name>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <description>Irq 0 to 31 Clear Enable
This register is used to disable interrupts and determine which interrupts are currently enabled.</description>
          <fields>
            <field>
              <name>CLRENA31</name>
              <description>[31:31] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  31 (See EVENT:CPUIRQSEL31.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>CLRENA30</name>
              <description>[30:30] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  30 (See EVENT:CPUIRQSEL30.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>CLRENA29</name>
              <description>[29:29] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  29 (See EVENT:CPUIRQSEL29.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>CLRENA28</name>
              <description>[28:28] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  28 (See EVENT:CPUIRQSEL28.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>CLRENA27</name>
              <description>[27:27] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  27 (See EVENT:CPUIRQSEL27.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>CLRENA26</name>
              <description>[26:26] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  26 (See EVENT:CPUIRQSEL26.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>CLRENA25</name>
              <description>[25:25] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  25 (See EVENT:CPUIRQSEL25.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>CLRENA24</name>
              <description>[24:24] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  24 (See EVENT:CPUIRQSEL24.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CLRENA23</name>
              <description>[23:23] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  23 (See EVENT:CPUIRQSEL23.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>CLRENA22</name>
              <description>[22:22] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  22 (See EVENT:CPUIRQSEL22.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>CLRENA21</name>
              <description>[21:21] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  21 (See EVENT:CPUIRQSEL21.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>CLRENA20</name>
              <description>[20:20] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  20 (See EVENT:CPUIRQSEL20.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CLRENA19</name>
              <description>[19:19] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  19 (See EVENT:CPUIRQSEL19.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CLRENA18</name>
              <description>[18:18] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  18 (See EVENT:CPUIRQSEL18.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>CLRENA17</name>
              <description>[17:17] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  17 (See EVENT:CPUIRQSEL17.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>CLRENA16</name>
              <description>[16:16] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  16 (See EVENT:CPUIRQSEL16.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CLRENA15</name>
              <description>[15:15] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  15 (See EVENT:CPUIRQSEL15.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>CLRENA14</name>
              <description>[14:14] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  14 (See EVENT:CPUIRQSEL14.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>CLRENA13</name>
              <description>[13:13] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  13 (See EVENT:CPUIRQSEL13.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>CLRENA12</name>
              <description>[12:12] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  12 (See EVENT:CPUIRQSEL12.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CLRENA11</name>
              <description>[11:11] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  11 (See EVENT:CPUIRQSEL11.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CLRENA10</name>
              <description>[10:10] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  10 (See EVENT:CPUIRQSEL10.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CLRENA9</name>
              <description>[9:9] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  9 (See EVENT:CPUIRQSEL9.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>CLRENA8</name>
              <description>[8:8] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  8 (See EVENT:CPUIRQSEL8.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CLRENA7</name>
              <description>[7:7] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  7 (See EVENT:CPUIRQSEL7.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CLRENA6</name>
              <description>[6:6] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  6 (See EVENT:CPUIRQSEL6.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>CLRENA5</name>
              <description>[5:5] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  5 (See EVENT:CPUIRQSEL5.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CLRENA4</name>
              <description>[4:4] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  4 (See EVENT:CPUIRQSEL4.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CLRENA3</name>
              <description>[3:3] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  3 (See EVENT:CPUIRQSEL3.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CLRENA2</name>
              <description>[2:2] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  2 (See EVENT:CPUIRQSEL2.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CLRENA1</name>
              <description>[1:1] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  1 (See EVENT:CPUIRQSEL1.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLRENA0</name>
              <description>[0:0] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  0 (See EVENT:CPUIRQSEL0.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_ICER1</name>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <description>Irq 32 to 63 Clear Enable
This register is used to disable interrupts and determine which interrupts are currently enabled.</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CLRENA33</name>
              <description>[1:1] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  33 (See EVENT:CPUIRQSEL33.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLRENA32</name>
              <description>[0:0] Writing 0 to this bit has no effect, writing 1 to this bit disables the interrupt number  32 (See EVENT:CPUIRQSEL32.EV for details). Reading the bit returns its current enable state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED1</name>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_ISPR0</name>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <description>Irq 0 to 31 Set Pending
This register is used to force interrupts into the pending state and determine which interrupts are currently pending.</description>
          <fields>
            <field>
              <name>SETPEND31</name>
              <description>[31:31] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 31 (See EVENT:CPUIRQSEL31.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>SETPEND30</name>
              <description>[30:30] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 30 (See EVENT:CPUIRQSEL30.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>SETPEND29</name>
              <description>[29:29] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 29 (See EVENT:CPUIRQSEL29.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>SETPEND28</name>
              <description>[28:28] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 28 (See EVENT:CPUIRQSEL28.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>SETPEND27</name>
              <description>[27:27] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 27 (See EVENT:CPUIRQSEL27.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>SETPEND26</name>
              <description>[26:26] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 26 (See EVENT:CPUIRQSEL26.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>SETPEND25</name>
              <description>[25:25] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 25 (See EVENT:CPUIRQSEL25.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>SETPEND24</name>
              <description>[24:24] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 24 (See EVENT:CPUIRQSEL24.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>SETPEND23</name>
              <description>[23:23] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 23 (See EVENT:CPUIRQSEL23.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>SETPEND22</name>
              <description>[22:22] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 22 (See EVENT:CPUIRQSEL22.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>SETPEND21</name>
              <description>[21:21] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 21 (See EVENT:CPUIRQSEL21.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>SETPEND20</name>
              <description>[20:20] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 20 (See EVENT:CPUIRQSEL20.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>SETPEND19</name>
              <description>[19:19] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 19 (See EVENT:CPUIRQSEL19.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>SETPEND18</name>
              <description>[18:18] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 18 (See EVENT:CPUIRQSEL18.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>SETPEND17</name>
              <description>[17:17] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 17 (See EVENT:CPUIRQSEL17.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>SETPEND16</name>
              <description>[16:16] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 16 (See EVENT:CPUIRQSEL16.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SETPEND15</name>
              <description>[15:15] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 15 (See EVENT:CPUIRQSEL15.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>SETPEND14</name>
              <description>[14:14] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 14 (See EVENT:CPUIRQSEL14.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>SETPEND13</name>
              <description>[13:13] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 13 (See EVENT:CPUIRQSEL13.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>SETPEND12</name>
              <description>[12:12] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 12 (See EVENT:CPUIRQSEL12.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>SETPEND11</name>
              <description>[11:11] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 11 (See EVENT:CPUIRQSEL11.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>SETPEND10</name>
              <description>[10:10] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 10 (See EVENT:CPUIRQSEL10.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>SETPEND9</name>
              <description>[9:9] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 9 (See EVENT:CPUIRQSEL9.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>SETPEND8</name>
              <description>[8:8] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 8 (See EVENT:CPUIRQSEL8.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SETPEND7</name>
              <description>[7:7] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 7 (See EVENT:CPUIRQSEL7.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SETPEND6</name>
              <description>[6:6] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 6 (See EVENT:CPUIRQSEL6.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SETPEND5</name>
              <description>[5:5] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 5 (See EVENT:CPUIRQSEL5.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>SETPEND4</name>
              <description>[4:4] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 4 (See EVENT:CPUIRQSEL4.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SETPEND3</name>
              <description>[3:3] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 3 (See EVENT:CPUIRQSEL3.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SETPEND2</name>
              <description>[2:2] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 2 (See EVENT:CPUIRQSEL2.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SETPEND1</name>
              <description>[1:1] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 1 (See EVENT:CPUIRQSEL1.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SETPEND0</name>
              <description>[0:0] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 0 (See EVENT:CPUIRQSEL0.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_ISPR1</name>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <description>Irq 32 to 63 Set Pending
This register is used to force interrupts into the pending state and determine which interrupts are currently pending.</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SETPEND33</name>
              <description>[1:1] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 33 (See EVENT:CPUIRQSEL33.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SETPEND32</name>
              <description>[0:0] Writing 0 to this bit has no effect, writing 1 to this bit pends the interrupt number 32 (See EVENT:CPUIRQSEL32.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED2</name>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_ICPR0</name>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <description>Irq 0 to 31 Clear Pending
This register is used to clear pending interrupts and determine which interrupts are currently pending.</description>
          <fields>
            <field>
              <name>CLRPEND31</name>
              <description>[31:31] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 31 (See EVENT:CPUIRQSEL31.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>CLRPEND30</name>
              <description>[30:30] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 30 (See EVENT:CPUIRQSEL30.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>CLRPEND29</name>
              <description>[29:29] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 29 (See EVENT:CPUIRQSEL29.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>CLRPEND28</name>
              <description>[28:28] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 28 (See EVENT:CPUIRQSEL28.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>CLRPEND27</name>
              <description>[27:27] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 27 (See EVENT:CPUIRQSEL27.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>CLRPEND26</name>
              <description>[26:26] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 26 (See EVENT:CPUIRQSEL26.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>CLRPEND25</name>
              <description>[25:25] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 25 (See EVENT:CPUIRQSEL25.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>CLRPEND24</name>
              <description>[24:24] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 24 (See EVENT:CPUIRQSEL24.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CLRPEND23</name>
              <description>[23:23] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 23 (See EVENT:CPUIRQSEL23.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>CLRPEND22</name>
              <description>[22:22] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 22 (See EVENT:CPUIRQSEL22.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>CLRPEND21</name>
              <description>[21:21] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 21 (See EVENT:CPUIRQSEL21.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>CLRPEND20</name>
              <description>[20:20] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 20 (See EVENT:CPUIRQSEL20.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CLRPEND19</name>
              <description>[19:19] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 19 (See EVENT:CPUIRQSEL19.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CLRPEND18</name>
              <description>[18:18] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 18 (See EVENT:CPUIRQSEL18.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>CLRPEND17</name>
              <description>[17:17] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 17 (See EVENT:CPUIRQSEL17.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>CLRPEND16</name>
              <description>[16:16] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 16 (See EVENT:CPUIRQSEL16.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CLRPEND15</name>
              <description>[15:15] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 15 (See EVENT:CPUIRQSEL15.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>CLRPEND14</name>
              <description>[14:14] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 14 (See EVENT:CPUIRQSEL14.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>CLRPEND13</name>
              <description>[13:13] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 13 (See EVENT:CPUIRQSEL13.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>CLRPEND12</name>
              <description>[12:12] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 12 (See EVENT:CPUIRQSEL12.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CLRPEND11</name>
              <description>[11:11] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 11 (See EVENT:CPUIRQSEL11.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CLRPEND10</name>
              <description>[10:10] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 10 (See EVENT:CPUIRQSEL10.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CLRPEND9</name>
              <description>[9:9] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 9 (See EVENT:CPUIRQSEL9.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>CLRPEND8</name>
              <description>[8:8] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 8 (See EVENT:CPUIRQSEL8.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CLRPEND7</name>
              <description>[7:7] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 7 (See EVENT:CPUIRQSEL7.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>CLRPEND6</name>
              <description>[6:6] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 6 (See EVENT:CPUIRQSEL6.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>CLRPEND5</name>
              <description>[5:5] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 5 (See EVENT:CPUIRQSEL5.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CLRPEND4</name>
              <description>[4:4] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 4 (See EVENT:CPUIRQSEL4.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CLRPEND3</name>
              <description>[3:3] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 3 (See EVENT:CPUIRQSEL3.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CLRPEND2</name>
              <description>[2:2] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 2 (See EVENT:CPUIRQSEL2.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CLRPEND1</name>
              <description>[1:1] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 1 (See EVENT:CPUIRQSEL1.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLRPEND0</name>
              <description>[0:0] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 0 (See EVENT:CPUIRQSEL0.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_ICPR1</name>
          <addressOffset>0x284</addressOffset>
          <size>32</size>
          <description>Irq 32 to 63 Clear Pending
This register is used to clear pending interrupts and determine which interrupts are currently pending.</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CLRPEND33</name>
              <description>[1:1] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 33 (See EVENT:CPUIRQSEL33.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLRPEND32</name>
              <description>[0:0] Writing 0 to this bit has no effect, writing 1 to this bit clears the corresponding pending interrupt 32 (See EVENT:CPUIRQSEL32.EV for details). Reading the bit returns its current state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED3</name>
          <addressOffset>0x288</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_IABR0</name>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <description>Irq 0 to 31 Active Bit
This register is used to determine which interrupts are active. Each flag in the register corresponds to one interrupt.</description>
          <fields>
            <field>
              <name>ACTIVE31</name>
              <description>[31:31] Reading 0 from this bit implies that interrupt line 31 is not active. Reading 1 from this bit implies that the interrupt line 31 is active (See EVENT:CPUIRQSEL31.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>ACTIVE30</name>
              <description>[30:30] Reading 0 from this bit implies that interrupt line 30 is not active. Reading 1 from this bit implies that the interrupt line 30 is active (See EVENT:CPUIRQSEL30.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>ACTIVE29</name>
              <description>[29:29] Reading 0 from this bit implies that interrupt line 29 is not active. Reading 1 from this bit implies that the interrupt line 29 is active (See EVENT:CPUIRQSEL29.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>ACTIVE28</name>
              <description>[28:28] Reading 0 from this bit implies that interrupt line 28 is not active. Reading 1 from this bit implies that the interrupt line 28 is active (See EVENT:CPUIRQSEL28.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>ACTIVE27</name>
              <description>[27:27] Reading 0 from this bit implies that interrupt line 27 is not active. Reading 1 from this bit implies that the interrupt line 27 is active (See EVENT:CPUIRQSEL27.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>ACTIVE26</name>
              <description>[26:26] Reading 0 from this bit implies that interrupt line 26 is not active. Reading 1 from this bit implies that the interrupt line 26 is active (See EVENT:CPUIRQSEL26.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>ACTIVE25</name>
              <description>[25:25] Reading 0 from this bit implies that interrupt line 25 is not active. Reading 1 from this bit implies that the interrupt line 25 is active (See EVENT:CPUIRQSEL25.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>ACTIVE24</name>
              <description>[24:24] Reading 0 from this bit implies that interrupt line 24 is not active. Reading 1 from this bit implies that the interrupt line 24 is active (See EVENT:CPUIRQSEL24.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>ACTIVE23</name>
              <description>[23:23] Reading 0 from this bit implies that interrupt line 23 is not active. Reading 1 from this bit implies that the interrupt line 23 is active (See EVENT:CPUIRQSEL23.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>ACTIVE22</name>
              <description>[22:22] Reading 0 from this bit implies that interrupt line 22 is not active. Reading 1 from this bit implies that the interrupt line 22 is active (See EVENT:CPUIRQSEL22.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>ACTIVE21</name>
              <description>[21:21] Reading 0 from this bit implies that interrupt line 21 is not active. Reading 1 from this bit implies that the interrupt line 21 is active (See EVENT:CPUIRQSEL21.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>ACTIVE20</name>
              <description>[20:20] Reading 0 from this bit implies that interrupt line 20 is not active. Reading 1 from this bit implies that the interrupt line 20 is active (See EVENT:CPUIRQSEL20.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>ACTIVE19</name>
              <description>[19:19] Reading 0 from this bit implies that interrupt line 19 is not active. Reading 1 from this bit implies that the interrupt line 19 is active (See EVENT:CPUIRQSEL19.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>ACTIVE18</name>
              <description>[18:18] Reading 0 from this bit implies that interrupt line 18 is not active. Reading 1 from this bit implies that the interrupt line 18 is active (See EVENT:CPUIRQSEL18.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>ACTIVE17</name>
              <description>[17:17] Reading 0 from this bit implies that interrupt line 17 is not active. Reading 1 from this bit implies that the interrupt line 17 is active (See EVENT:CPUIRQSEL17.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>ACTIVE16</name>
              <description>[16:16] Reading 0 from this bit implies that interrupt line 16 is not active. Reading 1 from this bit implies that the interrupt line 16 is active (See EVENT:CPUIRQSEL16.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>ACTIVE15</name>
              <description>[15:15] Reading 0 from this bit implies that interrupt line 15 is not active. Reading 1 from this bit implies that the interrupt line 15 is active (See EVENT:CPUIRQSEL15.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>ACTIVE14</name>
              <description>[14:14] Reading 0 from this bit implies that interrupt line 14 is not active. Reading 1 from this bit implies that the interrupt line 14 is active (See EVENT:CPUIRQSEL14.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>ACTIVE13</name>
              <description>[13:13] Reading 0 from this bit implies that interrupt line 13 is not active. Reading 1 from this bit implies that the interrupt line 13 is active (See EVENT:CPUIRQSEL13.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>ACTIVE12</name>
              <description>[12:12] Reading 0 from this bit implies that interrupt line 12 is not active. Reading 1 from this bit implies that the interrupt line 12 is active (See EVENT:CPUIRQSEL12.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>ACTIVE11</name>
              <description>[11:11] Reading 0 from this bit implies that interrupt line 11 is not active. Reading 1 from this bit implies that the interrupt line 11 is active (See EVENT:CPUIRQSEL11.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>ACTIVE10</name>
              <description>[10:10] Reading 0 from this bit implies that interrupt line 10 is not active. Reading 1 from this bit implies that the interrupt line 10 is active (See EVENT:CPUIRQSEL10.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>ACTIVE9</name>
              <description>[9:9] Reading 0 from this bit implies that interrupt line 9 is not active. Reading 1 from this bit implies that the interrupt line 9 is active (See EVENT:CPUIRQSEL9.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>ACTIVE8</name>
              <description>[8:8] Reading 0 from this bit implies that interrupt line 8 is not active. Reading 1 from this bit implies that the interrupt line 8 is active (See EVENT:CPUIRQSEL8.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ACTIVE7</name>
              <description>[7:7] Reading 0 from this bit implies that interrupt line 7 is not active. Reading 1 from this bit implies that the interrupt line 7 is active (See EVENT:CPUIRQSEL7.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>ACTIVE6</name>
              <description>[6:6] Reading 0 from this bit implies that interrupt line 6 is not active. Reading 1 from this bit implies that the interrupt line 6 is active (See EVENT:CPUIRQSEL6.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>ACTIVE5</name>
              <description>[5:5] Reading 0 from this bit implies that interrupt line 5 is not active. Reading 1 from this bit implies that the interrupt line 5 is active (See EVENT:CPUIRQSEL5.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>ACTIVE4</name>
              <description>[4:4] Reading 0 from this bit implies that interrupt line 4 is not active. Reading 1 from this bit implies that the interrupt line 4 is active (See EVENT:CPUIRQSEL4.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>ACTIVE3</name>
              <description>[3:3] Reading 0 from this bit implies that interrupt line 3 is not active. Reading 1 from this bit implies that the interrupt line 3 is active (See EVENT:CPUIRQSEL3.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>ACTIVE2</name>
              <description>[2:2] Reading 0 from this bit implies that interrupt line 2 is not active. Reading 1 from this bit implies that the interrupt line 2 is active (See EVENT:CPUIRQSEL2.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ACTIVE1</name>
              <description>[1:1] Reading 0 from this bit implies that interrupt line 1 is not active. Reading 1 from this bit implies that the interrupt line 1 is active (See EVENT:CPUIRQSEL1.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ACTIVE0</name>
              <description>[0:0] Reading 0 from this bit implies that interrupt line 0 is not active. Reading 1 from this bit implies that the interrupt line 0 is active (See EVENT:CPUIRQSEL0.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_IABR1</name>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <description>Irq 32 to 63 Active Bit
This register is used to determine which interrupts are active. Each flag in the register corresponds to one interrupt.</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ACTIVE33</name>
              <description>[1:1] Reading 0 from this bit implies that interrupt line 33 is not active. Reading 1 from this bit implies that the interrupt line 33 is active (See EVENT:CPUIRQSEL33.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ACTIVE32</name>
              <description>[0:0] Reading 0 from this bit implies that interrupt line 32 is not active. Reading 1 from this bit implies that the interrupt line 32 is active (See EVENT:CPUIRQSEL32.EV for details).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED4</name>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_IPR0</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>Irq 0 to 3 Priority
This register is used to assign a priority from 0 to 255 to each of the available interrupts. 0 is the highest priority, and 255 is the lowest. The interpretation of the Interrupt Priority Registers changes based on the setting in AIRCR.PRIGROUP.</description>
          <fields>
            <field>
              <name>PRI_3</name>
              <description>[31:24] Priority of interrupt 3 (See EVENT:CPUIRQSEL3.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRI_2</name>
              <description>[23:16] Priority of interrupt 2 (See EVENT:CPUIRQSEL2.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PRI_1</name>
              <description>[15:8] Priority of interrupt 1 (See EVENT:CPUIRQSEL1.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRI_0</name>
              <description>[7:0] Priority of interrupt 0 (See EVENT:CPUIRQSEL0.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_IPR1</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>Irq 4 to 7 Priority
This register is used to assign a priority from 0 to 255 to each of the available interrupts. 0 is the highest priority, and 255 is the lowest. The interpretation of the Interrupt Priority Registers changes based on the setting in AIRCR.PRIGROUP.</description>
          <fields>
            <field>
              <name>PRI_7</name>
              <description>[31:24] Priority of interrupt 7 (See EVENT:CPUIRQSEL7.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRI_6</name>
              <description>[23:16] Priority of interrupt 6 (See EVENT:CPUIRQSEL6.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PRI_5</name>
              <description>[15:8] Priority of interrupt 5 (See EVENT:CPUIRQSEL5.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRI_4</name>
              <description>[7:0] Priority of interrupt 4 (See EVENT:CPUIRQSEL4.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_IPR2</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>Irq 8 to 11 Priority
This register is used to assign a priority from 0 to 255 to each of the available interrupts. 0 is the highest priority, and 255 is the lowest. The interpretation of the Interrupt Priority Registers changes based on the setting in AIRCR.PRIGROUP.</description>
          <fields>
            <field>
              <name>PRI_11</name>
              <description>[31:24] Priority of interrupt 11 (See EVENT:CPUIRQSEL11.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRI_10</name>
              <description>[23:16] Priority of interrupt 10 (See EVENT:CPUIRQSEL10.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PRI_9</name>
              <description>[15:8] Priority of interrupt 9 (See EVENT:CPUIRQSEL9.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRI_8</name>
              <description>[7:0] Priority of interrupt 8 (See EVENT:CPUIRQSEL8.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_IPR3</name>
          <addressOffset>0x40c</addressOffset>
          <size>32</size>
          <description>Irq 12 to 15 Priority
This register is used to assign a priority from 0 to 255 to each of the available interrupts. 0 is the highest priority, and 255 is the lowest. The interpretation of the Interrupt Priority Registers changes based on the setting in AIRCR.PRIGROUP.</description>
          <fields>
            <field>
              <name>PRI_15</name>
              <description>[31:24] Priority of interrupt 15 (See EVENT:CPUIRQSEL15.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRI_14</name>
              <description>[23:16] Priority of interrupt 14 (See EVENT:CPUIRQSEL14.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PRI_13</name>
              <description>[15:8] Priority of interrupt 13 (See EVENT:CPUIRQSEL13.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRI_12</name>
              <description>[7:0] Priority of interrupt 12 (See EVENT:CPUIRQSEL12.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_IPR4</name>
          <addressOffset>0x410</addressOffset>
          <size>32</size>
          <description>Irq 16 to 19 Priority
This register is used to assign a priority from 0 to 255 to each of the available interrupts. 0 is the highest priority, and 255 is the lowest. The interpretation of the Interrupt Priority Registers changes based on the setting in AIRCR.PRIGROUP.</description>
          <fields>
            <field>
              <name>PRI_19</name>
              <description>[31:24] Priority of interrupt 19 (See EVENT:CPUIRQSEL19.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRI_18</name>
              <description>[23:16] Priority of interrupt 18 (See EVENT:CPUIRQSEL18.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PRI_17</name>
              <description>[15:8] Priority of interrupt 17 (See EVENT:CPUIRQSEL17.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRI_16</name>
              <description>[7:0] Priority of interrupt 16 (See EVENT:CPUIRQSEL16.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_IPR5</name>
          <addressOffset>0x414</addressOffset>
          <size>32</size>
          <description>Irq 20 to 23 Priority
This register is used to assign a priority from 0 to 255 to each of the available interrupts. 0 is the highest priority, and 255 is the lowest. The interpretation of the Interrupt Priority Registers changes based on the setting in AIRCR.PRIGROUP.</description>
          <fields>
            <field>
              <name>PRI_23</name>
              <description>[31:24] Priority of interrupt 23 (See EVENT:CPUIRQSEL23.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRI_22</name>
              <description>[23:16] Priority of interrupt 22 (See EVENT:CPUIRQSEL22.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PRI_21</name>
              <description>[15:8] Priority of interrupt 21 (See EVENT:CPUIRQSEL21.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRI_20</name>
              <description>[7:0] Priority of interrupt 20 (See EVENT:CPUIRQSEL20.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_IPR6</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>Irq 24 to 27 Priority
This register is used to assign a priority from 0 to 255 to each of the available interrupts. 0 is the highest priority, and 255 is the lowest. The interpretation of the Interrupt Priority Registers changes based on the setting in AIRCR.PRIGROUP.</description>
          <fields>
            <field>
              <name>PRI_27</name>
              <description>[31:24] Priority of interrupt 27 (See EVENT:CPUIRQSEL27.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRI_26</name>
              <description>[23:16] Priority of interrupt 26 (See EVENT:CPUIRQSEL26.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PRI_25</name>
              <description>[15:8] Priority of interrupt 25 (See EVENT:CPUIRQSEL25.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRI_24</name>
              <description>[7:0] Priority of interrupt 24 (See EVENT:CPUIRQSEL24.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_IPR7</name>
          <addressOffset>0x41c</addressOffset>
          <size>32</size>
          <description>Irq 28 to 31 Priority
This register is used to assign a priority from 0 to 255 to each of the available interrupts. 0 is the highest priority, and 255 is the lowest. The interpretation of the Interrupt Priority Registers changes based on the setting in AIRCR.PRIGROUP.</description>
          <fields>
            <field>
              <name>PRI_31</name>
              <description>[31:24] Priority of interrupt 31 (See EVENT:CPUIRQSEL31.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRI_30</name>
              <description>[23:16] Priority of interrupt 30 (See EVENT:CPUIRQSEL30.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PRI_29</name>
              <description>[15:8] Priority of interrupt 29 (See EVENT:CPUIRQSEL29.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRI_28</name>
              <description>[7:0] Priority of interrupt 28 (See EVENT:CPUIRQSEL28.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>NVIC_IPR8</name>
          <addressOffset>0x420</addressOffset>
          <size>32</size>
          <description>Irq 32 to 35 Priority
This register is used to assign a priority from 0 to 255 to each of the available interrupts. 0 is the highest priority, and 255 is the lowest. The interpretation of the Interrupt Priority Registers changes based on the setting in AIRCR.PRIGROUP.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PRI_33</name>
              <description>[15:8] Priority of interrupt 33 (See EVENT:CPUIRQSEL33.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRI_32</name>
              <description>[7:0] Priority of interrupt 32 (See EVENT:CPUIRQSEL32.EV for details).</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED5</name>
          <addressOffset>0x424</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CPUID</name>
          <addressOffset>0xd00</addressOffset>
          <size>32</size>
          <description>CPUID Base
This register determines the ID number of the processor core, the version number of the processor core and the implementation details of the processor core.</description>
          <fields>
            <field>
              <name>IMPLEMENTER</name>
              <description>[31:24] Implementor code.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>VARIANT</name>
              <description>[23:20] Implementation defined variant number.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CONSTANT</name>
              <description>[19:16] Reads as 0xF</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PARTNO</name>
              <description>[15:4] Number of processor within family.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>REVISION</name>
              <description>[3:0] Implementation defined revision number.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x412FC231</resetValue>
        </register>
        <register>
          <name>ICSR</name>
          <addressOffset>0xd04</addressOffset>
          <size>32</size>
          <description>Interrupt Control State
This register is used to set a pending Non-Maskable Interrupt (NMI), set or clear a pending SVC, set or clear a pending SysTick, check for pending exceptions, check the vector number of the highest priority pended exception, and check the vector number of the active exception.</description>
          <fields>
            <field>
              <name>NMIPENDSET</name>
              <description>[31:31] Set pending NMI bit. Setting this bit pends and activates an NMI. Because NMI is the highest-priority interrupt, it takes effect as soon as it registers.

0: No action
1: Set pending NMI</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>RESERVED29</name>
              <description>[30:29] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PENDSVSET</name>
              <description>[28:28] Set pending pendSV bit.

0: No action
1: Set pending PendSV</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PENDSVCLR</name>
              <description>[27:27] Clear pending pendSV bit

0: No action
1: Clear pending pendSV</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>PENDSTSET</name>
              <description>[26:26] Set a pending SysTick bit.

0: No action
1: Set pending SysTick</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PENDSTCLR</name>
              <description>[25:25] Clear pending SysTick bit

0: No action
1: Clear pending SysTick</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>RESERVED24</name>
              <description>[24:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>ISRPREEMPT</name>
              <description>[23:23] This field can only be used at debug time. It indicates that a pending interrupt is to be taken in the next running cycle. If DHCSR.C_MASKINTS= 0, the interrupt is serviced.

0: A pending exception is not serviced.
1: A pending exception is serviced on exit from the debug halt state</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>ISRPENDING</name>
              <description>[22:22] Interrupt pending flag. Excludes NMI and faults.

0x0: Interrupt not pending
0x1: Interrupt pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>RESERVED18</name>
              <description>[21:18] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>VECTPENDING</name>
              <description>[17:12] Pending ISR number field. This field contains the interrupt number of the highest priority pending ISR.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RETTOBASE</name>
              <description>[11:11] Indicates whether there are preempted active exceptions:

0: There are preempted active exceptions to execute
1: There are no active exceptions, or the currently-executing exception is the only active exception.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[10:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>VECTACTIVE</name>
              <description>[8:0] Active ISR number field. Reset clears this field.</description>
              <bitWidth>9</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>VTOR</name>
          <addressOffset>0xd08</addressOffset>
          <size>32</size>
          <description>Vector Table Offset
This register is used to relocated the vector table base address. The vector table base offset determines the offset from the bottom of the memory map. The two most significant bits and the seven least significant bits of the vector table base offset must be 0. The portion of vector table base offset that is allowed to change is TBLOFF.</description>
          <fields>
            <field>
              <name>RESERVED30</name>
              <description>[31:30] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>TBLOFF</name>
              <description>[29:7] Bits 29 down to 7 of the vector table base offset.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[6:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AIRCR</name>
          <addressOffset>0xd0c</addressOffset>
          <size>32</size>
          <description>Application Interrupt/Reset Control
This register is used to determine data endianness, clear all active state information for debug or to recover from a hard failure, execute a system reset, alter the priority grouping position (binary point).</description>
          <fields>
            <field>
              <name>VECTKEY</name>
              <description>[31:16] Register key. Writing to this register (AIRCR) requires 0x05FA in VECTKEY. Otherwise the write value is ignored. Read always returns 0xFA05.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>ENDIANESS</name>
              <description>[15:15] Data endianness bit</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIG</name>
                  <value>1</value>
                  <description>Big endian</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LITTLE</name>
                  <value>0</value>
                  <description>Little endian</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED11</name>
              <description>[14:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>PRIGROUP</name>
              <description>[10:8] Interrupt priority grouping field. This field is a binary point position indicator for creating subpriorities for exceptions that share the same pre-emption level. It divides the PRI_n field in the Interrupt Priority Registers (NVIC_IPR0, NVIC_IPR1,..., and  NVIC_IPR8) into a pre-emption level and a subpriority level. The binary point is a left-of value. This means that the PRIGROUP value represents a point starting at the left of the Least Significant Bit (LSB). The lowest value might not be 0 depending on the number of bits allocated for priorities, and implementation choices.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[7:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SYSRESETREQ</name>
              <description>[2:2] Requests a warm reset. Setting this bit does not prevent Halting Debug from running.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>VECTCLRACTIVE</name>
              <description>[1:1] Clears all active state information for active NMI, fault, and interrupts.  It is the responsibility of the application to reinitialize the stack. This bit is for returning to a known state during debug. The bit self-clears. IPSR is not cleared by this operation. So, if used by an application, it must only be used at the base level of activation, or within a system handler whose active bit can be set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>VECTRESET</name>
              <description>[0:0] System Reset bit. Resets the system, with the exception of debug components. This bit is reserved for debug use and can be written to 1 only when the core is halted. The bit self-clears. Writing this bit to 1 while core is not halted may result in unpredictable behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFA050000</resetValue>
        </register>
        <register>
          <name>SCR</name>
          <addressOffset>0xd10</addressOffset>
          <size>32</size>
          <description>System Control
This register is used for power-management functions, i.e., signaling to the system when the processor can enter a low power state, controlling how the processor enters and exits low power states.</description>
          <fields>
            <field>
              <name>RESERVED5</name>
              <description>[31:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>SEVONPEND</name>
              <description>[4:4] Send Event on Pending bit:

0: Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded
1: Enabled events and all interrupts, including disabled interrupts, can wakeup the processor.

When an event or interrupt enters pending state, the event signal wakes up the processor from WFE. If
the processor is not waiting for an event, the event is registered and affects the next WFE.
The processor also wakes up on execution of an SEV instruction.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>[2:2] Controls whether the processor uses sleep or deep sleep as its low power mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DEEPSLEEP</name>
                  <value>1</value>
                  <description>Deep sleep</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <value>0</value>
                  <description>Sleep</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEEPONEXIT</name>
              <description>[1:1] Sleep on exit when returning from Handler mode to Thread mode. Enables interrupt driven applications to avoid returning to empty main application.

0: Do not sleep when returning to thread mode
1: Sleep on ISR exit</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CCR</name>
          <addressOffset>0xd14</addressOffset>
          <size>32</size>
          <description>Configuration Control
This register is used to enable NMI, HardFault and FAULTMASK to ignore bus fault, trap divide by zero and unaligned accesses, enable user access to the Software Trigger Interrupt Register (STIR), control entry to Thread Mode.</description>
          <fields>
            <field>
              <name>RESERVED10</name>
              <description>[31:10] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>22</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>STKALIGN</name>
              <description>[9:9] Stack alignment bit.

0: Only 4-byte alignment is guaranteed for the SP used prior to the exception on exception entry.
1: On exception entry, the SP used prior to the exception is adjusted to be 8-byte aligned and the context to restore it is saved. The SP is restored on the associated exception return.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>BFHFNMIGN</name>
              <description>[8:8] Enables handlers with priority -1 or -2 to ignore data BusFaults caused by load and store instructions. This applies to the HardFault, NMI, and FAULTMASK escalated handlers:

0: Data BusFaults caused by load and store instructions cause a lock-up
1: Data BusFaults caused by load and store instructions are ignored.

Set this bit to 1 only when the handler and its data are in absolutely safe memory. The normal use
of this bit is to probe system devices and bridges to detect problems.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[7:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>DIV_0_TRP</name>
              <description>[4:4] Enables faulting or halting when the processor executes an SDIV or UDIV instruction with a divisor of 0:

0: Do not trap divide by 0. In this mode, a divide by zero returns a quotient of 0.
1: Trap divide by 0. The relevant Usage Fault Status Register bit is CFSR.DIVBYZERO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>UNALIGN_TRP</name>
              <description>[3:3] Enables unaligned access traps:

0: Do not trap unaligned halfword and word accesses
1: Trap unaligned halfword and word accesses. The relevant Usage Fault Status Register bit is CFSR.UNALIGNED.

If this bit is set to 1, an unaligned access generates a UsageFault.
Unaligned LDM, STM, LDRD, and STRD instructions always fault regardless of the value in UNALIGN_TRP.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[2:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>USERSETMPEND</name>
              <description>[1:1] Enables unprivileged software access to STIR:

0: User code is not allowed to write to the Software Trigger Interrupt register (STIR).
1: User code can write the Software Trigger Interrupt register (STIR) to trigger (pend) a Main exception, which is associated with the Main stack pointer.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>NONBASETHREDENA</name>
              <description>[0:0] Indicates how the processor enters Thread mode:

0: Processor can enter Thread mode only when no exception is active.
1: Processor can enter Thread mode from any level using the appropriate return value (EXC_RETURN).

Exception returns occur when one of the following instructions loads a value of 0xFXXXXXXX into the PC while in Handler mode: 
- POP/LDM which includes loading the PC. 
- LDR with PC as a destination. 
- BX with any register. 
The value written to the PC is intercepted and is referred to as the EXC_RETURN value.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x200</resetValue>
        </register>
        <register>
          <name>SHPR1</name>
          <addressOffset>0xd18</addressOffset>
          <size>32</size>
          <description>System Handlers 4-7 Priority
This register is used to prioritize the following system handlers: Memory manage, Bus fault, and Usage fault. System Handlers are a special class of exception handler that can have their priority set to any of the priority levels. Most can be masked on (enabled) or off (disabled). When disabled, the fault is always treated as a Hard Fault.</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRI_6</name>
              <description>[23:16] Priority of system handler 6. UsageFault</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PRI_5</name>
              <description>[15:8] Priority of system handler 5: BusFault</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRI_4</name>
              <description>[7:0] Priority of system handler 4: MemManage</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SHPR2</name>
          <addressOffset>0xd1c</addressOffset>
          <size>32</size>
          <description>System Handlers 8-11 Priority
This register is used to prioritize the SVC handler. System Handlers are a special class of exception handler that can have their priority set to any of the priority levels. Most can be masked on (enabled) or off (disabled). When disabled, the fault is always treated as a Hard Fault.</description>
          <fields>
            <field>
              <name>PRI_11</name>
              <description>[31:24] Priority of system handler 11. SVCall</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[23:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SHPR3</name>
          <addressOffset>0xd20</addressOffset>
          <size>32</size>
          <description>System Handlers 12-15 Priority
This register is used to prioritize the following system handlers: SysTick, PendSV and Debug Monitor. System Handlers are a special class of exception handler that can have their priority set to any of the priority levels. Most can be masked on (enabled) or off (disabled). When disabled, the fault is always treated as a Hard Fault.</description>
          <fields>
            <field>
              <name>PRI_15</name>
              <description>[31:24] Priority of system handler 15. SysTick exception</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PRI_14</name>
              <description>[23:16] Priority of system handler 14. Pend SV</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED8</name>
              <description>[15:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRI_12</name>
              <description>[7:0] Priority of system handler 12. Debug Monitor</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SHCSR</name>
          <addressOffset>0xd24</addressOffset>
          <size>32</size>
          <description>System Handler Control and State
This register is used to enable or disable the system handlers, determine the pending status of bus fault, mem manage fault, and SVC, determine the active status of the system handlers. If a fault condition occurs while its fault handler is disabled, the fault escalates to a Hard Fault.</description>
          <fields>
            <field>
              <name>RESERVED19</name>
              <description>[31:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>13</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>USGFAULTENA</name>
              <description>[18:18] Usage fault system handler enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Exception enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Exception disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSFAULTENA</name>
              <description>[17:17] Bus fault system handler enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Exception enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Exception disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MEMFAULTENA</name>
              <description>[16:16] MemManage fault system handler enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Exception enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Exception disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SVCALLPENDED</name>
              <description>[15:15] SVCall pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PENDING</name>
                  <value>1</value>
                  <description>Exception is pending.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOTPENDING</name>
                  <value>0</value>
                  <description>Exception is not active</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUSFAULTPENDED</name>
              <description>[14:14] BusFault pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PENDING</name>
                  <value>1</value>
                  <description>Exception is pending.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOTPENDING</name>
                  <value>0</value>
                  <description>Exception is not active</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MEMFAULTPENDED</name>
              <description>[13:13] MemManage exception pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PENDING</name>
                  <value>1</value>
                  <description>Exception is pending.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOTPENDING</name>
                  <value>0</value>
                  <description>Exception is not active</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>USGFAULTPENDED</name>
              <description>[12:12] Usage fault pending</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PENDING</name>
                  <value>1</value>
                  <description>Exception is pending.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOTPENDING</name>
                  <value>0</value>
                  <description>Exception is not active</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYSTICKACT</name>
              <description>[11:11] SysTick active flag.

0x0: Not active
0x1: Active</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <value>1</value>
                  <description>Exception is active</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOTACTIVE</name>
                  <value>0</value>
                  <description>Exception is not active</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PENDSVACT</name>
              <description>[10:10] PendSV active

0x0: Not active
0x1: Active</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[9:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>MONITORACT</name>
              <description>[8:8] Debug monitor active</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <value>1</value>
                  <description>Exception is active</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOTACTIVE</name>
                  <value>0</value>
                  <description>Exception is not active</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SVCALLACT</name>
              <description>[7:7] SVCall active</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <value>1</value>
                  <description>Exception is active</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOTACTIVE</name>
                  <value>0</value>
                  <description>Exception is not active</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[6:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>USGFAULTACT</name>
              <description>[3:3] UsageFault exception active</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <value>1</value>
                  <description>Exception is active</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOTACTIVE</name>
                  <value>0</value>
                  <description>Exception is not active</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[2:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>BUSFAULTACT</name>
              <description>[1:1] BusFault exception active</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <value>1</value>
                  <description>Exception is active</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOTACTIVE</name>
                  <value>0</value>
                  <description>Exception is not active</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MEMFAULTACT</name>
              <description>[0:0] MemManage exception active</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <value>1</value>
                  <description>Exception is active</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOTACTIVE</name>
                  <value>0</value>
                  <description>Exception is not active</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CFSR</name>
          <addressOffset>0xd28</addressOffset>
          <size>32</size>
          <description>Configurable Fault Status
This register is used to obtain information about local faults. These registers include three subsections: The first byte is Memory Manage Fault Status Register (MMFSR). The second byte is Bus Fault Status Register (BFSR). The higher half-word is Usage Fault Status Register (UFSR). The flags in these registers indicate the causes of local faults. Multiple flags can be set if more than one fault occurs. These register are read/write-clear. This means that they can be read normally, but writing a 1 to any bit clears that bit.
The CFSR is byte accessible. CFSR or its subregisters can be accessed as follows:
The following accesses are possible to the CFSR register:
- access the complete register with a word access to 0xE000ED28. 
- access the MMFSR with a byte access to 0xE000ED28
- access the MMFSR and BFSR with a halfword access to 0xE000ED28
- access the BFSR with a byte access to 0xE000ED29
- access the UFSR with a halfword access to 0xE000ED2A.</description>
          <fields>
            <field>
              <name>RESERVED26</name>
              <description>[31:26] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>DIVBYZERO</name>
              <description>[25:25] When CCR.DIV_0_TRP (see Configuration Control Register on page 8-26) is enabled and an SDIV or UDIV instruction is used with a divisor of 0, this fault occurs The instruction is executed and the return PC points to it. If CCR.DIV_0_TRP is not set, then the divide returns a quotient of 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>UNALIGNED</name>
              <description>[24:24] When CCR.UNALIGN_TRP is enabled, and there is an attempt to make an unaligned memory access, then this fault occurs. Unaligned LDM/STM/LDRD/STRD instructions always fault irrespective of the setting of CCR.UNALIGN_TRP.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED20</name>
              <description>[23:20] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>NOCP</name>
              <description>[19:19] Attempt to use a coprocessor instruction. The processor does not support coprocessor instructions.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>INVPC</name>
              <description>[18:18] Attempt to load EXC_RETURN into PC illegally. Invalid instruction, invalid context, invalid value. The return PC points to the instruction that tried to set the PC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>INVSTATE</name>
              <description>[17:17] Indicates an attempt to execute in an invalid EPSR state (e.g. after a BX type instruction has changed state). This includes state change after entry to or return from exception, as well as from inter-working instructions. Return PC points to faulting instruction, with the invalid state.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>UNDEFINSTR</name>
              <description>[16:16] This bit is set when the processor attempts to execute an undefined instruction. This is an instruction that the processor cannot decode. The return PC points to the undefined instruction.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>BFARVALID</name>
              <description>[15:15] This bit is set if the Bus Fault Address Register (BFAR) contains a valid address. This is true after a bus fault where the address is known. Other faults can clear this bit, such as a Mem Manage fault occurring later. If a Bus fault occurs that is escalated to a Hard Fault because of priority, the Hard Fault handler must clear this bit. This prevents problems if returning to a stacked active Bus fault handler whose BFAR value has been overwritten.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>RESERVED13</name>
              <description>[14:13] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>STKERR</name>
              <description>[12:12] Stacking from exception has caused one or more bus faults. The SP is still adjusted and the values in the context area on the stack might be incorrect. BFAR is not written.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>UNSTKERR</name>
              <description>[11:11] Unstack from exception return has caused one or more bus faults. This is chained to the handler, so that the original return stack is still present. SP is not adjusted from failing return and new save is not performed. BFAR is not written.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>IMPRECISERR</name>
              <description>[10:10] Imprecise data bus error. It is a BusFault, but the Return PC is not related to the causing instruction. This is not a synchronous fault. So, if detected when the priority of the current activation is higher than the Bus Fault, it only pends. Bus fault activates when returning to a lower priority activation. If a precise fault occurs before returning to a lower priority exception, the handler detects both IMPRECISERR set and one of the precise fault status bits set at the same time. BFAR is not written.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PRECISERR</name>
              <description>[9:9] Precise data bus error return.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>IBUSERR</name>
              <description>[8:8] Instruction bus error flag. This flag is set by a prefetch error. The fault stops on the instruction, so if the error occurs under a branch shadow, no fault occurs. BFAR is not written.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MMARVALID</name>
              <description>[7:7] Memory Manage Address Register (MMFAR) address valid flag. A later-arriving fault, such as a bus fault, can clear a memory manage fault.. If a MemManage fault occurs that is escalated to a Hard Fault because of priority, the Hard Fault handler must clear this bit. This prevents problems on return to a stacked active MemManage handler whose MMFAR value has been overwritten.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[6:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>MSTKERR</name>
              <description>[4:4] Stacking from exception has caused one or more access violations. The SP is still adjusted and the values in the context area on the stack might be incorrect. MMFAR is not written.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MUNSTKERR</name>
              <description>[3:3] Unstack from exception return has caused one or more access violations. This is chained to the handler, so that the original return stack is still present. SP is not adjusted from failing return and new save is not performed. MMFAR is not written.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[2:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DACCVIOL</name>
              <description>[1:1] Data access violation flag. Attempting to load or store at a location that does not permit the operation sets this flag. The return PC points to the faulting instruction. This error loads MMFAR with the address of the attempted access.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>IACCVIOL</name>
              <description>[0:0] Instruction access violation flag. Attempting to fetch an instruction from a location that does not permit execution sets this flag. This occurs on any access to an XN region, even when the MPU is disabled or not present. The return PC points to the faulting instruction. MMFAR is not written.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>HFSR</name>
          <addressOffset>0xd2c</addressOffset>
          <size>32</size>
          <description>Hard Fault Status
This register is used to obtain information about events that activate the Hard Fault handler. This register is a write-clear register. This means that writing a 1 to a bit clears that bit.</description>
          <fields>
            <field>
              <name>DEBUGEVT</name>
              <description>[31:31] This bit is set if there is a fault related to debug. This is only possible when halting debug is not enabled. For monitor enabled debug, it only happens for BKPT when the current priority is higher than the monitor. When both halting and monitor debug are disabled, it only happens for debug events that are not ignored (minimally, BKPT). The Debug Fault Status Register is updated.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>FORCED</name>
              <description>[30:30] Hard Fault activated because a Configurable Fault was received and cannot activate because of priority or because the Configurable Fault is disabled. The Hard Fault handler then has to read the other fault status registers to determine cause.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[29:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>VECTTBL</name>
              <description>[1:1] This bit is set if there is a fault because of vector table read on exception processing (Bus Fault). This case is always a Hard Fault. The return PC points to the pre-empted instruction.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DFSR</name>
          <addressOffset>0xd30</addressOffset>
          <size>32</size>
          <description>Debug Fault Status
This register is used to monitor external debug requests, vector catches, data watchpoint match, BKPT instruction execution, halt requests. Multiple flags in the Debug Fault Status Register can be set when multiple fault conditions occur. The register is read/write clear. This means that it can be read normally. Writing a 1 to a bit clears that bit. Note that these bits are not set unless the event is caught. This means that it causes a stop of some sort. If halting debug is enabled, these events stop the processor into debug. If debug is disabled and the debug monitor is enabled, then this becomes a debug monitor handler call, if priority permits. If debug and the monitor are both disabled, some of these events are Hard Faults, and some are ignored.</description>
          <fields>
            <field>
              <name>RESERVED5</name>
              <description>[31:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>EXTERNAL</name>
              <description>[4:4] External debug request flag. The processor stops on next instruction boundary.

0x0: External debug request signal not asserted
0x1: External debug request signal asserted</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>VCATCH</name>
              <description>[3:3] Vector catch flag. When this flag is set, a flag in one of the local fault status registers is also set to indicate the type of fault.

0x0: No vector catch occurred
0x1: Vector catch occurred</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DWTTRAP</name>
              <description>[2:2] Data Watchpoint and Trace (DWT) flag. The processor stops at the current instruction or at the next instruction.

0x0: No DWT match
0x1: DWT match</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>BKPT</name>
              <description>[1:1] BKPT flag. The BKPT flag is set by a BKPT instruction in flash patch code, and also by normal code. Return PC points to breakpoint containing instruction.

0x0: No BKPT instruction execution
0x1: BKPT instruction execution</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>HALTED</name>
              <description>[0:0] Halt request flag. The processor is halted on the next instruction.

0x0: No halt request
0x1: Halt requested by NVIC, including step</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MMFAR</name>
          <addressOffset>0xd34</addressOffset>
          <size>32</size>
          <description>Mem Manage Fault Address
This register is used to read the address of the location that caused a Memory Manage Fault.</description>
          <fields>
            <field>
              <name>ADDRESS</name>
              <description>[31:0] Mem Manage fault address field.
This field is the data address of a faulted load or store attempt. When an unaligned access faults, the address is the actual address that faulted. Because an access can be split into multiple parts, each aligned, this address can be any offset in the range of the requested size. Flags CFSR.IACCVIOL, CFSR.DACCVIOL ,CFSR.MUNSTKERR and CFSR.MSTKERR in combination with CFSR.MMARVALIDindicate the cause of the fault.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>BFAR</name>
          <addressOffset>0xd38</addressOffset>
          <size>32</size>
          <description>Bus Fault Address
This register is used to read the address of the location that generated a Bus Fault.</description>
          <fields>
            <field>
              <name>ADDRESS</name>
              <description>[31:0] Bus fault address field. This field is the data address of a faulted load or store attempt. When an unaligned access faults, the address is the address requested by the instruction, even if that is not the address that faulted. 
Flags CFSR.IBUSERR, CFSR.PRECISERR, CFSR.IMPRECISERR, CFSR.UNSTKERR and CFSR.STKERR in combination with CFSR.BFARVALID indicate the cause of the fault.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AFSR</name>
          <addressOffset>0xd3c</addressOffset>
          <size>32</size>
          <description>Auxiliary Fault Status
This register is used to determine additional system fault information to software. Single-cycle high level on an auxiliary faults is latched as one. The bit can only be cleared by writing a one to the corresponding bit. Auxiliary fault inputs to the CPU are tied to 0.</description>
          <fields>
            <field>
              <name>IMPDEF</name>
              <description>[31:0] Implementation defined. The bits map directly onto the signal assignment to the auxiliary fault inputs. Tied to 0</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ID_PFR0</name>
          <addressOffset>0xd40</addressOffset>
          <size>32</size>
          <description>Processor Feature 0</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>STATE1</name>
              <description>[7:4] State1 (T-bit == 1)

0x0: N/A
0x1: N/A
0x2: Thumb-2 encoding with the 16-bit basic instructions plus 32-bit Buncond/BL but no other 32-bit basic instructions (Note non-basic 32-bit instructions can be added using the appropriate instruction attribute, but other 32-bit basic instructions cannot.)
0x3: Thumb-2 encoding with all Thumb-2 basic instructions</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>STATE0</name>
              <description>[3:0] State0 (T-bit == 0)

0x0: No ARM encoding
0x1: N/A</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x30</resetValue>
        </register>
        <register>
          <name>ID_PFR1</name>
          <addressOffset>0xd44</addressOffset>
          <size>32</size>
          <description>Processor Feature 1</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>MICROCONTROLLER_PROGRAMMERS_MODEL</name>
              <description>[11:8] Microcontroller programmer's model

0x0: Not supported
0x2: Two-stack support</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[7:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x200</resetValue>
        </register>
        <register>
          <name>ID_DFR0</name>
          <addressOffset>0xd48</addressOffset>
          <size>32</size>
          <description>Debug Feature 0
This register provides a high level view of the debug system. Further details are provided in the debug infrastructure itself.</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>MICROCONTROLLER_DEBUG_MODEL</name>
              <description>[23:20] Microcontroller Debug Model - memory mapped

0x0: Not supported
0x1: Microcontroller debug v1 (ITMv1 and DWTv1)</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[19:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x100000</resetValue>
        </register>
        <register>
          <name>ID_AFR0</name>
          <addressOffset>0xd4c</addressOffset>
          <size>32</size>
          <description>Auxiliary Feature 0
This register provides some freedom for implementation defined features to be registered. Not used in Cortex-M.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ID_MMFR0</name>
          <addressOffset>0xd50</addressOffset>
          <size>32</size>
          <description>Memory Model Feature 0
General information on the memory model and memory management support.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x100030</resetValue>
        </register>
        <register>
          <name>ID_MMFR1</name>
          <addressOffset>0xd54</addressOffset>
          <size>32</size>
          <description>Memory Model Feature 1
General information on the memory model and memory management support.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ID_MMFR2</name>
          <addressOffset>0xd58</addressOffset>
          <size>32</size>
          <description>Memory Model Feature 2
General information on the memory model and memory management support.</description>
          <fields>
            <field>
              <name>RESERVED28</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>WAIT_FOR_INTERRUPT_STALLING</name>
              <description>[24:24] wait for interrupt stalling

0x0: Not supported
0x1: Wait for interrupt supported</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[23:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1000000</resetValue>
        </register>
        <register>
          <name>ID_MMFR3</name>
          <addressOffset>0xd5c</addressOffset>
          <size>32</size>
          <description>Memory Model Feature 3
General information on the memory model and memory management support.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ID_ISAR0</name>
          <addressOffset>0xd60</addressOffset>
          <size>32</size>
          <description>ISA Feature 0
Information on the instruction set attributes register</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1101110</resetValue>
        </register>
        <register>
          <name>ID_ISAR1</name>
          <addressOffset>0xd64</addressOffset>
          <size>32</size>
          <description>ISA Feature 1
Information on the instruction set attributes register</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x2111000</resetValue>
        </register>
        <register>
          <name>ID_ISAR2</name>
          <addressOffset>0xd68</addressOffset>
          <size>32</size>
          <description>ISA Feature 2
Information on the instruction set attributes register</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x21112231</resetValue>
        </register>
        <register>
          <name>ID_ISAR3</name>
          <addressOffset>0xd6c</addressOffset>
          <size>32</size>
          <description>ISA Feature 3
Information on the instruction set attributes register</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1111110</resetValue>
        </register>
        <register>
          <name>ID_ISAR4</name>
          <addressOffset>0xd70</addressOffset>
          <size>32</size>
          <description>ISA Feature 4
Information on the instruction set attributes register</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1310132</resetValue>
        </register>
        <register>
          <name>CPACR</name>
          <addressOffset>0xd88</addressOffset>
          <size>32</size>
          <description>Coprocessor Access Control
This register specifies the access privileges for coprocessors.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED6</name>
          <addressOffset>0xd90</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DHCSR</name>
          <addressOffset>0xdf0</addressOffset>
          <size>32</size>
          <description>Debug Halting Control and Status
The purpose of this register is to provide status information about the state of the processor, enable core debug, halt and step the processor. For writes, 0xA05F must be written to higher half-word of this register, otherwise the write operation is ignored and no bits are written into the register. If not enabled for Halting mode, C_DEBUGEN = 1, all other fields are disabled. This register is not reset on a core reset. It is reset by a power-on reset. However, C_HALT always clears on a core reset. To halt on a reset, the following bits must be enabled: DEMCR.VC_CORERESET and C_DEBUGEN. Note that writes to this register in any size other than word are unpredictable. It is acceptable to read in any size, and it can be used to avoid or intentionally change a sticky bit.

Behavior of the system when writing to this register while CPU is halted (i.e. C_DEBUGEN = 1 and S_HALT= 1):
C_HALT=0, C_STEP=0, C_MASKINTS=0               Exit Debug state and start instruction execution. Exceptions activate according to the exception configuration rules.
C_HALT=0, C_STEP=0, C_MASKINTS=1               Exit Debug state and start instruction execution. PendSV, SysTick and external configurable interrupts are disabled, otherwise exceptions activate according to standard configuration rules.
C_HALT=0, C_STEP=1, C_MASKINTS=0               Exit Debug state, step an instruction and halt. Exceptions activate according to the exception configuration rules.
C_HALT=0, C_STEP=1, C_MASKINTS=1               Exit Debug state, step an instruction and halt. PendSV, SysTick and external configurable interrupts are disabled, otherwise exceptions activate according to standard configuration rules.
C_HALT=1, C_STEP=x, C_MASKINTS=x               Remain in Debug state</description>
          <fields>
            <field>
              <name>RESERVED26</name>
              <description>[31:26] Software should not rely on the value of a reserved. 
When writing to this register, 0x28 must be written this bit-field, otherwise the write operation is ignored and no bits are written into the register.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>S_RESET_ST</name>
              <description>[25:25] Indicates that the core has been reset, or is now being reset, since the last time this bit was read. This a sticky bit that clears on read. So, reading twice and getting 1 then 0 means it was reset in the past. Reading twice and getting 1 both times means that it is being reset now (held in reset still).
When writing to this register, 0 must be written this bit-field, otherwise the write operation is ignored and no bits are written into the register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>S_RETIRE_ST</name>
              <description>[24:24] Indicates that an instruction has completed since last read. This is a sticky bit that clears on read. This determines if the core is stalled on a load/store or fetch.
When writing to this register, 0 must be written this bit-field, otherwise the write operation is ignored and no bits are written into the register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED20</name>
              <description>[23:20] Software should not rely on the value of a reserved. 
When writing to this register, 0x5 must be written this bit-field, otherwise the write operation is ignored and no bits are written into the register.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>S_LOCKUP</name>
              <description>[19:19] Reads as one if the core is running (not halted) and a lockup condition is present.
When writing to this register, 1 must be written this bit-field, otherwise the write operation is ignored and no bits are written into the register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>S_SLEEP</name>
              <description>[18:18] Indicates that the core is sleeping (WFI, WFE, or **SLEEP-ON-EXIT**). Must use C_HALT to gain control or wait for interrupt to wake-up.
When writing to this register, 1 must be written this bit-field, otherwise the write operation is ignored and no bits are written into the register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>S_HALT</name>
              <description>[17:17] The core is in debug state when this bit is set.
When writing to this register, 1 must be written this bit-field, otherwise the write operation is ignored and no bits are written into the register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>S_REGRDY</name>
              <description>[16:16] Register Read/Write on the Debug Core Register Selector register is available. Last transfer is complete.
When writing to this register, 1 must be written this bit-field, otherwise the write operation is ignored and no bits are written into the register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[15:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>C_SNAPSTALL</name>
              <description>[5:5] If the core is stalled on a load/store operation the stall ceases and the instruction is forced to complete. This enables Halting debug to gain control of the core. It can only be set if: C_DEBUGEN = 1 and C_HALT = 1. The core reads S_RETIRE_ST as 0. This indicates that no instruction has advanced. This prevents misuse. The bus state is Unpredictable when this is used. S_RETIRE_ST can detect core stalls on load/store operations.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[4:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>C_MASKINTS</name>
              <description>[3:3] Mask interrupts when stepping or running in halted debug. This masking does not affect NMI, fault exceptions and SVC caused by execution of the instructions. This bit must only be modified when the processor is halted (S_HALT == 1).  C_MASKINTS must be set or cleared before halt is released (i.e., the writes to set or clear C_MASKINTS and to set or clear C_HALT must be separate). Modifying C_MASKINTS while the system is running with halting debug support enabled (C_DEBUGEN = 1, S_HALT = 0) may cause unpredictable behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>C_STEP</name>
              <description>[2:2] Steps the core in halted debug. When C_DEBUGEN = 0, this bit has no effect. Must only be modified when the processor is halted (S_HALT == 1).
Modifying C_STEP while the system is running with halting debug support enabled (C_DEBUGEN = 1, S_HALT = 0) may cause unpredictable behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>C_HALT</name>
              <description>[1:1] Halts the core. This bit is set automatically when the core Halts. For example Breakpoint. This bit clears on core reset.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>C_DEBUGEN</name>
              <description>[0:0] Enables debug. This can only be written by AHB-AP and not by the core. It is ignored when written by the core, which cannot set or clear it. The core must write a 1 to it when writing C_HALT to halt itself.
The values of C_HALT, C_STEP and C_MASKINTS are ignored by hardware when C_DEBUGEN = 0. The read values for C_HALT, C_STEP and C_MASKINTS fields will be unknown to software when C_DEBUGEN = 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DCRSR</name>
          <addressOffset>0xdf4</addressOffset>
          <size>32</size>
          <description>Deubg Core Register Selector
The purpose of this register is to select the processor register to transfer data to or from. This write-only register generates a handshake to the core to transfer data to or from Debug Core Register Data Register and the selected register. Until this core transaction is complete, DHCSR.S_REGRDY is 0. Note that writes to this register in any size but word are Unpredictable. 
Note that PSR registers are fully accessible this way, whereas some read as 0 when using MRS instructions. Note that all bits can be written, but some combinations cause a fault when execution is resumed.</description>
          <fields>
            <field>
              <name>RESERVED17</name>
              <description>[31:17] Software should not rely on the value of a reserved. Write 0.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>REGWNR</name>
              <description>[16:16] 1: Write
0: Read</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[15:5] Software should not rely on the value of a reserved. Write 0.</description>
              <bitWidth>11</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>REGSEL</name>
              <description>[4:0] Register select

0x00: R0
0x01: R1
0x02: R2
0x03: R3
0x04: R4
0x05: R5
0x06: R6
0x07: R7
0x08: R8
0x09: R9
0x0A: R10
0x0B: R11
0x0C: R12
0x0D: Current SP
0x0E: LR
0x0F: DebugReturnAddress
0x10: XPSR/flags, execution state information, and exception number
0x11: MSP (Main SP)
0x12: PSP (Process SP)
0x14: CONTROL&lt;&lt;24 | FAULTMASK&lt;&lt;16 | BASEPRI&lt;&lt;8 | PRIMASK</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DCRDR</name>
          <addressOffset>0xdf8</addressOffset>
          <size>32</size>
          <description>Debug Core Register Data</description>
          <fields>
            <field>
              <name>DCRDR</name>
              <description>[31:0] This register holds data for reading and writing registers to and from the processor. This is the data value written to the register selected by DCRSR. When the processor receives a request from DCRSR, this register is read or written by the processor using a normal load-store unit operation. If core register transfers are not being performed, software-based debug monitors can use this register for communication in non-halting debug. This enables flags and bits to acknowledge state and indicate if commands have been accepted to, replied to, or accepted and replied to.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DEMCR</name>
          <addressOffset>0xdfc</addressOffset>
          <size>32</size>
          <description>Debug Exception and Monitor Control
The purpose of this register is vector catching and debug monitor control.  This register manages exception behavior under debug. Vector catching is only available to halting debug. The upper halfword is for monitor controls and the lower halfword is for halting exception support. This register is not reset on a system reset. This register is reset by a power-on reset. The fields MON_EN, MON_PEND, MON_STEP and MON_REQ are always cleared on a core reset. The debug monitor is enabled by software in the reset handler or later, or by the **AHB-AP** port. Vector catching is semi-synchronous. When a matching event is seen, a Halt is requested. Because the processor can only halt on an instruction boundary, it must wait until the next instruction boundary. As a result, it stops on the first instruction of the exception handler. However, two special cases exist when a vector catch has triggered: 1. If a fault is taken during a vector read or stack push error the halt occurs on the corresponding fault handler for the vector error or stack push. 2. If a late arriving interrupt detected during a vector read or stack push error it is not taken. That is, an implementation that supports the late arrival optimization must suppress it in this case.</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>TRCENA</name>
              <description>[24:24] This bit must be set to 1 to enable use of the trace and debug blocks: DWT, ITM, ETM and TPIU. This enables control of power usage unless tracing is required. The application can enable this, for ITM use, or use by a debugger.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED20</name>
              <description>[23:20] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>MON_REQ</name>
              <description>[19:19] This enables the monitor to identify how it wakes up. This bit clears on a Core Reset.

0x0: Woken up by debug exception.
0x1: Woken up by MON_PEND</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>MON_STEP</name>
              <description>[18:18] When MON_EN = 1, this steps the core. When MON_EN = 0, this bit is ignored. 
This is the equivalent to DHCSR.C_STEP. Interrupts are only stepped according to the priority of the monitor and settings of PRIMASK, FAULTMASK, or BASEPRI.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>MON_PEND</name>
              <description>[17:17] Pend the monitor to activate when priority permits. This can wake up the monitor through the AHB-AP port. It is the equivalent to DHCSR.C_HALT for Monitor debug. This register does not reset on a system reset. It is only reset by a power-on reset. Software in the reset handler or later, or by the DAP must enable the debug monitor.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>MON_EN</name>
              <description>[16:16] Enable the debug monitor. 
When enabled, the System handler priority register controls its priority level. If disabled, then all debug events go to Hard fault. DHCSR.C_DEBUGEN overrides this bit. Vector catching is semi-synchronous. When a matching event is seen, a Halt is requested. Because the processor can only halt on an instruction boundary, it must wait until the next instruction boundary. As a result, it stops on the first instruction of the exception handler. However, two special cases exist when a vector catch has triggered: 1. If a fault is taken during vectoring, vector read or stack push error, the halt occurs on the corresponding fault handler, for the vector error or stack push. 2. If a late arriving interrupt comes in during vectoring, it is not taken. That is, an implementation that supports the late arrival optimization must suppress it in this case.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED11</name>
              <description>[15:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>VC_HARDERR</name>
              <description>[10:10] Debug trap on Hard Fault. Ignored when DHCSR.C_DEBUGEN is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>VC_INTERR</name>
              <description>[9:9] Debug trap on a fault occurring during an exception entry or return sequence. Ignored when DHCSR.C_DEBUGEN is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>VC_BUSERR</name>
              <description>[8:8] Debug Trap on normal Bus error. Ignored when DHCSR.C_DEBUGEN is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VC_STATERR</name>
              <description>[7:7] Debug trap on Usage Fault state errors. Ignored when DHCSR.C_DEBUGEN is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>VC_CHKERR</name>
              <description>[6:6] Debug trap on Usage Fault enabled checking errors. Ignored when DHCSR.C_DEBUGEN is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>VC_NOCPERR</name>
              <description>[5:5] Debug trap on a UsageFault access to a Coprocessor. Ignored when DHCSR.C_DEBUGEN is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>VC_MMERR</name>
              <description>[4:4] Debug trap on Memory Management faults. Ignored when DHCSR.C_DEBUGEN is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[3:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>VC_CORERESET</name>
              <description>[0:0] Reset Vector Catch. Halt running system if Core reset occurs. Ignored when DHCSR.C_DEBUGEN is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STIR</name>
          <addressOffset>0xf00</addressOffset>
          <size>32</size>
          <description>Software Trigger Interrupt</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Software should not rely on the value of a reserved. Write 0.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>INTID</name>
              <description>[8:0] Interrupt ID field. Writing a value to this bit-field is the same as manually pending an interrupt by setting the corresponding interrupt bit in an Interrupt Set Pending Register in NVIC_ISPR0 or NVIC_ISPR1.</description>
              <bitWidth>9</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPU_TIPROP</name>
      <baseAddress>0xE00FE000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Cortex-M's TI proprietary registers</description>
      <registers>
        <register>
          <name>RESERVED000</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TRACECLKMUX</name>
          <addressOffset>0xff8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TRACECLK_N_SWV</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TRACECLK</name>
                  <value>1</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SWV</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DYN_CG</name>
          <addressOffset>0xffc</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DYN_CG</name>
              <description>[1:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPU_TPIU</name>
      <baseAddress>0xE0040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Cortex-M3's Trace Port Interface Unit (TPIU)</description>
      <registers>
        <register>
          <name>SSPSR</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Supported Sync Port Sizes
This register represents a single port size that is supported on the device, that is, 4, 2 or 1. This is to ensure that tools do not attempt to select a port width that an attached TPA cannot capture.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>FOUR</name>
              <description>[3:3] 4-bit port size support

0x0: Not supported
0x1: Supported</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>THREE</name>
              <description>[2:2] 3-bit port size support

0x0: Not supported
0x1: Supported</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TWO</name>
              <description>[1:1] 2-bit port size support

0x0: Not supported
0x1: Supported</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ONE</name>
              <description>[0:0] 1-bit port size support

0x0: Not supported
0x1: Supported</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xB</resetValue>
        </register>
        <register>
          <name>CSPSR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Current Sync Port Size
This register has the same format as SSPSR but only one bit can be set, and all others must be zero. Writing values with more than one bit set, or setting a bit that is not indicated as supported can cause Unpredictable behavior. On reset this defaults to the smallest possible port size, 1 bit.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>FOUR</name>
              <description>[3:3] 4-bit port enable
Writing values with more than one bit set in CSPSR, or setting a bit that is not indicated as supported in SSPSR can cause Unpredictable behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>THREE</name>
              <description>[2:2] 3-bit port enable
Writing values with more than one bit set in CSPSR, or setting a bit that is not indicated as supported in SSPSR can cause Unpredictable behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TWO</name>
              <description>[1:1] 2-bit port enable
Writing values with more than one bit set in CSPSR, or setting a bit that is not indicated as supported in SSPSR can cause Unpredictable behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ONE</name>
              <description>[0:0] 1-bit port enable
Writing values with more than one bit set in CSPSR, or setting a bit that is not indicated as supported in SSPSR can cause Unpredictable behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>ACPR</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Async Clock Prescaler
This register scales the baud rate of the asynchronous output.</description>
          <fields>
            <field>
              <name>RESERVED13</name>
              <description>[31:13] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>19</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PRESCALER</name>
              <description>[12:0] Divisor for input trace clock is (PRESCALER + 1).</description>
              <bitWidth>13</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SPPR</name>
          <addressOffset>0xf0</addressOffset>
          <size>32</size>
          <description>Selected Pin Protocol
This register selects the protocol to be used for trace output. 
Note: If this register is changed while trace data is being output, data corruption occurs.</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PROTOCOL</name>
              <description>[1:0] Trace output protocol</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SWO_NRZ</name>
                  <value>2</value>
                  <description>SerialWire Output (NRZ)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SWO_MANCHESTER</name>
                  <value>1</value>
                  <description>SerialWire Output (Manchester). This is the reset value.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TRACEPORT</name>
                  <value>0</value>
                  <description>TracePort mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>FFSR</name>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <description>Formatter and Flush Status</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>FTNONSTOP</name>
              <description>[3:3] 0: Formatter can be stopped
1: Formatter cannot be stopped</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[2:0] This field always reads as zero</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x8</resetValue>
        </register>
        <register>
          <name>FFCR</name>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <description>Formatter and Flush Control
When one of the two single wire output (SWO) modes is selected, ENFCONT enables the formatter to be bypassed. If the formatter is bypassed, only the ITM/DWT trace source (ATDATA2) passes through. The TPIU accepts and discards data that is presented on the ETM port (ATDATA1). This function is intended to be used when it is necessary to connect a device containing an ETM to a trace capture device that is only able to capture Serial Wire Output (SWO) data. Enabling or disabling the formatter causes momentary data corruption. 
Note: If the selected pin protocol register (SPPR.PROTOCOL) is set to 0x00 (TracePort mode), this register always reads 0x102, because the formatter is automatically enabled. If one of the serial wire modes is then selected, the register reverts to its previously programmed value.</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TRIGIN</name>
              <description>[8:8] Indicates that triggers are inserted when a trigger pin is asserted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[7:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ENFCONT</name>
              <description>[1:1] Enable continuous formatting:

0: Continuous formatting disabled
1: Continuous formatting enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x102</resetValue>
        </register>
        <register>
          <name>FSCR</name>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <description>Formatter Synchronization Counter</description>
          <fields>
            <field>
              <name>FSCR</name>
              <description>[31:0] The global synchronization trigger is generated by the Program Counter (PC) Sampler block. This means that there is no synchronization counter in the TPIU.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CLAIMMASK</name>
          <addressOffset>0xfa0</addressOffset>
          <size>32</size>
          <description>Claim Tag Mask</description>
          <fields>
            <field>
              <name>CLAIMMASK</name>
              <description>[31:0] This register forms one half of the Claim Tag value. When reading this register returns the number of bits that can be set (each bit is considered separately):

0: This claim tag bit is not implemented
1: This claim tag bit is not implemented

The behavior when writing to this register is described in CLAIMSET.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xF</resetValue>
        </register>
        <register>
          <name>CLAIMSET</name>
          <addressOffset>0xfa0</addressOffset>
          <size>32</size>
          <description>Claim Tag Set</description>
          <fields>
            <field>
              <name>CLAIMSET</name>
              <description>[31:0] This register forms one half of the Claim Tag value. Writing to this location allows individual bits to be set (each bit is considered separately):

0: No effect
1: Set this bit in the claim tag

The behavior when reading from this location is described in CLAIMMASK.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xF</resetValue>
        </register>
        <register>
          <name>CLAIMTAG</name>
          <addressOffset>0xfa4</addressOffset>
          <size>32</size>
          <description>Current Claim Tag</description>
          <fields>
            <field>
              <name>CLAIMTAG</name>
              <description>[31:0] This register forms one half of the Claim Tag value. Reading this register returns the current Claim Tag value. 
Reading CLAIMMASK determines how many bits from this register must be used.

The behavior when writing to this register is described in CLAIMCLR.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CLAIMCLR</name>
          <addressOffset>0xfa4</addressOffset>
          <size>32</size>
          <description>Claim Tag Clear</description>
          <fields>
            <field>
              <name>CLAIMCLR</name>
              <description>[31:0] This register forms one half of the Claim Tag value. Writing to this location enables individual bits to be cleared (each bit is considered separately):

0: No effect
1: Clear this bit in the claim tag.

The behavior when reading from this location is described in CLAIMTAG.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DEVID</name>
          <addressOffset>0xfc8</addressOffset>
          <size>32</size>
          <description>Device ID</description>
          <fields>
            <field>
              <name>DEVID</name>
              <description>[31:0] This field returns: 0xCA1 if there is an ETM present. 0xCA0 if there is no ETM present.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xCA0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRYPTO</name>
      <baseAddress>0x40024000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x800</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Crypto core with DMA capability and local key storage</description>
      <registers>
        <register>
          <name>DMACH0CTL</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>DMA Channel 0 Control</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PRIO</name>
              <description>[1:1] Channel priority:

A channel with high priority will be served before a channel with low priority in cases with simultaneous access requests. If both channels have the same priority access of the channels to the external port is arbitrated using a Round Robin scheme.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>1</value>
                  <description>Priority high</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>0</value>
                  <description>Priority low</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] DMA Channel 0 Control</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Channel enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Channel disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMACH0EXTADDR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>DMA Channel 0 External Address</description>
          <fields>
            <field>
              <name>ADDR</name>
              <description>[31:0] Channel external address value.
Holds the last updated external address after being sent to the master interface.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMACH0LEN</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>DMA Channel 0 Length</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LEN</name>
              <description>[15:0] DMA transfer length in bytes.
During configuration, this register contains the DMA transfer length in bytes. During operation, it contains the last updated value of the DMA transfer length after being sent to the master interface.
Note: Writing a non-zero value to this register field starts the transfer if the channel is enabled by setting DMACH0CTL.EN.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMASTAT</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>DMA Controller Status</description>
          <fields>
            <field>
              <name>RESERVED18</name>
              <description>[31:18] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>14</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PORT_ERR</name>
              <description>[17:17] Reflects possible transfer errors on the AHB port.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[16:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CH1_ACTIVE</name>
              <description>[1:1] This register field indicates if DMA channel 1 is active or not.
0: Not active
1: Active</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CH0_ACTIVE</name>
              <description>[0:0] This register field indicates if DMA channel 0 is active or not.
0: Not active
1: Active</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMASWRESET</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>DMA Controller Software Reset</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESET</name>
              <description>[0:0] Software reset enable 

0:  Disable
1:  Enable (self-cleared to zero).

Note: Completion of the software reset must be checked in DMASTAT.CH0_ACTIVE and DMASTAT.CH1_ACTIVE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMACH1CTL</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>DMA Channel 1 Control</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PRIO</name>
              <description>[1:1] Channel priority:

A channel with high priority will be served before a channel with low priority in cases with simultaneous access requests. If both channels have the same priority access of the channels to the external port is arbitrated using a Round Robin scheme.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>1</value>
                  <description>Priority high</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>0</value>
                  <description>Priority low</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] Channel enable:

Note: Disabling an active channel will interrupt the DMA operation. The ongoing block transfer will be completed, but no new transfers will be requested.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Channel enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Channel disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMACH1EXTADDR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>DMA Channel 1 External Address</description>
          <fields>
            <field>
              <name>ADDR</name>
              <description>[31:0] Channel external address value.
Holds the last updated external address after being sent to the master interface.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMACH1LEN</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>DMA Channel 1 Length</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LEN</name>
              <description>[15:0] DMA transfer length in bytes.
During configuration, this register contains the DMA transfer length in bytes. During operation, it contains the last updated value of the DMA transfer length after being sent to the master interface.
Note: Writing a non-zero value to this register field starts the transfer if the channel is enabled by setting DMACH1CTL.EN.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMABUSCFG</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>DMA Controller Master Configuration</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>AHB_MST1_BURST_SIZE</name>
              <description>[15:12] Maximum burst size that can be performed on the AHB bus</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>64_BYTE</name>
                  <value>6</value>
                  <description>64 bytes</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>32_BYTE</name>
                  <value>5</value>
                  <description>32 bytes</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>16_BYTE</name>
                  <value>4</value>
                  <description>16 bytes</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8_BYTE</name>
                  <value>3</value>
                  <description>8 bytes</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4_BYTE</name>
                  <value>2</value>
                  <description>4 bytes</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AHB_MST1_IDLE_EN</name>
              <description>[11:11] Idle transfer insertion between consecutive burst transfers on AHB</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <value>1</value>
                  <description>Idle transfer insertion enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NO_IDLE</name>
                  <value>0</value>
                  <description>Do not insert idle transfers.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AHB_MST1_INCR_EN</name>
              <description>[10:10] Burst length type of AHB transfer</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPECIFIED</name>
                  <value>1</value>
                  <description>Fixed length bursts or single transfers</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNSPECIFIED</name>
                  <value>0</value>
                  <description>Unspecified length burst transfers</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AHB_MST1_LOCK_EN</name>
              <description>[9:9] Locked transform on AHB</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOCKED</name>
                  <value>1</value>
                  <description>Transfers are locked</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_LOCKED</name>
                  <value>0</value>
                  <description>Transfers are not locked</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AHB_MST1_BIGEND</name>
              <description>[8:8] Endianess for the AHB master</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIG_ENDIAN</name>
                  <value>1</value>
                  <description>Big Endian</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LITTLE_ENDIAN</name>
                  <value>0</value>
                  <description>Little Endian</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[7:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x2400</resetValue>
        </register>
        <register>
          <name>DMAPORTERR</name>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <description>DMA Controller Port Error</description>
          <fields>
            <field>
              <name>RESERVED13</name>
              <description>[31:13] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>19</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>AHB_ERR</name>
              <description>[12:12] A 1 indicates that the Crypto peripheral has detected an AHB bus error</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RESERVED10</name>
              <description>[11:10] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>LAST_CH</name>
              <description>[9:9] Indicates which channel was serviced last (channel 0 or channel 1) by the AHB master port.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[8:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>9</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMAHWVER</name>
          <addressOffset>0xfc</addressOffset>
          <size>32</size>
          <description>DMA Controller Version</description>
          <fields>
            <field>
              <name>RESERVED28</name>
              <description>[31:28] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>HW_MAJOR_VER</name>
              <description>[27:24] Major version number</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>HW_MINOR_VER</name>
              <description>[23:20] Minor version number</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>HW_PATCH_LVL</name>
              <description>[19:16] Patch level.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VER_NUM_COMPL</name>
              <description>[15:8] Bit-by-bit complement of the VER_NUM field bits.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VER_NUM</name>
              <description>[7:0] Version number of the DMA Controller (209)</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1012ED1</resetValue>
        </register>
        <register>
          <name>KEYWRITEAREA</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>Key Write Area</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RAM_AREA7</name>
              <description>[7:7] Represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written.

Writing to multiple RAM locations is only possible when the selected RAM areas are sequential.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL</name>
                  <value>1</value>
                  <description>This RAM area is selected to be written</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_SEL</name>
                  <value>0</value>
                  <description>This RAM area is not selected to be written</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA6</name>
              <description>[6:6] Represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written.

Writing to multiple RAM locations is only possible when the selected RAM areas are sequential.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL</name>
                  <value>1</value>
                  <description>This RAM area is selected to be written</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_SEL</name>
                  <value>0</value>
                  <description>This RAM area is not selected to be written</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA5</name>
              <description>[5:5] Represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written.

Writing to multiple RAM locations is only possible when the selected RAM areas are sequential.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL</name>
                  <value>1</value>
                  <description>This RAM area is selected to be written</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_SEL</name>
                  <value>0</value>
                  <description>This RAM area is not selected to be written</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA4</name>
              <description>[4:4] Represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written.

Writing to multiple RAM locations is only possible when the selected RAM areas are sequential.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL</name>
                  <value>1</value>
                  <description>This RAM area is selected to be written</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_SEL</name>
                  <value>0</value>
                  <description>This RAM area is not selected to be written</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA3</name>
              <description>[3:3] Represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written.

Writing to multiple RAM locations is only possible when the selected RAM areas are sequential.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL</name>
                  <value>1</value>
                  <description>This RAM area is selected to be written</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_SEL</name>
                  <value>0</value>
                  <description>This RAM area is not selected to be written</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA2</name>
              <description>[2:2] Represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written.

Writing to multiple RAM locations is only possible when the selected RAM areas are sequential.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL</name>
                  <value>1</value>
                  <description>This RAM area is selected to be written</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_SEL</name>
                  <value>0</value>
                  <description>This RAM area is not selected to be written</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA1</name>
              <description>[1:1] Represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written.

Writing to multiple RAM locations is only possible when the selected RAM areas are sequential.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL</name>
                  <value>1</value>
                  <description>This RAM area is selected to be written</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_SEL</name>
                  <value>0</value>
                  <description>This RAM area is not selected to be written</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA0</name>
              <description>[0:0] Represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written.

Writing to multiple RAM locations is only possible when the selected RAM areas are sequential.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL</name>
                  <value>1</value>
                  <description>This RAM area is selected to be written</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_SEL</name>
                  <value>0</value>
                  <description>This RAM area is not selected to be written</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>KEYWRITTENAREA</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>Key Written Area Status
This register shows which areas of the key store RAM contain valid written keys.
When a new key needs to be written to the key store, on a location that is already occupied by a valid key, this key area must be cleared first. This can be done by writing this register before the new key is written to the key store memory.
Attempting to write to a key area that already contains a valid key is not allowed and will result in an error.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN7</name>
              <description>[7:7] On read this bit returns the key area written status.

This bit can be reset by writing a 1.

Note: This register will be reset on a soft reset initiated by writing to DMASWRESET.RESET. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WRITTEN</name>
                  <value>1</value>
                  <description>This RAM area is written with valid key information</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_WRITTEN</name>
                  <value>0</value>
                  <description>This RAM area is not written with valid key information</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN6</name>
              <description>[6:6] On read this bit returns the key area written status.

This bit can be reset by writing a 1.

Note: This register will be reset on a soft reset initiated by writing to DMASWRESET.RESET. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WRITTEN</name>
                  <value>1</value>
                  <description>This RAM area is written with valid key information</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_WRITTEN</name>
                  <value>0</value>
                  <description>This RAM area is not written with valid key information</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN5</name>
              <description>[5:5] On read this bit returns the key area written status.

This bit can be reset by writing a 1.

Note: This register will be reset on a soft reset initiated by writing to DMASWRESET.RESET. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WRITTEN</name>
                  <value>1</value>
                  <description>This RAM area is written with valid key information</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_WRITTEN</name>
                  <value>0</value>
                  <description>This RAM area is not written with valid key information</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN4</name>
              <description>[4:4] On read this bit returns the key area written status.

This bit can be reset by writing a 1.

Note: This register will be reset on a soft reset initiated by writing to DMASWRESET.RESET. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WRITTEN</name>
                  <value>1</value>
                  <description>This RAM area is written with valid key information</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_WRITTEN</name>
                  <value>0</value>
                  <description>This RAM area is not written with valid key information</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN3</name>
              <description>[3:3] On read this bit returns the key area written status.

This bit can be reset by writing a 1.

Note: This register will be reset on a soft reset initiated by writing to DMASWRESET.RESET. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WRITTEN</name>
                  <value>1</value>
                  <description>This RAM area is written with valid key information</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_WRITTEN</name>
                  <value>0</value>
                  <description>This RAM area is not written with valid key information</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN2</name>
              <description>[2:2] On read this bit returns the key area written status.

This bit can be reset by writing a 1.

Note: This register will be reset on a soft reset initiated by writing to DMASWRESET.RESET. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WRITTEN</name>
                  <value>1</value>
                  <description>This RAM area is written with valid key information</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_WRITTEN</name>
                  <value>0</value>
                  <description>This RAM area is not written with valid key information</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN1</name>
              <description>[1:1] On read this bit returns the key area written status.

This bit can be reset by writing a 1.

Note: This register will be reset on a soft reset initiated by writing to DMASWRESET.RESET. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WRITTEN</name>
                  <value>1</value>
                  <description>This RAM area is written with valid key information</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_WRITTEN</name>
                  <value>0</value>
                  <description>This RAM area is not written with valid key information</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RAM_AREA_WRITTEN0</name>
              <description>[0:0] On read this bit returns the key area written status.


This bit can be reset by writing a 1.

Note: This register will be reset on a soft reset initiated by writing to DMASWRESET.RESET. After a soft reset, all keys must be rewritten to the key store memory.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WRITTEN</name>
                  <value>1</value>
                  <description>This RAM area is written with valid key information</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOT_WRITTEN</name>
                  <value>0</value>
                  <description>This RAM area is not written with valid key information</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>KEYSIZE</name>
          <addressOffset>0x408</addressOffset>
          <size>32</size>
          <description>Key Size
This register defines the size of the keys that are written with DMA.</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SIZE</name>
              <description>[1:0] Key size

When writing to this register, KEYWRITTENAREA will be reset.

Note: For the Crypto peripheral this field is fixed to 128 bits. For software compatibility KEYWRITTENAREA will  be reset when writing to this register.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>256_BIT</name>
                  <value>3</value>
                  <description>Not supported</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>192_BIT</name>
                  <value>2</value>
                  <description>Not supported</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>128_BIT</name>
                  <value>1</value>
                  <description>128 bits</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>KEYREADAREA</name>
          <addressOffset>0x40c</addressOffset>
          <size>32</size>
          <description>Key Read Area</description>
          <fields>
            <field>
              <name>BUSY</name>
              <description>[31:31] Key store operation busy status flag (read only)

0: operation is completed.
1: operation is not completed and the key store is busy.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[30:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RAM_AREA</name>
              <description>[3:0] Selects the area of the key store RAM from where the key needs to be read that will be written to the AES engine.

Only RAM areas that contain valid written keys can be selected.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_RAM</name>
                  <value>8</value>
                  <description>No RAM</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RAM_AREA7</name>
                  <value>7</value>
                  <description>RAM Area 7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RAM_AREA6</name>
                  <value>6</value>
                  <description>RAM Area 6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RAM_AREA5</name>
                  <value>5</value>
                  <description>RAM Area 5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RAM_AREA4</name>
                  <value>4</value>
                  <description>RAM Area 4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RAM_AREA3</name>
                  <value>3</value>
                  <description>RAM Area 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RAM_AREA2</name>
                  <value>2</value>
                  <description>RAM Area 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RAM_AREA1</name>
                  <value>1</value>
                  <description>RAM Area 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RAM_AREA0</name>
                  <value>0</value>
                  <description>RAM Area 0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x8</resetValue>
        </register>
        <register>
          <name>AESKEY2</name>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <description>Clear AES_KEY2/GHASH Key</description>
          <fields>
            <field>
              <name>KEY2</name>
              <description>[31:0] AESKEY2.* bits 31+x:0+x or AES_GHASH_H.* bits 31+x:0+x, where x = 0, 32, 64, 96 ordered from the LSW entry of this 4-deep register array.
The interpretation of this field depends on the crypto operation mode.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESKEY3</name>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <description>Clear AES_KEY3</description>
          <fields>
            <field>
              <name>KEY3</name>
              <description>[31:0] AESKEY3.* bits 31+x:0+x or AESKEY2.* bits 159+x:128+x, where x = 0, 32, 64, 96 ordered from the LSW entry of this 4-deep register arrary.
The interpretation of this field depends on the crypto operation mode.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESIV</name>
          <addressOffset>0x540</addressOffset>
          <size>32</size>
          <description>AES Initialization Vector</description>
          <fields>
            <field>
              <name>IV</name>
              <description>[31:0] The interpretation of this field depends on the crypto operation mode.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESCTL</name>
          <addressOffset>0x550</addressOffset>
          <size>32</size>
          <description>AES Input/Output Buffer Control</description>
          <fields>
            <field>
              <name>CONTEXT_RDY</name>
              <description>[31:31] If 1, this status bit indicates that the context data registers can be overwritten and the Host is permitted to write the next context.  Writing a context means writing either a mode, the crypto length or AESDATALEN1.LEN_MSW, AESDATALEN0.LEN_LSW length registers</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>SAVED_CONTEXT_RDY</name>
              <description>[30:30] If read as 1, this status bit indicates that an AES authentication TAG and/or IV block(s) is/are available for the Host to retrieve. This bit is only asserted if SAVE_CONTEXT is set to 1. The bit is mutually exclusive with CONTEXT_RDY.

Writing 1 clears the bit to zero, indicating the Crypto peripheral can start its next operation. This bit is also cleared when the 4th word of the output TAG and/or IV is read.

Note: All other mode bit writes will be ignored when this mode bit is written with 1.

Note: This bit is controlled automatically by the Crypto peripheral for TAG read DMA operations.

For typical use, this bit does NOT need to be written, but is used for status reading only. In this case, this status bit is automatically maintained by the Crypto peripheral.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>SAVE_CONTEXT</name>
              <description>[29:29] IV must be read before the AES engine can start a new operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>RESERVED25</name>
              <description>[28:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>CCM_M</name>
              <description>[24:22] Defines M that indicates the length of the authentication field for CCM operations; the authentication field length equals two times the value of CCM_M plus one.
Note: The Crypto peripheral always returns a 128-bit authentication field, of which the M least significant bytes are valid. All values are supported.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>CCM_L</name>
              <description>[21:19] Defines L that indicates the width of the length field for CCM operations; the length field in bytes equals the value of CMM_L plus one. All values are supported.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CCM</name>
              <description>[18:18] AES-CCM mode enable.
AES-CCM is a combined mode, using AES for both authentication and encryption.
Note: Selecting AES-CCM mode requires writing of AESDATALEN1.LEN_MSW and AESDATALEN0.LEN_LSW  after all other registers.
Note: The CTR mode bit in this register must also be set to 1 to enable AES-CTR; selecting other AES modes than CTR mode is invalid.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[17:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CBC_MAC</name>
              <description>[15:15] MAC mode enable.
The DIR bit must be set to 1 for this mode.
Selecting this mode requires writing the AESDATALEN1.LEN_MSW and AESDATALEN0.LEN_LSW registers after all other registers.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[14:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>CTR_WIDTH</name>
              <description>[8:7] Specifies the counter width for AES-CTR mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>128_BIT</name>
                  <value>3</value>
                  <description>128 bits</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>96_BIT</name>
                  <value>2</value>
                  <description>96 bits</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>64_BIT</name>
                  <value>1</value>
                  <description>64 bits</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>32_BIT</name>
                  <value>0</value>
                  <description>32 bits</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CTR</name>
              <description>[6:6] AES-CTR mode enable
This bit must also be set for CCM, when encryption/decryption is required.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>CBC</name>
              <description>[5:5] CBC mode enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>KEY_SIZE</name>
              <description>[4:3] This field specifies the key size.
The key size is automatically configured when a new key is loaded via the key store module.
00 = N/A - reserved
01 = 128 bits
10 = N/A - reserved
11 = N/A - reserved
For the Crypto peripheral this field is fixed to 128 bits.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DIR</name>
              <description>[2:2] Direction.
0 : Decrypt operation is performed.
1 : Encrypt operation is performed.

This bit must be written with a 1 when CBC-MAC is selected.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>INPUT_RDY</name>
              <description>[1:1] If read as 1, this status bit indicates that the 16-byte AES input buffer is empty. The Host is permitted to write the next block of data.

Writing a 0 clears the bit to zero and indicates that the AES engine can use the provided input data block.

Writing a 1 to this bit will be ignored.

Note: For DMA operations, this bit is automatically controlled by the Crypto peripheral.
After reset, this bit is 0. After writing a context (note 1), this bit will become 1.

For typical use, this bit does NOT need to be written, but is used for status reading only. In this case, this status bit is automatically maintained by the Crypto peripheral.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>OUTPUT_RDY</name>
              <description>[0:0] If read as 1, this status bit indicates that an AES output block is available to be retrieved by the Host.

Writing a 0 clears the bit to zero and indicates that output data is read by the Host. The AES engine can provide a next output data block.

Writing a 1 to this bit will be ignored.

Note: For DMA operations, this bit is automatically controlled by the Crypto peripheral.

For typical use, this bit does NOT need to be written, but is used for status reading only. In this case, this status bit is automatically maintained by the Crypto peripheral.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x80000000</resetValue>
        </register>
        <register>
          <name>AESDATALEN0</name>
          <addressOffset>0x554</addressOffset>
          <size>32</size>
          <description>Crypto Data Length LSW</description>
          <fields>
            <field>
              <name>LEN_LSW</name>
              <description>[31:0] Used to write the Length values to the Crypto peripheral.  

This register contains bits [31:0] of the combined data length.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESDATALEN1</name>
          <addressOffset>0x558</addressOffset>
          <size>32</size>
          <description>Crypto Data Length MSW</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:29] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>LEN_MSW</name>
              <description>[28:0] Bits [60:32] of the combined data length.

Bits [60:0] of the crypto length registers AESDATALEN1 and AESDATALEN0 store the cryptographic data length in bytes for all modes. Once processing with this context is started, this length decrements to zero. Data lengths up to (2^61 - 1) bytes are allowed.
For GCM, any value up to 2^36 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 2^32 - 2, resulting in a maximum number of bytes of 2^36 - 32.
Writing to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM.
Note: For the combined modes (GCM and CCM), this length does not include the authentication only data; the authentication length is specified in the AESAUTHLEN.LEN.
All modes must have a length > 0. For the combined modes, it is allowed to have one of the lengths equal to zero.
For the basic encryption modes (ECB/CBC/CTR) it is allowed to program zero to the length field; in that case the length is assumed infinite.
All data must be byte (8-bit) aligned for stream cipher modes; bit aligned data streams are not supported by the Crypto peripheral. For block cipher modes, the data length must be programmed in multiples of the block cipher size, 16 bytes.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESAUTHLEN</name>
          <addressOffset>0x55c</addressOffset>
          <size>32</size>
          <description>AES Authentication Length</description>
          <fields>
            <field>
              <name>LEN</name>
              <description>[31:0] Authentication data length in bytes for combined mode, CCM only.
Supported AAD-lengths for CCM are from 0 to (216 - 28) bytes. Once processing with this context is started, this length decrements to zero.
Writing this register triggers the engine to start using this context for CCM.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESDATAOUT0</name>
          <addressOffset>0x560</addressOffset>
          <size>32</size>
          <description>Data Input/Output</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[31:0] Data register 0 for output block data from the Crypto peripheral.
These bits = AES Output Data[31:0] of {127:0]

For normal operations, this register is not used, since data input and output is transferred from and to the AES engine via DMA.

For a Host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range will read one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, AESCTL.OUTPUT_RDY must be written.
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.

Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESDATAIN0</name>
          <addressOffset>0x560</addressOffset>
          <size>32</size>
          <description>AES Data Input/Output 0</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[31:0] Data registers for input block data to the Crypto peripheral.
These bits = AES Input Data[31:0]  of [127:0]

For normal operations, this register is not used, since data input and output is transferred from and to the AES engine via DMA.

For a Host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range will store the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to AESCTL.INPUT_RDY.

Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]): 0 &lt; n &lt;= 128 bits. For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The Crypto peripheral automatically pads or masks misaligned ending data blocks with zeroes for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESDATAOUT1</name>
          <addressOffset>0x564</addressOffset>
          <size>32</size>
          <description>AES Data Input/Output 3</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[31:0] Data registers for output block data from the Crypto peripheral.
These bits = AES Output Data[63:32] of [127:0]

For normal operations, this register is not used, since data input and output is transferred from and to the AES engine via DMA.

For a Host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range will read one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, AESCTL.OUTPUT_RDY must be written.
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.

Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESDATAIN1</name>
          <addressOffset>0x564</addressOffset>
          <size>32</size>
          <description>AES Data Input/Output 1</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[31:0] Data registers for input block data to the Crypto peripheral.
These bits = AES Input Data[63:32]  of [127:0]

For normal operations, this register is not used, since data input and output is transferred from and to the AES engine via DMA.

For a Host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range will store the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to AESCTL.INPUT_RDY.

Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]): 0 &lt; n &lt;= 128 bits. For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The Crypto peripheral automatically pads or masks misaligned ending data blocks with zeroes for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESDATAOUT2</name>
          <addressOffset>0x568</addressOffset>
          <size>32</size>
          <description>AES Data Input/Output 2</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[31:0] Data registers for output block data from the Crypto peripheral.
These bits = AES Output Data[95:64] of [127:0]

For normal operations, this register is not used, since data input and output is transferred from and to the AES engine via DMA.

For a Host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range will read one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, AESCTL.OUTPUT_RDY must be written.
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.

Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESDATAIN2</name>
          <addressOffset>0x568</addressOffset>
          <size>32</size>
          <description>AES Data Input/Output 2</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[31:0] Data registers for input block data to the Crypto peripheral.
These bits = AES Input Data[95:64]  of [127:0]

For normal operations, this register is not used, since data input and output is transferred from and to the AES engine via DMA.

For a Host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range will store the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to AESCTL.INPUT_RDY.

Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]): 0 &lt; n &lt;= 128 bits. For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The Crypto peripheral automatically pads or masks misaligned ending data blocks with zeroes for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESDATAOUT3</name>
          <addressOffset>0x56c</addressOffset>
          <size>32</size>
          <description>AES Data Input/Output 3</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[31:0] Data registers for output block data from the Crypto peripheral.
These bits = AES Output Data[127:96] of [127:0]

For normal operations, this register is not used, since data input and output is transferred from and to the AES engine via DMA.

For a Host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range will read one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, AESCTL.OUTPUT_RDY must be written.
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.

Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESDATAIN3</name>
          <addressOffset>0x56c</addressOffset>
          <size>32</size>
          <description>Data Input/Output</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[31:0] Data registers for input block data to the Crypto peripheral.
These bits = AES Input Data[127:96] of [127:0]

For normal operations, this register is not used, since data input and output is transferred from and to the AES engine via DMA.

For a Host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range will store the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to AESCTL.INPUT_RDY.

Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]): 0 &lt; n &lt;= 128 bits. For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The Crypto peripheral automatically pads or masks misaligned ending data blocks with zeroes for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AESTAGOUT</name>
          <addressOffset>0x570</addressOffset>
          <size>32</size>
          <description>AES Tag Output</description>
          <fields>
            <field>
              <name>TAG</name>
              <description>[31:0] This register contains the authentication TAG for the combined and authentication-only modes.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ALGSEL</name>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <description>Master Algorithm Select
This register configures the internal destination of the DMA controller.</description>
          <fields>
            <field>
              <name>TAG</name>
              <description>[31:31] If this bit is cleared to 0, the DMA operation involves only data.
If this bit is set, the DMA operation includes a TAG (Authentication Result / Digest).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[30:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AES</name>
              <description>[1:1] If set to 1,  the AES data is loaded via DMA
Both Read and Write maximum transfer size to DMA engine is set to 16 bytes</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>KEY_STORE</name>
              <description>[0:0] If set to 1, selects the Key Store to be loaded via DMA.
The maximum transfer size to DMA engine is set to 32 bytes (however transfers of 16, 24 and 32 bytes are allowed)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMAPROTCTL</name>
          <addressOffset>0x704</addressOffset>
          <size>32</size>
          <description>Master Protection Control</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] Select AHB transfer protection control for DMA transfers using the key store area as destination.
0 : transfers use 'USER' type access.
1 : transfers use 'PRIVILEGED' type access.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SWRESET</name>
          <addressOffset>0x740</addressOffset>
          <size>32</size>
          <description>Software Reset</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESET</name>
              <description>[0:0] If this bit is set to 1, the following modules are reset:
- Master control internal state is reset. That includes interrupt, error status register and result available interrupt generation FSM.
- Key store module state is reset. That includes clearing the Written Area flags; therefore the keys must be reloaded to the key store module.
Writing 0 has no effect.
The bit is self cleared after executing the reset.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQTYPE</name>
          <addressOffset>0x780</addressOffset>
          <size>32</size>
          <description>Control Interrupt Configuration</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LEVEL</name>
              <description>[0:0] If this bit is 0, the interrupt output is a pulse.
If this bit is set to 1, the interrupt is a level interrupt that must be cleared by writing the interrupt clear register.
This bit is applicable for both interrupt output signals.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQEN</name>
          <addressOffset>0x784</addressOffset>
          <size>32</size>
          <description>Interrupt Enable</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DMA_IN_DONE</name>
              <description>[1:1] This bit enables IRQSTAT.DMA_IN_DONE as source for IRQ.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESULT_AVAIL</name>
              <description>[0:0] This bit enables IRQSTAT.RESULT_AVAIL as source for IRQ.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQCLR</name>
          <addressOffset>0x788</addressOffset>
          <size>32</size>
          <description>Interrupt Clear</description>
          <fields>
            <field>
              <name>DMA_BUS_ERR</name>
              <description>[31:31] If 1 is written to this bit, IRQSTAT.DMA_BUS_ERR is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>KEY_ST_WR_ERR</name>
              <description>[30:30] If 1 is written to this bit, IRQSTAT.KEY_ST_WR_ERR is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>KEY_ST_RD_ERR</name>
              <description>[29:29] If 1 is written to this bit, IRQSTAT.KEY_ST_RD_ERR is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[28:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DMA_IN_DONE</name>
              <description>[1:1] If 1 is written to this bit, IRQSTAT.DMA_IN_DONE is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESULT_AVAIL</name>
              <description>[0:0] If 1 is written to this bit, IRQSTAT.RESULT_AVAIL is cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQSET</name>
          <addressOffset>0x78c</addressOffset>
          <size>32</size>
          <description>Interrupt Set</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DMA_IN_DONE</name>
              <description>[1:1] If 1 is written to this bit, IRQSTAT.DMA_IN_DONE is set.
Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESULT_AVAIL</name>
              <description>[0:0] If 1 is written to this bit, IRQSTAT.RESULT_AVAIL is set.
Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQSTAT</name>
          <addressOffset>0x790</addressOffset>
          <size>32</size>
          <description>Interrupt Status</description>
          <fields>
            <field>
              <name>DMA_BUS_ERR</name>
              <description>[31:31] This bit is set when a DMA bus error is detected during a DMA operation. The value of this register is held until it is cleared via IRQCLR.DMA_BUS_ERR
Note: This error is asserted if an error is detected on the AHB master interface during a DMA operation.
Note: This is not an interrupt source.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>KEY_ST_WR_ERR</name>
              <description>[30:30] This bit is set when a write error is detected during the DMA write operation to the key store memory. The value of this register is held until it is cleared via IRQCLR.KEY_ST_WR_ERR
Note: This error is asserted if a DMA operation does not cover a full key area or more areas are written than expected.
Note: This is not an interrupt source.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>KEY_ST_RD_ERR</name>
              <description>[29:29] This bit will be set when a read error is detected during the read of a key from the key store, while copying it to the AES engine. The value of this register is held until it is cleared via IRQCLR.KEY_ST_RD_ERR.
Note: This error is asserted if a key location is selected in the key store that is not available.
Note: This is not an interrupt source.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[28:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DMA_IN_DONE</name>
              <description>[1:1] This bit returns the status of DMA data in done interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESULT_AVAIL</name>
              <description>[0:0] This bit is set high when the Crypto peripheral has a result available.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>HWVER</name>
          <addressOffset>0x7fc</addressOffset>
          <size>32</size>
          <description>CTRL Module Version</description>
          <fields>
            <field>
              <name>RESERVED28</name>
              <description>[31:28] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>HW_MAJOR_VER</name>
              <description>[27:24] Major version number</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>HW_MINOR_VER</name>
              <description>[23:20] Minor version number</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>HW_PATCH_LVL</name>
              <description>[19:16] Patch level, starts at 0 at first delivery of this version.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VER_NUM_COMPL</name>
              <description>[15:8] These bits simply contain the complement of VER_NUM (0x87), used by a driver to ascertain that the Crypto peripheral register is indeed read.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VER_NUM</name>
              <description>[7:0] The version number for the Crypto peripheral, this field contains the value 120 (decimal) or 0x78.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x91118778</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EVENT</name>
      <baseAddress>0x40083000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Event Fabric Component Definition</description>
      <registers>
        <register>
          <name>CPUIRQSEL0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AON_GPIO_EDGE</name>
                  <value>4</value>
                  <description>Edge detect event from IOC. Configureded by the IOC:IOCFGn.EDGE_IRQ_EN and  IOC:IOCFGn.EDGE_DET settings</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x4</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 1</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C_IRQ</name>
                  <value>9</value>
                  <description>Interrupt event from I2C</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x9</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL2</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 2</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_CPE_1</name>
                  <value>30</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE1 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_1 event</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1E</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL3</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 3</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x38</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL4</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 4</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AON_RTC_COMB</name>
                  <value>7</value>
                  <description>Event from AON_RTC, controlled by the AON_RTC:CTL.COMB_EV_MASK setting</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x7</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL5</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 5</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART0_COMB</name>
                  <value>36</value>
                  <description>UART0 combined interrupt, interrupt flags are found here UART0:MIS</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x24</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL6</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 6</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUX_SWEV0</name>
                  <value>28</value>
                  <description>AUX software event 0, triggered by AUX_EVCTL:SWEVSET.SWEV0, also available as AUX_EVENT0 AON wake up event.
MCU domain wakeup control AON_EVENT:MCUWUSEL
AUX domain wakeup control AON_EVENT:AUXWUSEL</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1C</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL7</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 7</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI0_COMB</name>
                  <value>34</value>
                  <description>SSI0 combined interrupt, interrupt flags are found here SSI0:MIS</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x22</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL8</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 8</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI1_COMB</name>
                  <value>35</value>
                  <description>SSI1 combined interrupt, interrupt flags are found here SSI1:MIS</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x23</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL9</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 9</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_CPE_0</name>
                  <value>27</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE0 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_0 event</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1B</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL10</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 10</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_HW_COMB</name>
                  <value>26</value>
                  <description>Combined RFC hardware interrupt, corresponding flag is here RFC_DBELL:RFHWIFG</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1A</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL11</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 11</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_CMD_ACK</name>
                  <value>25</value>
                  <description>RFC Doorbell Command Acknowledgement Interrupt, equvialent to RFC_DBELL:RFACKIFG.ACKFLAG</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x19</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL12</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 12</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2S_IRQ</name>
                  <value>8</value>
                  <description>Interrupt event from I2S</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x8</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL13</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 13</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>29</value>
                  <description>AUX software event 1, triggered by AUX_EVCTL:SWEVSET.SWEV1, also available as AUX_EVENT2 AON wake up event.
MCU domain wakeup control AON_EVENT:MCUWUSEL
AUX domain wakeup control AON_EVENT:AUXWUSEL</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1D</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL14</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 14</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WDT_IRQ</name>
                  <value>24</value>
                  <description>Watchdog interrupt event, controlled by WDT:CTL.INTEN</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x18</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL15</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 15</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT0A</name>
                  <value>16</value>
                  <description>GPT0A interrupt event, controlled by GPT0:TAMR</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x10</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL16</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 16</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT0B</name>
                  <value>17</value>
                  <description>GPT0B interrupt event, controlled by GPT0:TBMR</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x11</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL17</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 17</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT1A</name>
                  <value>18</value>
                  <description>GPT1A interrupt event, controlled by GPT1:TAMR</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x12</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL18</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 18</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT1B</name>
                  <value>19</value>
                  <description>GPT1B interrupt event, controlled by GPT1:TBMR</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x13</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL19</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 19</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT2A</name>
                  <value>12</value>
                  <description>GPT2A interrupt event, controlled by GPT2:TAMR</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0xC</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL20</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 20</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT2B</name>
                  <value>13</value>
                  <description>GPT2B interrupt event, controlled by GPT2:TBMR</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0xD</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL21</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 21</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT3A</name>
                  <value>14</value>
                  <description>GPT3A interrupt event, controlled by GPT3:TAMR</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0xE</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL22</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 22</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT3B</name>
                  <value>15</value>
                  <description>GPT3B interrupt event, controlled by GPT3:TBMR</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0xF</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL23</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 23</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CRYPTO_RESULT_AVAIL_IRQ</name>
                  <value>93</value>
                  <description>CRYPTO result available interupt event, the corresponding flag is found here CRYPTO:IRQSTAT.RESULT_AVAIL. Controlled by CRYPTO:IRQSTAT.RESULT_AVAIL</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x5D</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL24</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 24</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DMA_DONE_COMB</name>
                  <value>39</value>
                  <description>Combined DMA done, corresponding flags are here UDMA0:REQDONE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x27</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL25</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 25</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DMA_ERR</name>
                  <value>38</value>
                  <description>DMA bus error, corresponds to UDMA0:ERROR.STATUS</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x26</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL26</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 26</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FLASH</name>
                  <value>21</value>
                  <description>FLASH controller error event,  the status flags are FLASH:FEDACSTAT.FSM_DONE and FLASH:FEDACSTAT.RVF_INT</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x15</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL27</name>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 27</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SWEV0</name>
                  <value>100</value>
                  <description>Software event 0, triggered by SWEV.SWEV0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x64</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL28</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 28</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUX_COMB</name>
                  <value>11</value>
                  <description>AUX combined event, the corresponding flag register is here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0xB</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL29</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 29</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AON_PROG0</name>
                  <value>1</value>
                  <description>AON programmable event 0. Event selected by AON_EVENT  MCU event selector, AON_EVENT:EVTOMCUSEL.AON_PROG0_EV</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL30</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 30</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_UPD</name>
                  <value>119</value>
                  <description>RTC periodic event controlled by AON_RTC:CTL.RTC_UPD_EN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_OBSMUX0</name>
                  <value>114</value>
                  <description>Loopback of OBSMUX0 through AUX, corresponds to AUX_EVCTL:EVTOMCUFLAGS.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_FIFO_ALMOST_FULL</name>
                  <value>113</value>
                  <description>AUX ADC FIFO watermark event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>112</value>
                  <description>AUX ADC done, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SMPH_AUTOTAKE_DONE</name>
                  <value>111</value>
                  <description>Autotake event from AUX semaphore, configured by AUX_SMPH:AUTOTAKE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>110</value>
                  <description>AUX timer 1 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>109</value>
                  <description>AUX timer 0 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>108</value>
                  <description>AUX TDC measurement done event, corresponds to the flag AUX_EVCTL:EVTOMCUFLAGS.TDC_DONE and the AUX_TDC status AUX_TDC:STAT.DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>107</value>
                  <description>AUX Compare B event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_AON_WU_EV</name>
                  <value>105</value>
                  <description>AON wakeup event, corresponds flags are here AUX_EVCTL:EVTOMCUFLAGS.AON_WU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CRYPTO_DMA_DONE_IRQ</name>
                  <value>94</value>
                  <description>CRYPTO DMA input done event, the correspondingg flag is CRYPTO:IRQSTAT.DMA_IN_DONE. Controlled by CRYPTO:IRQEN.DMA_IN_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DMA_CH18_DONE</name>
                  <value>22</value>
                  <description>DMA done for software tiggered UDMA channel 18, see UDMA0:SOFTREQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DMA_CH0_DONE</name>
                  <value>20</value>
                  <description>DMA done for software tiggered UDMA channel 0, see UDMA0:SOFTREQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_AUX_SWEV0</name>
                  <value>10</value>
                  <description>AUX Software event 0, AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_IRQ</name>
                  <value>8</value>
                  <description>Interrupt event from I2S</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG2</name>
                  <value>3</value>
                  <description>AON programmable event 2. Event selected by AON_EVENT MCU event selector, AON_EVENT:EVTOMCUSEL.AON_PROG2_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG1</name>
                  <value>2</value>
                  <description>AON programmable event 1. Event selected by AON_EVENT MCU event selector, AON_EVENT:EVTOMCUSEL.AON_PROG1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL31</name>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 31</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>106</value>
                  <description>AUX Compare A event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPA</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6A</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL32</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 32</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUX_ADC_IRQ</name>
                  <value>115</value>
                  <description>AUX ADC interrupt event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_IRQ. Status flags are found here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x73</resetValue>
        </register>
        <register>
          <name>CPUIRQSEL33</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>Output Selection for CPU Interrupt 33</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TRNG_IRQ</name>
                  <value>104</value>
                  <description>TRNG Interrupt event, controlled by TRNG:IRQEN.EN</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x68</resetValue>
        </register>
        <register>
          <name>RFCSEL0</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>Output Selection for RFC Event 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT0A_CMP</name>
                  <value>61</value>
                  <description>GPT0A compare event. Configured by GPT0:TAMR.TCACT</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x3D</resetValue>
        </register>
        <register>
          <name>RFCSEL1</name>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <description>Output Selection for RFC Event 1</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT0B_CMP</name>
                  <value>62</value>
                  <description>GPT0B compare event. Configured by GPT0:TBMR.TCACT</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x3E</resetValue>
        </register>
        <register>
          <name>RFCSEL2</name>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <description>Output Selection for RFC Event 2</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT1A_CMP</name>
                  <value>63</value>
                  <description>GPT1A compare event. Configured by GPT1:TAMR.TCACT</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x3F</resetValue>
        </register>
        <register>
          <name>RFCSEL3</name>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <description>Output Selection for RFC Event 3</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT1B_CMP</name>
                  <value>64</value>
                  <description>GPT1B compare event. Configured by GPT1:TBMR.TCACT</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x40</resetValue>
        </register>
        <register>
          <name>RFCSEL4</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>Output Selection for RFC Event 4</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT2A_CMP</name>
                  <value>65</value>
                  <description>GPT2A compare event. Configured by GPT2:TAMR.TCACT</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x41</resetValue>
        </register>
        <register>
          <name>RFCSEL5</name>
          <addressOffset>0x114</addressOffset>
          <size>32</size>
          <description>Output Selection for RFC Event 5</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT2B_CMP</name>
                  <value>66</value>
                  <description>GPT2B compare event. Configured by GPT2:TBMR.TCACT</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x42</resetValue>
        </register>
        <register>
          <name>RFCSEL6</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>Output Selection for RFC Event 6</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT3A_CMP</name>
                  <value>67</value>
                  <description>GPT3A compare event. Configured by GPT3:TAMR.TCACT</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x43</resetValue>
        </register>
        <register>
          <name>RFCSEL7</name>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <description>Output Selection for RFC Event 7</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT3B_CMP</name>
                  <value>68</value>
                  <description>GPT3B compare event. Configured by GPT3:TBMR.TCACT</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x44</resetValue>
        </register>
        <register>
          <name>RFCSEL8</name>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <description>Output Selection for RFC Event 8</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AON_RTC_UPD</name>
                  <value>119</value>
                  <description>RTC periodic event controlled by AON_RTC:CTL.RTC_UPD_EN</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x77</resetValue>
        </register>
        <register>
          <name>RFCSEL9</name>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <description>Output Selection for RFC Event 9</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_IRQ</name>
                  <value>115</value>
                  <description>AUX ADC interrupt event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_IRQ. Status flags are found here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_OBSMUX0</name>
                  <value>114</value>
                  <description>Loopback of OBSMUX0 through AUX, corresponds to AUX_EVCTL:EVTOMCUFLAGS.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_FIFO_ALMOST_FULL</name>
                  <value>113</value>
                  <description>AUX ADC FIFO watermark event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>112</value>
                  <description>AUX ADC done, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SMPH_AUTOTAKE_DONE</name>
                  <value>111</value>
                  <description>Autotake event from AUX semaphore, configured by AUX_SMPH:AUTOTAKE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>110</value>
                  <description>AUX timer 1 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>109</value>
                  <description>AUX timer 0 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>108</value>
                  <description>AUX TDC measurement done event, corresponds to the flag AUX_EVCTL:EVTOMCUFLAGS.TDC_DONE and the AUX_TDC status AUX_TDC:STAT.DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>107</value>
                  <description>AUX Compare B event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>106</value>
                  <description>AUX Compare A event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_AON_WU_EV</name>
                  <value>105</value>
                  <description>AON wakeup event, corresponds flags are here AUX_EVCTL:EVTOMCUFLAGS.AON_WU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SWEV1</name>
                  <value>101</value>
                  <description>Software event 1, triggered by SWEV.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SWEV0</name>
                  <value>100</value>
                  <description>Software event 0, triggered by SWEV.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CRYPTO_RESULT_AVAIL_IRQ</name>
                  <value>93</value>
                  <description>CRYPTO result available interupt event, the corresponding flag is found here CRYPTO:IRQSTAT.RESULT_AVAIL. Controlled by CRYPTO:IRQSTAT.RESULT_AVAIL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DMA_DONE_COMB</name>
                  <value>39</value>
                  <description>Combined DMA done, corresponding flags are here UDMA0:REQDONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_COMB</name>
                  <value>36</value>
                  <description>UART0 combined interrupt, interrupt flags are found here UART0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_COMB</name>
                  <value>35</value>
                  <description>SSI1 combined interrupt, interrupt flags are found here SSI1:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_COMB</name>
                  <value>34</value>
                  <description>SSI0 combined interrupt, interrupt flags are found here SSI0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WDT_IRQ</name>
                  <value>24</value>
                  <description>Watchdog interrupt event, controlled by WDT:CTL.INTEN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_AUX_SWEV0</name>
                  <value>10</value>
                  <description>AUX Software event 0, AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_IRQ</name>
                  <value>8</value>
                  <description>Interrupt event from I2S</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG1</name>
                  <value>2</value>
                  <description>AON programmable event 1. Event selected by AON_EVENT MCU event selector, AON_EVENT:EVTOMCUSEL.AON_PROG1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG0</name>
                  <value>1</value>
                  <description>AON programmable event 0. Event selected by AON_EVENT  MCU event selector, AON_EVENT:EVTOMCUSEL.AON_PROG0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x2</resetValue>
        </register>
        <register>
          <name>GPT0ACAPTSEL</name>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <description>Output Selection for GPT0 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_UPD</name>
                  <value>119</value>
                  <description>RTC periodic event controlled by AON_RTC:CTL.RTC_UPD_EN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_IRQ</name>
                  <value>115</value>
                  <description>AUX ADC interrupt event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_IRQ. Status flags are found here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_OBSMUX0</name>
                  <value>114</value>
                  <description>Loopback of OBSMUX0 through AUX, corresponds to AUX_EVCTL:EVTOMCUFLAGS.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_FIFO_ALMOST_FULL</name>
                  <value>113</value>
                  <description>AUX ADC FIFO watermark event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>112</value>
                  <description>AUX ADC done, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SMPH_AUTOTAKE_DONE</name>
                  <value>111</value>
                  <description>Autotake event from AUX semaphore, configured by AUX_SMPH:AUTOTAKE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>110</value>
                  <description>AUX timer 1 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>109</value>
                  <description>AUX timer 0 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>108</value>
                  <description>AUX TDC measurement done event, corresponds to the flag AUX_EVCTL:EVTOMCUFLAGS.TDC_DONE and the AUX_TDC status AUX_TDC:STAT.DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>107</value>
                  <description>AUX Compare B event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>106</value>
                  <description>AUX Compare A event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_AON_WU_EV</name>
                  <value>105</value>
                  <description>AON wakeup event, corresponds flags are here AUX_EVCTL:EVTOMCUFLAGS.AON_WU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>86</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT1 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>85</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT0 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_CMP</name>
                  <value>68</value>
                  <description>GPT3B compare event. Configured by GPT3:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_CMP</name>
                  <value>67</value>
                  <description>GPT3A compare event. Configured by GPT3:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_CMP</name>
                  <value>66</value>
                  <description>GPT2B compare event. Configured by GPT2:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_CMP</name>
                  <value>65</value>
                  <description>GPT2A compare event. Configured by GPT2:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_CMP</name>
                  <value>64</value>
                  <description>GPT1B compare event. Configured by GPT1:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_CMP</name>
                  <value>63</value>
                  <description>GPT1A compare event. Configured by GPT1:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_CMP</name>
                  <value>62</value>
                  <description>GPT0B compare event. Configured by GPT0:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_CMP</name>
                  <value>61</value>
                  <description>GPT0A compare event. Configured by GPT0:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_COMB</name>
                  <value>36</value>
                  <description>UART0 combined interrupt, interrupt flags are found here UART0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_COMB</name>
                  <value>35</value>
                  <description>SSI1 combined interrupt, interrupt flags are found here SSI1:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_COMB</name>
                  <value>34</value>
                  <description>SSI0 combined interrupt, interrupt flags are found here SSI0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_1</name>
                  <value>30</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE1 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_0</name>
                  <value>27</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE0 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_HW_COMB</name>
                  <value>26</value>
                  <description>Combined RFC hardware interrupt, corresponding flag is here RFC_DBELL:RFHWIFG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CMD_ACK</name>
                  <value>25</value>
                  <description>RFC Doorbell Command Acknowledgement Interrupt, equvialent to RFC_DBELL:RFACKIFG.ACKFLAG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLASH</name>
                  <value>21</value>
                  <description>FLASH controller error event,  the status flags are FLASH:FEDACSTAT.FSM_DONE and FLASH:FEDACSTAT.RVF_INT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMB</name>
                  <value>11</value>
                  <description>AUX combined event, the corresponding flag register is here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_IRQ</name>
                  <value>9</value>
                  <description>Interrupt event from I2C</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_COMB</name>
                  <value>7</value>
                  <description>Event from AON_RTC, controlled by the AON_RTC:CTL.COMB_EV_MASK setting</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_GPIO_EDGE</name>
                  <value>4</value>
                  <description>Edge detect event from IOC. Configureded by the IOC:IOCFGn.EDGE_IRQ_EN and  IOC:IOCFGn.EDGE_DET settings</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x55</resetValue>
        </register>
        <register>
          <name>GPT0BCAPTSEL</name>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <description>Output Selection for GPT0 1</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_UPD</name>
                  <value>119</value>
                  <description>RTC periodic event controlled by AON_RTC:CTL.RTC_UPD_EN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_IRQ</name>
                  <value>115</value>
                  <description>AUX ADC interrupt event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_IRQ. Status flags are found here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_OBSMUX0</name>
                  <value>114</value>
                  <description>Loopback of OBSMUX0 through AUX, corresponds to AUX_EVCTL:EVTOMCUFLAGS.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_FIFO_ALMOST_FULL</name>
                  <value>113</value>
                  <description>AUX ADC FIFO watermark event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>112</value>
                  <description>AUX ADC done, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SMPH_AUTOTAKE_DONE</name>
                  <value>111</value>
                  <description>Autotake event from AUX semaphore, configured by AUX_SMPH:AUTOTAKE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>110</value>
                  <description>AUX timer 1 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>109</value>
                  <description>AUX timer 0 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>108</value>
                  <description>AUX TDC measurement done event, corresponds to the flag AUX_EVCTL:EVTOMCUFLAGS.TDC_DONE and the AUX_TDC status AUX_TDC:STAT.DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>107</value>
                  <description>AUX Compare B event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>106</value>
                  <description>AUX Compare A event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_AON_WU_EV</name>
                  <value>105</value>
                  <description>AON wakeup event, corresponds flags are here AUX_EVCTL:EVTOMCUFLAGS.AON_WU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>86</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT1 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>85</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT0 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_CMP</name>
                  <value>68</value>
                  <description>GPT3B compare event. Configured by GPT3:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_CMP</name>
                  <value>67</value>
                  <description>GPT3A compare event. Configured by GPT3:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_CMP</name>
                  <value>66</value>
                  <description>GPT2B compare event. Configured by GPT2:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_CMP</name>
                  <value>65</value>
                  <description>GPT2A compare event. Configured by GPT2:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_CMP</name>
                  <value>64</value>
                  <description>GPT1B compare event. Configured by GPT1:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_CMP</name>
                  <value>63</value>
                  <description>GPT1A compare event. Configured by GPT1:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_CMP</name>
                  <value>62</value>
                  <description>GPT0B compare event. Configured by GPT0:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_CMP</name>
                  <value>61</value>
                  <description>GPT0A compare event. Configured by GPT0:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_COMB</name>
                  <value>36</value>
                  <description>UART0 combined interrupt, interrupt flags are found here UART0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_COMB</name>
                  <value>35</value>
                  <description>SSI1 combined interrupt, interrupt flags are found here SSI1:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_COMB</name>
                  <value>34</value>
                  <description>SSI0 combined interrupt, interrupt flags are found here SSI0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_1</name>
                  <value>30</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE1 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_0</name>
                  <value>27</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE0 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_HW_COMB</name>
                  <value>26</value>
                  <description>Combined RFC hardware interrupt, corresponding flag is here RFC_DBELL:RFHWIFG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CMD_ACK</name>
                  <value>25</value>
                  <description>RFC Doorbell Command Acknowledgement Interrupt, equvialent to RFC_DBELL:RFACKIFG.ACKFLAG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLASH</name>
                  <value>21</value>
                  <description>FLASH controller error event,  the status flags are FLASH:FEDACSTAT.FSM_DONE and FLASH:FEDACSTAT.RVF_INT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMB</name>
                  <value>11</value>
                  <description>AUX combined event, the corresponding flag register is here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_IRQ</name>
                  <value>9</value>
                  <description>Interrupt event from I2C</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_COMB</name>
                  <value>7</value>
                  <description>Event from AON_RTC, controlled by the AON_RTC:CTL.COMB_EV_MASK setting</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_GPIO_EDGE</name>
                  <value>4</value>
                  <description>Edge detect event from IOC. Configureded by the IOC:IOCFGn.EDGE_IRQ_EN and  IOC:IOCFGn.EDGE_DET settings</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x56</resetValue>
        </register>
        <register>
          <name>GPT1ACAPTSEL</name>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <description>Output Selection for GPT1 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_UPD</name>
                  <value>119</value>
                  <description>RTC periodic event controlled by AON_RTC:CTL.RTC_UPD_EN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_IRQ</name>
                  <value>115</value>
                  <description>AUX ADC interrupt event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_IRQ. Status flags are found here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_OBSMUX0</name>
                  <value>114</value>
                  <description>Loopback of OBSMUX0 through AUX, corresponds to AUX_EVCTL:EVTOMCUFLAGS.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_FIFO_ALMOST_FULL</name>
                  <value>113</value>
                  <description>AUX ADC FIFO watermark event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>112</value>
                  <description>AUX ADC done, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SMPH_AUTOTAKE_DONE</name>
                  <value>111</value>
                  <description>Autotake event from AUX semaphore, configured by AUX_SMPH:AUTOTAKE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>110</value>
                  <description>AUX timer 1 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>109</value>
                  <description>AUX timer 0 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>108</value>
                  <description>AUX TDC measurement done event, corresponds to the flag AUX_EVCTL:EVTOMCUFLAGS.TDC_DONE and the AUX_TDC status AUX_TDC:STAT.DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>107</value>
                  <description>AUX Compare B event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>106</value>
                  <description>AUX Compare A event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_AON_WU_EV</name>
                  <value>105</value>
                  <description>AON wakeup event, corresponds flags are here AUX_EVCTL:EVTOMCUFLAGS.AON_WU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>88</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT3 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>87</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT2 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_CMP</name>
                  <value>68</value>
                  <description>GPT3B compare event. Configured by GPT3:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_CMP</name>
                  <value>67</value>
                  <description>GPT3A compare event. Configured by GPT3:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_CMP</name>
                  <value>66</value>
                  <description>GPT2B compare event. Configured by GPT2:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_CMP</name>
                  <value>65</value>
                  <description>GPT2A compare event. Configured by GPT2:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_CMP</name>
                  <value>64</value>
                  <description>GPT1B compare event. Configured by GPT1:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_CMP</name>
                  <value>63</value>
                  <description>GPT1A compare event. Configured by GPT1:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_CMP</name>
                  <value>62</value>
                  <description>GPT0B compare event. Configured by GPT0:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_CMP</name>
                  <value>61</value>
                  <description>GPT0A compare event. Configured by GPT0:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_COMB</name>
                  <value>36</value>
                  <description>UART0 combined interrupt, interrupt flags are found here UART0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_COMB</name>
                  <value>35</value>
                  <description>SSI1 combined interrupt, interrupt flags are found here SSI1:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_COMB</name>
                  <value>34</value>
                  <description>SSI0 combined interrupt, interrupt flags are found here SSI0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_1</name>
                  <value>30</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE1 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_0</name>
                  <value>27</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE0 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_HW_COMB</name>
                  <value>26</value>
                  <description>Combined RFC hardware interrupt, corresponding flag is here RFC_DBELL:RFHWIFG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CMD_ACK</name>
                  <value>25</value>
                  <description>RFC Doorbell Command Acknowledgement Interrupt, equvialent to RFC_DBELL:RFACKIFG.ACKFLAG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLASH</name>
                  <value>21</value>
                  <description>FLASH controller error event,  the status flags are FLASH:FEDACSTAT.FSM_DONE and FLASH:FEDACSTAT.RVF_INT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMB</name>
                  <value>11</value>
                  <description>AUX combined event, the corresponding flag register is here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_IRQ</name>
                  <value>9</value>
                  <description>Interrupt event from I2C</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_COMB</name>
                  <value>7</value>
                  <description>Event from AON_RTC, controlled by the AON_RTC:CTL.COMB_EV_MASK setting</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_GPIO_EDGE</name>
                  <value>4</value>
                  <description>Edge detect event from IOC. Configureded by the IOC:IOCFGn.EDGE_IRQ_EN and  IOC:IOCFGn.EDGE_DET settings</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x57</resetValue>
        </register>
        <register>
          <name>GPT1BCAPTSEL</name>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <description>Output Selection for GPT1 1</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_UPD</name>
                  <value>119</value>
                  <description>RTC periodic event controlled by AON_RTC:CTL.RTC_UPD_EN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_IRQ</name>
                  <value>115</value>
                  <description>AUX ADC interrupt event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_IRQ. Status flags are found here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_OBSMUX0</name>
                  <value>114</value>
                  <description>Loopback of OBSMUX0 through AUX, corresponds to AUX_EVCTL:EVTOMCUFLAGS.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_FIFO_ALMOST_FULL</name>
                  <value>113</value>
                  <description>AUX ADC FIFO watermark event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>112</value>
                  <description>AUX ADC done, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SMPH_AUTOTAKE_DONE</name>
                  <value>111</value>
                  <description>Autotake event from AUX semaphore, configured by AUX_SMPH:AUTOTAKE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>110</value>
                  <description>AUX timer 1 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>109</value>
                  <description>AUX timer 0 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>108</value>
                  <description>AUX TDC measurement done event, corresponds to the flag AUX_EVCTL:EVTOMCUFLAGS.TDC_DONE and the AUX_TDC status AUX_TDC:STAT.DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>107</value>
                  <description>AUX Compare B event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>106</value>
                  <description>AUX Compare A event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_AON_WU_EV</name>
                  <value>105</value>
                  <description>AON wakeup event, corresponds flags are here AUX_EVCTL:EVTOMCUFLAGS.AON_WU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>88</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT3 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>87</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT2 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_CMP</name>
                  <value>68</value>
                  <description>GPT3B compare event. Configured by GPT3:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_CMP</name>
                  <value>67</value>
                  <description>GPT3A compare event. Configured by GPT3:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_CMP</name>
                  <value>66</value>
                  <description>GPT2B compare event. Configured by GPT2:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_CMP</name>
                  <value>65</value>
                  <description>GPT2A compare event. Configured by GPT2:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_CMP</name>
                  <value>64</value>
                  <description>GPT1B compare event. Configured by GPT1:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_CMP</name>
                  <value>63</value>
                  <description>GPT1A compare event. Configured by GPT1:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_CMP</name>
                  <value>62</value>
                  <description>GPT0B compare event. Configured by GPT0:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_CMP</name>
                  <value>61</value>
                  <description>GPT0A compare event. Configured by GPT0:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_COMB</name>
                  <value>36</value>
                  <description>UART0 combined interrupt, interrupt flags are found here UART0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_COMB</name>
                  <value>35</value>
                  <description>SSI1 combined interrupt, interrupt flags are found here SSI1:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_COMB</name>
                  <value>34</value>
                  <description>SSI0 combined interrupt, interrupt flags are found here SSI0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_1</name>
                  <value>30</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE1 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_0</name>
                  <value>27</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE0 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_HW_COMB</name>
                  <value>26</value>
                  <description>Combined RFC hardware interrupt, corresponding flag is here RFC_DBELL:RFHWIFG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CMD_ACK</name>
                  <value>25</value>
                  <description>RFC Doorbell Command Acknowledgement Interrupt, equvialent to RFC_DBELL:RFACKIFG.ACKFLAG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLASH</name>
                  <value>21</value>
                  <description>FLASH controller error event,  the status flags are FLASH:FEDACSTAT.FSM_DONE and FLASH:FEDACSTAT.RVF_INT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMB</name>
                  <value>11</value>
                  <description>AUX combined event, the corresponding flag register is here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_IRQ</name>
                  <value>9</value>
                  <description>Interrupt event from I2C</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_COMB</name>
                  <value>7</value>
                  <description>Event from AON_RTC, controlled by the AON_RTC:CTL.COMB_EV_MASK setting</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_GPIO_EDGE</name>
                  <value>4</value>
                  <description>Edge detect event from IOC. Configureded by the IOC:IOCFGn.EDGE_IRQ_EN and  IOC:IOCFGn.EDGE_DET settings</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x58</resetValue>
        </register>
        <register>
          <name>GPT2ACAPTSEL</name>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <description>Output Selection for GPT2 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_UPD</name>
                  <value>119</value>
                  <description>RTC periodic event controlled by AON_RTC:CTL.RTC_UPD_EN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_IRQ</name>
                  <value>115</value>
                  <description>AUX ADC interrupt event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_IRQ. Status flags are found here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_OBSMUX0</name>
                  <value>114</value>
                  <description>Loopback of OBSMUX0 through AUX, corresponds to AUX_EVCTL:EVTOMCUFLAGS.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_FIFO_ALMOST_FULL</name>
                  <value>113</value>
                  <description>AUX ADC FIFO watermark event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>112</value>
                  <description>AUX ADC done, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SMPH_AUTOTAKE_DONE</name>
                  <value>111</value>
                  <description>Autotake event from AUX semaphore, configured by AUX_SMPH:AUTOTAKE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>110</value>
                  <description>AUX timer 1 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>109</value>
                  <description>AUX timer 0 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>108</value>
                  <description>AUX TDC measurement done event, corresponds to the flag AUX_EVCTL:EVTOMCUFLAGS.TDC_DONE and the AUX_TDC status AUX_TDC:STAT.DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>107</value>
                  <description>AUX Compare B event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>106</value>
                  <description>AUX Compare A event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_AON_WU_EV</name>
                  <value>105</value>
                  <description>AON wakeup event, corresponds flags are here AUX_EVCTL:EVTOMCUFLAGS.AON_WU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>90</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT4 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>89</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT4 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_CMP</name>
                  <value>68</value>
                  <description>GPT3B compare event. Configured by GPT3:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_CMP</name>
                  <value>67</value>
                  <description>GPT3A compare event. Configured by GPT3:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_CMP</name>
                  <value>66</value>
                  <description>GPT2B compare event. Configured by GPT2:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_CMP</name>
                  <value>65</value>
                  <description>GPT2A compare event. Configured by GPT2:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_CMP</name>
                  <value>64</value>
                  <description>GPT1B compare event. Configured by GPT1:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_CMP</name>
                  <value>63</value>
                  <description>GPT1A compare event. Configured by GPT1:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_CMP</name>
                  <value>62</value>
                  <description>GPT0B compare event. Configured by GPT0:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_CMP</name>
                  <value>61</value>
                  <description>GPT0A compare event. Configured by GPT0:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_COMB</name>
                  <value>36</value>
                  <description>UART0 combined interrupt, interrupt flags are found here UART0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_COMB</name>
                  <value>35</value>
                  <description>SSI1 combined interrupt, interrupt flags are found here SSI1:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_COMB</name>
                  <value>34</value>
                  <description>SSI0 combined interrupt, interrupt flags are found here SSI0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_1</name>
                  <value>30</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE1 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_0</name>
                  <value>27</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE0 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_HW_COMB</name>
                  <value>26</value>
                  <description>Combined RFC hardware interrupt, corresponding flag is here RFC_DBELL:RFHWIFG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CMD_ACK</name>
                  <value>25</value>
                  <description>RFC Doorbell Command Acknowledgement Interrupt, equvialent to RFC_DBELL:RFACKIFG.ACKFLAG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLASH</name>
                  <value>21</value>
                  <description>FLASH controller error event,  the status flags are FLASH:FEDACSTAT.FSM_DONE and FLASH:FEDACSTAT.RVF_INT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMB</name>
                  <value>11</value>
                  <description>AUX combined event, the corresponding flag register is here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_IRQ</name>
                  <value>9</value>
                  <description>Interrupt event from I2C</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_COMB</name>
                  <value>7</value>
                  <description>Event from AON_RTC, controlled by the AON_RTC:CTL.COMB_EV_MASK setting</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_GPIO_EDGE</name>
                  <value>4</value>
                  <description>Edge detect event from IOC. Configureded by the IOC:IOCFGn.EDGE_IRQ_EN and  IOC:IOCFGn.EDGE_DET settings</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x59</resetValue>
        </register>
        <register>
          <name>GPT2BCAPTSEL</name>
          <addressOffset>0x404</addressOffset>
          <size>32</size>
          <description>Output Selection for GPT2 1</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_UPD</name>
                  <value>119</value>
                  <description>RTC periodic event controlled by AON_RTC:CTL.RTC_UPD_EN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_IRQ</name>
                  <value>115</value>
                  <description>AUX ADC interrupt event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_IRQ. Status flags are found here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_OBSMUX0</name>
                  <value>114</value>
                  <description>Loopback of OBSMUX0 through AUX, corresponds to AUX_EVCTL:EVTOMCUFLAGS.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_FIFO_ALMOST_FULL</name>
                  <value>113</value>
                  <description>AUX ADC FIFO watermark event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>112</value>
                  <description>AUX ADC done, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SMPH_AUTOTAKE_DONE</name>
                  <value>111</value>
                  <description>Autotake event from AUX semaphore, configured by AUX_SMPH:AUTOTAKE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>110</value>
                  <description>AUX timer 1 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>109</value>
                  <description>AUX timer 0 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>108</value>
                  <description>AUX TDC measurement done event, corresponds to the flag AUX_EVCTL:EVTOMCUFLAGS.TDC_DONE and the AUX_TDC status AUX_TDC:STAT.DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>107</value>
                  <description>AUX Compare B event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>106</value>
                  <description>AUX Compare A event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_AON_WU_EV</name>
                  <value>105</value>
                  <description>AON wakeup event, corresponds flags are here AUX_EVCTL:EVTOMCUFLAGS.AON_WU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>90</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT4 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>89</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT4 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_CMP</name>
                  <value>68</value>
                  <description>GPT3B compare event. Configured by GPT3:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_CMP</name>
                  <value>67</value>
                  <description>GPT3A compare event. Configured by GPT3:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_CMP</name>
                  <value>66</value>
                  <description>GPT2B compare event. Configured by GPT2:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_CMP</name>
                  <value>65</value>
                  <description>GPT2A compare event. Configured by GPT2:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_CMP</name>
                  <value>64</value>
                  <description>GPT1B compare event. Configured by GPT1:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_CMP</name>
                  <value>63</value>
                  <description>GPT1A compare event. Configured by GPT1:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_CMP</name>
                  <value>62</value>
                  <description>GPT0B compare event. Configured by GPT0:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_CMP</name>
                  <value>61</value>
                  <description>GPT0A compare event. Configured by GPT0:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_COMB</name>
                  <value>36</value>
                  <description>UART0 combined interrupt, interrupt flags are found here UART0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_COMB</name>
                  <value>35</value>
                  <description>SSI1 combined interrupt, interrupt flags are found here SSI1:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_COMB</name>
                  <value>34</value>
                  <description>SSI0 combined interrupt, interrupt flags are found here SSI0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_1</name>
                  <value>30</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE1 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_0</name>
                  <value>27</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE0 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_HW_COMB</name>
                  <value>26</value>
                  <description>Combined RFC hardware interrupt, corresponding flag is here RFC_DBELL:RFHWIFG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CMD_ACK</name>
                  <value>25</value>
                  <description>RFC Doorbell Command Acknowledgement Interrupt, equvialent to RFC_DBELL:RFACKIFG.ACKFLAG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLASH</name>
                  <value>21</value>
                  <description>FLASH controller error event,  the status flags are FLASH:FEDACSTAT.FSM_DONE and FLASH:FEDACSTAT.RVF_INT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMB</name>
                  <value>11</value>
                  <description>AUX combined event, the corresponding flag register is here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_IRQ</name>
                  <value>9</value>
                  <description>Interrupt event from I2C</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_COMB</name>
                  <value>7</value>
                  <description>Event from AON_RTC, controlled by the AON_RTC:CTL.COMB_EV_MASK setting</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_GPIO_EDGE</name>
                  <value>4</value>
                  <description>Edge detect event from IOC. Configureded by the IOC:IOCFGn.EDGE_IRQ_EN and  IOC:IOCFGn.EDGE_DET settings</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x5A</resetValue>
        </register>
        <register>
          <name>UDMACH0SSEL</name>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH0BSEL</name>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH1SSEL</name>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 1 SREQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART0_RX_DMASREQ</name>
                  <value>49</value>
                  <description>UART0 RX DMA single request, controlled by UART0:DMACTL.RXDMAE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x31</resetValue>
        </register>
        <register>
          <name>UDMACH1BSEL</name>
          <addressOffset>0x50c</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 1 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART0_RX_DMABREQ</name>
                  <value>48</value>
                  <description>UART0 RX DMA burst request, controlled by UART0:DMACTL.RXDMAE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x30</resetValue>
        </register>
        <register>
          <name>UDMACH2SSEL</name>
          <addressOffset>0x510</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 2 SREQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART0_TX_DMASREQ</name>
                  <value>51</value>
                  <description>UART0 TX DMA single request, controlled by UART0:DMACTL.TXDMAE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x33</resetValue>
        </register>
        <register>
          <name>UDMACH2BSEL</name>
          <addressOffset>0x514</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 2 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART0_TX_DMABREQ</name>
                  <value>50</value>
                  <description>UART0 TX DMA burst request, controlled by UART0:DMACTL.TXDMAE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x32</resetValue>
        </register>
        <register>
          <name>UDMACH3SSEL</name>
          <addressOffset>0x518</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 3 SREQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI0_RX_DMASREQ</name>
                  <value>41</value>
                  <description>SSI0 RX DMA single request, controlled by SSI0:DMACR.RXDMAE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x29</resetValue>
        </register>
        <register>
          <name>UDMACH3BSEL</name>
          <addressOffset>0x51c</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 3 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI0_RX_DMABREQ</name>
                  <value>40</value>
                  <description>SSI0 RX DMA burst request , controlled by SSI0:DMACR.RXDMAE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x28</resetValue>
        </register>
        <register>
          <name>UDMACH4SSEL</name>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 4 SREQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI0_TX_DMASREQ</name>
                  <value>43</value>
                  <description>SSI0 TX DMA single request, controlled by SSI0:DMACR.TXDMAE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x2B</resetValue>
        </register>
        <register>
          <name>UDMACH4BSEL</name>
          <addressOffset>0x524</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 4 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI0_TX_DMABREQ</name>
                  <value>42</value>
                  <description>SSI0 TX DMA burst request , controlled by SSI0:DMACR.TXDMAE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x2A</resetValue>
        </register>
        <register>
          <name>UDMACH5SSEL</name>
          <addressOffset>0x528</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 5 SREQ</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3A</resetValue>
        </register>
        <register>
          <name>UDMACH5BSEL</name>
          <addressOffset>0x52c</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 5 REQ</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x39</resetValue>
        </register>
        <register>
          <name>UDMACH6SSEL</name>
          <addressOffset>0x530</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 6 SREQ</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3C</resetValue>
        </register>
        <register>
          <name>UDMACH6BSEL</name>
          <addressOffset>0x534</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 6 REQ</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3B</resetValue>
        </register>
        <register>
          <name>UDMACH7SSEL</name>
          <addressOffset>0x538</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 7 SREQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUX_DMASREQ</name>
                  <value>117</value>
                  <description>DMA single request event from AUX, configured by AUX_EVCTL:DMACTL</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x75</resetValue>
        </register>
        <register>
          <name>UDMACH7BSEL</name>
          <addressOffset>0x53c</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 7 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUX_DMABREQ</name>
                  <value>118</value>
                  <description>DMA burst request event from AUX, configured by AUX_EVCTL:DMACTL</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x76</resetValue>
        </register>
        <register>
          <name>UDMACH8SSEL</name>
          <addressOffset>0x540</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 8 SREQ

Single request is ignored for this channel</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUX_SW_DMABREQ</name>
                  <value>116</value>
                  <description>DMA sofware trigger from AUX, triggered by AUX_EVCTL:DMASWREQ.START</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x74</resetValue>
        </register>
        <register>
          <name>UDMACH8BSEL</name>
          <addressOffset>0x544</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 8 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUX_SW_DMABREQ</name>
                  <value>116</value>
                  <description>DMA sofware trigger from AUX, triggered by AUX_EVCTL:DMASWREQ.START</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x74</resetValue>
        </register>
        <register>
          <name>UDMACH9SSEL</name>
          <addressOffset>0x548</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 9 SREQ

DMA_DONE for the corresponding DMA channel is available as interrupt on GPT0 as GPT0:RIS.DMAARIS</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_DMABREQ</name>
                  <value>84</value>
                  <description>GPT3B DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_DMABREQ</name>
                  <value>83</value>
                  <description>GPT3A DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_DMABREQ</name>
                  <value>82</value>
                  <description>GPT2B DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_DMABREQ</name>
                  <value>81</value>
                  <description>GPT2A DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_DMABREQ</name>
                  <value>80</value>
                  <description>GPT1B DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_DMABREQ</name>
                  <value>79</value>
                  <description>GPT1A DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_DMABREQ</name>
                  <value>78</value>
                  <description>GPT0B DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_DMABREQ</name>
                  <value>77</value>
                  <description>GPT0A DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIE_LOW</name>
                  <value>69</value>
                  <description>Not used tied to 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x45</resetValue>
        </register>
        <register>
          <name>UDMACH9BSEL</name>
          <addressOffset>0x54c</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 9 REQ

DMA_DONE for the corresponding DMA channel is available as interrupt on GPT0 as GPT0:RIS.DMAARIS</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_DMABREQ</name>
                  <value>84</value>
                  <description>GPT3B DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_DMABREQ</name>
                  <value>83</value>
                  <description>GPT3A DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_DMABREQ</name>
                  <value>82</value>
                  <description>GPT2B DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_DMABREQ</name>
                  <value>81</value>
                  <description>GPT2A DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_DMABREQ</name>
                  <value>80</value>
                  <description>GPT1B DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_DMABREQ</name>
                  <value>79</value>
                  <description>GPT1A DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_DMABREQ</name>
                  <value>78</value>
                  <description>GPT0B DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_DMABREQ</name>
                  <value>77</value>
                  <description>GPT0A DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x4D</resetValue>
        </register>
        <register>
          <name>UDMACH10SSEL</name>
          <addressOffset>0x550</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 10 SREQ

DMA_DONE for the corresponding DMA channel is available as interrupt on GPT0 as GPT0:RIS.DMABRIS</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_DMABREQ</name>
                  <value>84</value>
                  <description>GPT3B DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_DMABREQ</name>
                  <value>83</value>
                  <description>GPT3A DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_DMABREQ</name>
                  <value>82</value>
                  <description>GPT2B DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_DMABREQ</name>
                  <value>81</value>
                  <description>GPT2A DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_DMABREQ</name>
                  <value>80</value>
                  <description>GPT1B DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_DMABREQ</name>
                  <value>79</value>
                  <description>GPT1A DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_DMABREQ</name>
                  <value>78</value>
                  <description>GPT0B DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_DMABREQ</name>
                  <value>77</value>
                  <description>GPT0A DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIE_LOW</name>
                  <value>70</value>
                  <description>Not used tied to 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x46</resetValue>
        </register>
        <register>
          <name>UDMACH10BSEL</name>
          <addressOffset>0x554</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 10 REQ

DMA_DONE for the corresponding DMA channel is available as interrupt on GPT0 as GPT0:RIS.DMABRIS</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_DMABREQ</name>
                  <value>84</value>
                  <description>GPT3B DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_DMABREQ</name>
                  <value>83</value>
                  <description>GPT3A DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_DMABREQ</name>
                  <value>82</value>
                  <description>GPT2B DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_DMABREQ</name>
                  <value>81</value>
                  <description>GPT2A DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_DMABREQ</name>
                  <value>80</value>
                  <description>GPT1B DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_DMABREQ</name>
                  <value>79</value>
                  <description>GPT1A DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_DMABREQ</name>
                  <value>78</value>
                  <description>GPT0B DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_DMABREQ</name>
                  <value>77</value>
                  <description>GPT0A DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x4E</resetValue>
        </register>
        <register>
          <name>UDMACH11SSEL</name>
          <addressOffset>0x558</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 11 SREQ

DMA_DONE for the corresponding DMA channel is available as interrupt on GPT1 as GPT1:RIS.DMAARIS</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_DMABREQ</name>
                  <value>84</value>
                  <description>GPT3B DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_DMABREQ</name>
                  <value>83</value>
                  <description>GPT3A DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_DMABREQ</name>
                  <value>82</value>
                  <description>GPT2B DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_DMABREQ</name>
                  <value>81</value>
                  <description>GPT2A DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_DMABREQ</name>
                  <value>80</value>
                  <description>GPT1B DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_DMABREQ</name>
                  <value>79</value>
                  <description>GPT1A DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_DMABREQ</name>
                  <value>78</value>
                  <description>GPT0B DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_DMABREQ</name>
                  <value>77</value>
                  <description>GPT0A DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIE_LOW</name>
                  <value>71</value>
                  <description>Not used tied to 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x47</resetValue>
        </register>
        <register>
          <name>UDMACH11BSEL</name>
          <addressOffset>0x55c</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 11 REQ

DMA_DONE for the corresponding DMA channel is available as interrupt on GPT1 as GPT1:RIS.DMAARIS</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_DMABREQ</name>
                  <value>84</value>
                  <description>GPT3B DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_DMABREQ</name>
                  <value>83</value>
                  <description>GPT3A DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_DMABREQ</name>
                  <value>82</value>
                  <description>GPT2B DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_DMABREQ</name>
                  <value>81</value>
                  <description>GPT2A DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_DMABREQ</name>
                  <value>80</value>
                  <description>GPT1B DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_DMABREQ</name>
                  <value>79</value>
                  <description>GPT1A DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_DMABREQ</name>
                  <value>78</value>
                  <description>GPT0B DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_DMABREQ</name>
                  <value>77</value>
                  <description>GPT0A DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x4F</resetValue>
        </register>
        <register>
          <name>UDMACH12SSEL</name>
          <addressOffset>0x560</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 12 SREQ

DMA_DONE for the corresponding DMA channel is available as interrupt on GPT1 as GPT1:RIS.DMABRIS</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_DMABREQ</name>
                  <value>84</value>
                  <description>GPT3B DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_DMABREQ</name>
                  <value>83</value>
                  <description>GPT3A DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_DMABREQ</name>
                  <value>82</value>
                  <description>GPT2B DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_DMABREQ</name>
                  <value>81</value>
                  <description>GPT2A DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_DMABREQ</name>
                  <value>80</value>
                  <description>GPT1B DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_DMABREQ</name>
                  <value>79</value>
                  <description>GPT1A DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_DMABREQ</name>
                  <value>78</value>
                  <description>GPT0B DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_DMABREQ</name>
                  <value>77</value>
                  <description>GPT0A DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIE_LOW</name>
                  <value>72</value>
                  <description>Not used tied to 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x48</resetValue>
        </register>
        <register>
          <name>UDMACH12BSEL</name>
          <addressOffset>0x564</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 12 REQ

DMA_DONE for the corresponding DMA channel is available as interrupt on GPT1 as GPT1:RIS.DMABRIS</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_DMABREQ</name>
                  <value>84</value>
                  <description>GPT3B DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_DMABREQ</name>
                  <value>83</value>
                  <description>GPT3A DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_DMABREQ</name>
                  <value>82</value>
                  <description>GPT2B DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_DMABREQ</name>
                  <value>81</value>
                  <description>GPT2A DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_DMABREQ</name>
                  <value>80</value>
                  <description>GPT1B DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_DMABREQ</name>
                  <value>79</value>
                  <description>GPT1A DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_DMABREQ</name>
                  <value>78</value>
                  <description>GPT0B DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_DMABREQ</name>
                  <value>77</value>
                  <description>GPT0A DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x50</resetValue>
        </register>
        <register>
          <name>UDMACH13SSEL</name>
          <addressOffset>0x568</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AON_PROG2</name>
                  <value>3</value>
                  <description>AON programmable event 2. Event selected by AON_EVENT MCU event selector, AON_EVENT:EVTOMCUSEL.AON_PROG2_EV</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x3</resetValue>
        </register>
        <register>
          <name>UDMACH13BSEL</name>
          <addressOffset>0x56c</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 13 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AON_PROG2</name>
                  <value>3</value>
                  <description>AON programmable event 2. Event selected by AON_EVENT MCU event selector, AON_EVENT:EVTOMCUSEL.AON_PROG2_EV</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x3</resetValue>
        </register>
        <register>
          <name>UDMACH14SSEL</name>
          <addressOffset>0x570</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AON_PROG0</name>
                  <value>1</value>
                  <description>AON programmable event 0. Event selected by AON_EVENT  MCU event selector, AON_EVENT:EVTOMCUSEL.AON_PROG0_EV</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>UDMACH14BSEL</name>
          <addressOffset>0x574</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 14 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_HALTED</name>
                  <value>120</value>
                  <description>CPU halted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_UPD</name>
                  <value>119</value>
                  <description>RTC periodic event controlled by AON_RTC:CTL.RTC_UPD_EN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_DMABREQ</name>
                  <value>118</value>
                  <description>DMA burst request event from AUX, configured by AUX_EVCTL:DMACTL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_DMASREQ</name>
                  <value>117</value>
                  <description>DMA single request event from AUX, configured by AUX_EVCTL:DMACTL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SW_DMABREQ</name>
                  <value>116</value>
                  <description>DMA sofware trigger from AUX, triggered by AUX_EVCTL:DMASWREQ.START</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_IRQ</name>
                  <value>115</value>
                  <description>AUX ADC interrupt event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_IRQ. Status flags are found here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_OBSMUX0</name>
                  <value>114</value>
                  <description>Loopback of OBSMUX0 through AUX, corresponds to AUX_EVCTL:EVTOMCUFLAGS.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_FIFO_ALMOST_FULL</name>
                  <value>113</value>
                  <description>AUX ADC FIFO watermark event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>112</value>
                  <description>AUX ADC done, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SMPH_AUTOTAKE_DONE</name>
                  <value>111</value>
                  <description>Autotake event from AUX semaphore, configured by AUX_SMPH:AUTOTAKE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>110</value>
                  <description>AUX timer 1 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>109</value>
                  <description>AUX timer 0 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>108</value>
                  <description>AUX TDC measurement done event, corresponds to the flag AUX_EVCTL:EVTOMCUFLAGS.TDC_DONE and the AUX_TDC status AUX_TDC:STAT.DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>107</value>
                  <description>AUX Compare B event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>106</value>
                  <description>AUX Compare A event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_AON_WU_EV</name>
                  <value>105</value>
                  <description>AON wakeup event, corresponds flags are here AUX_EVCTL:EVTOMCUFLAGS.AON_WU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TRNG_IRQ</name>
                  <value>104</value>
                  <description>TRNG Interrupt event, controlled by TRNG:IRQEN.EN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SWEV3</name>
                  <value>103</value>
                  <description>Software event 3, triggered by SWEV.SWEV3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SWEV2</name>
                  <value>102</value>
                  <description>Software event 2, triggered by SWEV.SWEV2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SWEV1</name>
                  <value>101</value>
                  <description>Software event 1, triggered by SWEV.SWEV1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SWEV0</name>
                  <value>100</value>
                  <description>Software event 0, triggered by SWEV.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WDT_NMI</name>
                  <value>99</value>
                  <description>Watchdog non maskable interrupt event, controlled by WDT:CTL.INTTYPE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CRYPTO_DMA_DONE_IRQ</name>
                  <value>94</value>
                  <description>CRYPTO DMA input done event, the correspondingg flag is CRYPTO:IRQSTAT.DMA_IN_DONE. Controlled by CRYPTO:IRQEN.DMA_IN_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CRYPTO_RESULT_AVAIL_IRQ</name>
                  <value>93</value>
                  <description>CRYPTO result available interupt event, the corresponding flag is found here CRYPTO:IRQSTAT.RESULT_AVAIL. Controlled by CRYPTO:IRQSTAT.RESULT_AVAIL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>92</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT7 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>91</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT6 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>90</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT4 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>89</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT4 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>88</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT3 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>87</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT2 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>86</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT1 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>85</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT0 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_DMABREQ</name>
                  <value>84</value>
                  <description>GPT3B DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_DMABREQ</name>
                  <value>83</value>
                  <description>GPT3A DMA trigger event. Configured by GPT3:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_DMABREQ</name>
                  <value>82</value>
                  <description>GPT2B DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_DMABREQ</name>
                  <value>81</value>
                  <description>GPT2A DMA trigger event. Configured by GPT2:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_DMABREQ</name>
                  <value>80</value>
                  <description>GPT1B DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_DMABREQ</name>
                  <value>79</value>
                  <description>GPT1A DMA trigger event. Configured by GPT1:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_DMABREQ</name>
                  <value>78</value>
                  <description>GPT0B DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_DMABREQ</name>
                  <value>77</value>
                  <description>GPT0A DMA trigger event. Configured by GPT0:DMAEV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_CMP</name>
                  <value>68</value>
                  <description>GPT3B compare event. Configured by GPT3:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_CMP</name>
                  <value>67</value>
                  <description>GPT3A compare event. Configured by GPT3:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_CMP</name>
                  <value>66</value>
                  <description>GPT2B compare event. Configured by GPT2:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_CMP</name>
                  <value>65</value>
                  <description>GPT2A compare event. Configured by GPT2:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_CMP</name>
                  <value>64</value>
                  <description>GPT1B compare event. Configured by GPT1:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_CMP</name>
                  <value>63</value>
                  <description>GPT1A compare event. Configured by GPT1:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_CMP</name>
                  <value>62</value>
                  <description>GPT0B compare event. Configured by GPT0:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_CMP</name>
                  <value>61</value>
                  <description>GPT0A compare event. Configured by GPT0:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX_DMASREQ</name>
                  <value>51</value>
                  <description>UART0 TX DMA single request, controlled by UART0:DMACTL.TXDMAE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX_DMABREQ</name>
                  <value>50</value>
                  <description>UART0 TX DMA burst request, controlled by UART0:DMACTL.TXDMAE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX_DMASREQ</name>
                  <value>49</value>
                  <description>UART0 RX DMA single request, controlled by UART0:DMACTL.RXDMAE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX_DMABREQ</name>
                  <value>48</value>
                  <description>UART0 RX DMA burst request, controlled by UART0:DMACTL.RXDMAE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX_DMASREQ</name>
                  <value>47</value>
                  <description>SSI1 TX DMA single request, controlled by SSI0:DMACR.TXDMAE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX_DMABREQ</name>
                  <value>46</value>
                  <description>SSI1 TX DMA burst request , controlled by SSI0:DMACR.TXDMAE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX_DMASREQ</name>
                  <value>45</value>
                  <description>SSI1 RX DMA single request, controlled by SSI0:DMACR.RXDMAE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX_DMABREQ</name>
                  <value>44</value>
                  <description>SSI1 RX DMA burst request , controlled by SSI0:DMACR.RXDMAE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX_DMASREQ</name>
                  <value>43</value>
                  <description>SSI0 TX DMA single request, controlled by SSI0:DMACR.TXDMAE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX_DMABREQ</name>
                  <value>42</value>
                  <description>SSI0 TX DMA burst request , controlled by SSI0:DMACR.TXDMAE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX_DMASREQ</name>
                  <value>41</value>
                  <description>SSI0 RX DMA single request, controlled by SSI0:DMACR.RXDMAE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX_DMABREQ</name>
                  <value>40</value>
                  <description>SSI0 RX DMA burst request , controlled by SSI0:DMACR.RXDMAE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DMA_DONE_COMB</name>
                  <value>39</value>
                  <description>Combined DMA done, corresponding flags are here UDMA0:REQDONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DMA_ERR</name>
                  <value>38</value>
                  <description>DMA bus error, corresponds to UDMA0:ERROR.STATUS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_COMB</name>
                  <value>36</value>
                  <description>UART0 combined interrupt, interrupt flags are found here UART0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_COMB</name>
                  <value>35</value>
                  <description>SSI1 combined interrupt, interrupt flags are found here SSI1:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_COMB</name>
                  <value>34</value>
                  <description>SSI0 combined interrupt, interrupt flags are found here SSI0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_1</name>
                  <value>30</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE1 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SWEV1</name>
                  <value>29</value>
                  <description>AUX software event 1, triggered by AUX_EVCTL:SWEVSET.SWEV1, also available as AUX_EVENT2 AON wake up event.
MCU domain wakeup control AON_EVENT:MCUWUSEL
AUX domain wakeup control AON_EVENT:AUXWUSEL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_0</name>
                  <value>27</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE0 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_HW_COMB</name>
                  <value>26</value>
                  <description>Combined RFC hardware interrupt, corresponding flag is here RFC_DBELL:RFHWIFG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CMD_ACK</name>
                  <value>25</value>
                  <description>RFC Doorbell Command Acknowledgement Interrupt, equvialent to RFC_DBELL:RFACKIFG.ACKFLAG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WDT_IRQ</name>
                  <value>24</value>
                  <description>Watchdog interrupt event, controlled by WDT:CTL.INTEN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DMA_CH18_DONE</name>
                  <value>22</value>
                  <description>DMA done for software tiggered UDMA channel 18, see UDMA0:SOFTREQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLASH</name>
                  <value>21</value>
                  <description>FLASH controller error event,  the status flags are FLASH:FEDACSTAT.FSM_DONE and FLASH:FEDACSTAT.RVF_INT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DMA_CH0_DONE</name>
                  <value>20</value>
                  <description>DMA done for software tiggered UDMA channel 0, see UDMA0:SOFTREQ</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B</name>
                  <value>19</value>
                  <description>GPT1B interrupt event, controlled by GPT1:TBMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A</name>
                  <value>18</value>
                  <description>GPT1A interrupt event, controlled by GPT1:TAMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B</name>
                  <value>17</value>
                  <description>GPT0B interrupt event, controlled by GPT0:TBMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A</name>
                  <value>16</value>
                  <description>GPT0A interrupt event, controlled by GPT0:TAMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B</name>
                  <value>15</value>
                  <description>GPT3B interrupt event, controlled by GPT3:TBMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A</name>
                  <value>14</value>
                  <description>GPT3A interrupt event, controlled by GPT3:TAMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B</name>
                  <value>13</value>
                  <description>GPT2B interrupt event, controlled by GPT2:TBMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A</name>
                  <value>12</value>
                  <description>GPT2A interrupt event, controlled by GPT2:TAMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMB</name>
                  <value>11</value>
                  <description>AUX combined event, the corresponding flag register is here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_AUX_SWEV0</name>
                  <value>10</value>
                  <description>AUX Software event 0, AUX_EVCTL:SWEVSET.SWEV0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_IRQ</name>
                  <value>9</value>
                  <description>Interrupt event from I2C</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_IRQ</name>
                  <value>8</value>
                  <description>Interrupt event from I2S</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_COMB</name>
                  <value>7</value>
                  <description>Event from AON_RTC, controlled by the AON_RTC:CTL.COMB_EV_MASK setting</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_GPIO_EDGE</name>
                  <value>4</value>
                  <description>Edge detect event from IOC. Configureded by the IOC:IOCFGn.EDGE_IRQ_EN and  IOC:IOCFGn.EDGE_DET settings</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG2</name>
                  <value>3</value>
                  <description>AON programmable event 2. Event selected by AON_EVENT MCU event selector, AON_EVENT:EVTOMCUSEL.AON_PROG2_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG1</name>
                  <value>2</value>
                  <description>AON programmable event 1. Event selected by AON_EVENT MCU event selector, AON_EVENT:EVTOMCUSEL.AON_PROG1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_PROG0</name>
                  <value>1</value>
                  <description>AON programmable event 0. Event selected by AON_EVENT  MCU event selector, AON_EVENT:EVTOMCUSEL.AON_PROG0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>UDMACH15SSEL</name>
          <addressOffset>0x578</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AON_RTC_COMB</name>
                  <value>7</value>
                  <description>Event from AON_RTC, controlled by the AON_RTC:CTL.COMB_EV_MASK setting</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x7</resetValue>
        </register>
        <register>
          <name>UDMACH15BSEL</name>
          <addressOffset>0x57c</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 15 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AON_RTC_COMB</name>
                  <value>7</value>
                  <description>Event from AON_RTC, controlled by the AON_RTC:CTL.COMB_EV_MASK setting</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x7</resetValue>
        </register>
        <register>
          <name>UDMACH16SSEL</name>
          <addressOffset>0x580</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 16 SREQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI1_RX_DMASREQ</name>
                  <value>45</value>
                  <description>SSI1 RX DMA single request, controlled by SSI0:DMACR.RXDMAE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x2D</resetValue>
        </register>
        <register>
          <name>UDMACH16BSEL</name>
          <addressOffset>0x584</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 16 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI1_RX_DMABREQ</name>
                  <value>44</value>
                  <description>SSI1 RX DMA burst request , controlled by SSI0:DMACR.RXDMAE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x2C</resetValue>
        </register>
        <register>
          <name>UDMACH17SSEL</name>
          <addressOffset>0x588</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 17 SREQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI1_TX_DMASREQ</name>
                  <value>47</value>
                  <description>SSI1 TX DMA single request, controlled by SSI0:DMACR.TXDMAE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x2F</resetValue>
        </register>
        <register>
          <name>UDMACH17BSEL</name>
          <addressOffset>0x58c</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 17 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI1_TX_DMABREQ</name>
                  <value>46</value>
                  <description>SSI1 TX DMA burst request , controlled by SSI0:DMACR.TXDMAE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x2E</resetValue>
        </register>
        <register>
          <name>UDMACH18SSEL</name>
          <addressOffset>0x590</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH18BSEL</name>
          <addressOffset>0x594</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH19SSEL</name>
          <addressOffset>0x598</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH19BSEL</name>
          <addressOffset>0x59c</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH20SSEL</name>
          <addressOffset>0x5a0</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH20BSEL</name>
          <addressOffset>0x5a4</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH21SSEL</name>
          <addressOffset>0x5a8</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 21 SREQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SWEV0</name>
                  <value>100</value>
                  <description>Software event 0, triggered by SWEV.SWEV0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x64</resetValue>
        </register>
        <register>
          <name>UDMACH21BSEL</name>
          <addressOffset>0x5ac</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 21 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SWEV0</name>
                  <value>100</value>
                  <description>Software event 0, triggered by SWEV.SWEV0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x64</resetValue>
        </register>
        <register>
          <name>UDMACH22SSEL</name>
          <addressOffset>0x5b0</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 22 SREQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SWEV1</name>
                  <value>101</value>
                  <description>Software event 1, triggered by SWEV.SWEV1</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x65</resetValue>
        </register>
        <register>
          <name>UDMACH22BSEL</name>
          <addressOffset>0x5b4</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 22 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SWEV1</name>
                  <value>101</value>
                  <description>Software event 1, triggered by SWEV.SWEV1</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x65</resetValue>
        </register>
        <register>
          <name>UDMACH23SSEL</name>
          <addressOffset>0x5b8</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 23 SREQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SWEV2</name>
                  <value>102</value>
                  <description>Software event 2, triggered by SWEV.SWEV2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x66</resetValue>
        </register>
        <register>
          <name>UDMACH23BSEL</name>
          <addressOffset>0x5bc</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 23 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SWEV2</name>
                  <value>102</value>
                  <description>Software event 2, triggered by SWEV.SWEV2</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x66</resetValue>
        </register>
        <register>
          <name>UDMACH24SSEL</name>
          <addressOffset>0x5c0</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 24 SREQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SWEV3</name>
                  <value>103</value>
                  <description>Software event 3, triggered by SWEV.SWEV3</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x67</resetValue>
        </register>
        <register>
          <name>UDMACH24BSEL</name>
          <addressOffset>0x5c4</addressOffset>
          <size>32</size>
          <description>Output Selection for DMA Channel 24 REQ</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SWEV3</name>
                  <value>103</value>
                  <description>Software event 3, triggered by SWEV.SWEV3</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x67</resetValue>
        </register>
        <register>
          <name>UDMACH25SSEL</name>
          <addressOffset>0x5c8</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH25BSEL</name>
          <addressOffset>0x5cc</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH26SSEL</name>
          <addressOffset>0x5d0</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH26BSEL</name>
          <addressOffset>0x5d4</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH27SSEL</name>
          <addressOffset>0x5d8</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH27BSEL</name>
          <addressOffset>0x5dc</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH28SSEL</name>
          <addressOffset>0x5e0</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH28BSEL</name>
          <addressOffset>0x5e4</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH29SSEL</name>
          <addressOffset>0x5e8</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH29BSEL</name>
          <addressOffset>0x5ec</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH30SSEL</name>
          <addressOffset>0x5f0</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH30BSEL</name>
          <addressOffset>0x5f4</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH31SSEL</name>
          <addressOffset>0x5f8</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UDMACH31BSEL</name>
          <addressOffset>0x5fc</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>EV</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPT3ACAPTSEL</name>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <description>Output Selection for GPT3 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_UPD</name>
                  <value>119</value>
                  <description>RTC periodic event controlled by AON_RTC:CTL.RTC_UPD_EN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_IRQ</name>
                  <value>115</value>
                  <description>AUX ADC interrupt event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_IRQ. Status flags are found here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_OBSMUX0</name>
                  <value>114</value>
                  <description>Loopback of OBSMUX0 through AUX, corresponds to AUX_EVCTL:EVTOMCUFLAGS.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_FIFO_ALMOST_FULL</name>
                  <value>113</value>
                  <description>AUX ADC FIFO watermark event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>112</value>
                  <description>AUX ADC done, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SMPH_AUTOTAKE_DONE</name>
                  <value>111</value>
                  <description>Autotake event from AUX semaphore, configured by AUX_SMPH:AUTOTAKE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>110</value>
                  <description>AUX timer 1 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>109</value>
                  <description>AUX timer 0 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>108</value>
                  <description>AUX TDC measurement done event, corresponds to the flag AUX_EVCTL:EVTOMCUFLAGS.TDC_DONE and the AUX_TDC status AUX_TDC:STAT.DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>107</value>
                  <description>AUX Compare B event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>106</value>
                  <description>AUX Compare A event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_AON_WU_EV</name>
                  <value>105</value>
                  <description>AON wakeup event, corresponds flags are here AUX_EVCTL:EVTOMCUFLAGS.AON_WU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>92</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT7 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>91</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT6 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_CMP</name>
                  <value>68</value>
                  <description>GPT3B compare event. Configured by GPT3:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_CMP</name>
                  <value>67</value>
                  <description>GPT3A compare event. Configured by GPT3:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_CMP</name>
                  <value>66</value>
                  <description>GPT2B compare event. Configured by GPT2:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_CMP</name>
                  <value>65</value>
                  <description>GPT2A compare event. Configured by GPT2:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_CMP</name>
                  <value>64</value>
                  <description>GPT1B compare event. Configured by GPT1:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_CMP</name>
                  <value>63</value>
                  <description>GPT1A compare event. Configured by GPT1:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_CMP</name>
                  <value>62</value>
                  <description>GPT0B compare event. Configured by GPT0:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_CMP</name>
                  <value>61</value>
                  <description>GPT0A compare event. Configured by GPT0:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_COMB</name>
                  <value>36</value>
                  <description>UART0 combined interrupt, interrupt flags are found here UART0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_COMB</name>
                  <value>35</value>
                  <description>SSI1 combined interrupt, interrupt flags are found here SSI1:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_COMB</name>
                  <value>34</value>
                  <description>SSI0 combined interrupt, interrupt flags are found here SSI0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_1</name>
                  <value>30</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE1 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_0</name>
                  <value>27</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE0 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_HW_COMB</name>
                  <value>26</value>
                  <description>Combined RFC hardware interrupt, corresponding flag is here RFC_DBELL:RFHWIFG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CMD_ACK</name>
                  <value>25</value>
                  <description>RFC Doorbell Command Acknowledgement Interrupt, equvialent to RFC_DBELL:RFACKIFG.ACKFLAG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLASH</name>
                  <value>21</value>
                  <description>FLASH controller error event,  the status flags are FLASH:FEDACSTAT.FSM_DONE and FLASH:FEDACSTAT.RVF_INT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMB</name>
                  <value>11</value>
                  <description>AUX combined event, the corresponding flag register is here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_COMB</name>
                  <value>7</value>
                  <description>Event from AON_RTC, controlled by the AON_RTC:CTL.COMB_EV_MASK setting</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_GPIO_EDGE</name>
                  <value>4</value>
                  <description>Edge detect event from IOC. Configureded by the IOC:IOCFGn.EDGE_IRQ_EN and  IOC:IOCFGn.EDGE_DET settings</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x5B</resetValue>
        </register>
        <register>
          <name>GPT3BCAPTSEL</name>
          <addressOffset>0x604</addressOffset>
          <size>32</size>
          <description>Output Selection for GPT3 1</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_UPD</name>
                  <value>119</value>
                  <description>RTC periodic event controlled by AON_RTC:CTL.RTC_UPD_EN</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_IRQ</name>
                  <value>115</value>
                  <description>AUX ADC interrupt event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_IRQ. Status flags are found here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_OBSMUX0</name>
                  <value>114</value>
                  <description>Loopback of OBSMUX0 through AUX, corresponds to AUX_EVCTL:EVTOMCUFLAGS.OBSMUX0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_FIFO_ALMOST_FULL</name>
                  <value>113</value>
                  <description>AUX ADC FIFO watermark event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_FIFO_ALMOST_FULL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_ADC_DONE</name>
                  <value>112</value>
                  <description>AUX ADC done, corresponds to AUX_EVCTL:EVTOMCUFLAGS.ADC_DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_SMPH_AUTOTAKE_DONE</name>
                  <value>111</value>
                  <description>Autotake event from AUX semaphore, configured by AUX_SMPH:AUTOTAKE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER1_EV</name>
                  <value>110</value>
                  <description>AUX timer 1 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER1_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TIMER0_EV</name>
                  <value>109</value>
                  <description>AUX timer 0 event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.TIMER0_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_TDC_DONE</name>
                  <value>108</value>
                  <description>AUX TDC measurement done event, corresponds to the flag AUX_EVCTL:EVTOMCUFLAGS.TDC_DONE and the AUX_TDC status AUX_TDC:STAT.DONE</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPB</name>
                  <value>107</value>
                  <description>AUX Compare B event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPB</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMPA</name>
                  <value>106</value>
                  <description>AUX Compare A event, corresponds to AUX_EVCTL:EVTOMCUFLAGS.AUX_COMPA</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_AON_WU_EV</name>
                  <value>105</value>
                  <description>AON wakeup event, corresponds flags are here AUX_EVCTL:EVTOMCUFLAGS.AON_WU_EV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>92</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT7 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>91</value>
                  <description>Port capture event from IOC, configured by IOC:IOCFGn.PORT_ID. Events on ports configured with ENUM PORT_EVENT6 wil be routed here.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B_CMP</name>
                  <value>68</value>
                  <description>GPT3B compare event. Configured by GPT3:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A_CMP</name>
                  <value>67</value>
                  <description>GPT3A compare event. Configured by GPT3:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B_CMP</name>
                  <value>66</value>
                  <description>GPT2B compare event. Configured by GPT2:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A_CMP</name>
                  <value>65</value>
                  <description>GPT2A compare event. Configured by GPT2:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B_CMP</name>
                  <value>64</value>
                  <description>GPT1B compare event. Configured by GPT1:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A_CMP</name>
                  <value>63</value>
                  <description>GPT1A compare event. Configured by GPT1:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B_CMP</name>
                  <value>62</value>
                  <description>GPT0B compare event. Configured by GPT0:TBMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A_CMP</name>
                  <value>61</value>
                  <description>GPT0A compare event. Configured by GPT0:TAMR.TCACT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_COMB</name>
                  <value>36</value>
                  <description>UART0 combined interrupt, interrupt flags are found here UART0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_COMB</name>
                  <value>35</value>
                  <description>SSI1 combined interrupt, interrupt flags are found here SSI1:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_COMB</name>
                  <value>34</value>
                  <description>SSI0 combined interrupt, interrupt flags are found here SSI0:MIS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_1</name>
                  <value>30</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE1 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_1 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CPE_0</name>
                  <value>27</value>
                  <description>Combined Interrupt for CPE Generated events. Corresponding flags are here RFC_DBELL:RFCPEIFG. Only interrupts selected with CPE0 in RFC_DBELL:RFCPEIFG can trigger a RFC_CPE_0 event</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_HW_COMB</name>
                  <value>26</value>
                  <description>Combined RFC hardware interrupt, corresponding flag is here RFC_DBELL:RFHWIFG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_CMD_ACK</name>
                  <value>25</value>
                  <description>RFC Doorbell Command Acknowledgement Interrupt, equvialent to RFC_DBELL:RFACKIFG.ACKFLAG</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FLASH</name>
                  <value>21</value>
                  <description>FLASH controller error event,  the status flags are FLASH:FEDACSTAT.FSM_DONE and FLASH:FEDACSTAT.RVF_INT</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_COMB</name>
                  <value>11</value>
                  <description>AUX combined event, the corresponding flag register is here AUX_EVCTL:EVTOMCUFLAGS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_RTC_COMB</name>
                  <value>7</value>
                  <description>Event from AON_RTC, controlled by the AON_RTC:CTL.COMB_EV_MASK setting</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_GPIO_EDGE</name>
                  <value>4</value>
                  <description>Edge detect event from IOC. Configureded by the IOC:IOCFGn.EDGE_IRQ_EN and  IOC:IOCFGn.EDGE_DET settings</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x5C</resetValue>
        </register>
        <register>
          <name>AUXSEL0</name>
          <addressOffset>0x700</addressOffset>
          <size>32</size>
          <description>Output Selection for AUX Subscriber 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1B</name>
                  <value>19</value>
                  <description>GPT1B interrupt event, controlled by GPT1:TBMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1A</name>
                  <value>18</value>
                  <description>GPT1A interrupt event, controlled by GPT1:TAMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0B</name>
                  <value>17</value>
                  <description>GPT0B interrupt event, controlled by GPT0:TBMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0A</name>
                  <value>16</value>
                  <description>GPT0A interrupt event, controlled by GPT0:TAMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3B</name>
                  <value>15</value>
                  <description>GPT3B interrupt event, controlled by GPT3:TBMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT3A</name>
                  <value>14</value>
                  <description>GPT3A interrupt event, controlled by GPT3:TAMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2B</name>
                  <value>13</value>
                  <description>GPT2B interrupt event, controlled by GPT2:TBMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2A</name>
                  <value>12</value>
                  <description>GPT2A interrupt event, controlled by GPT2:TAMR</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x10</resetValue>
        </register>
        <register>
          <name>CM3NMISEL0</name>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <description>Output Selection for NMI Subscriber 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read only selection value</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WDT_NMI</name>
                  <value>99</value>
                  <description>Watchdog non maskable interrupt event, controlled by WDT:CTL.INTTYPE</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x63</resetValue>
        </register>
        <register>
          <name>I2SSTMPSEL0</name>
          <addressOffset>0x900</addressOffset>
          <size>32</size>
          <description>Output Selection for I2S Subscriber 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x5F</resetValue>
        </register>
        <register>
          <name>FRZSEL0</name>
          <addressOffset>0xa00</addressOffset>
          <size>32</size>
          <description>Output Selection for FRZ Subscriber
The halted debug signal is passed to peripherals such as the General Purpose Timer, Sensor Controller with Digital and Analog Peripherals (AUX), Radio, and RTC. When the system CPU halts, the connected peripherals that have freeze enabled also halt. The programmable output can be set to static values of 0 or 1, and can also be set to pass the halted signal.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[6:0] Read/write selection value

Writing any other value than values defined by a ENUM may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ALWAYS_ACTIVE</name>
                  <value>121</value>
                  <description>Always asserted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_HALTED</name>
                  <value>120</value>
                  <description>CPU halted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>Always inactive</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x78</resetValue>
        </register>
        <register>
          <name>SWEV</name>
          <addressOffset>0xf00</addressOffset>
          <size>32</size>
          <description>Set or Clear Software Events</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>SWEV3</name>
              <description>[24:24] Writing "1" to this bit when the value is "0" triggers the Software 3 event.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[23:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>SWEV2</name>
              <description>[16:16] Writing "1" to this bit when the value is "0" triggers the Software 2 event.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[15:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>SWEV1</name>
              <description>[8:8] Writing "1" to this bit when the value is "0" triggers the Software 1 event.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SWEV0</name>
              <description>[0:0] Writing "1" to this bit when the value is "0" triggers the Software 0 event.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FCFG1</name>
      <baseAddress>0x50001000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Factory configuration area (FCFG1)</description>
      <registers>
        <register>
          <name>MISC_CONF_1</name>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <description>Misc configurations</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DEVICE_MINOR_REV</name>
              <description>[7:0] HW minor revision number (a value of 0xFF shall be treated equally to 0x00).
Any test of this field by SW should be implemented as a 'greater or equal' comparison as signed integer.
Value may change without warning.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFF00</resetValue>
        </register>
        <register>
          <name>MISC_CONF_2</name>
          <addressOffset>0xa4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>HPOSC_COMP_P3</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFF00</resetValue>
        </register>
        <register>
          <name>CONFIG_RF_FRONTEND_DIV5</name>
          <addressOffset>0xc4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>IFAMP_IB</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>LNA_IB</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>IFAMP_TRIM</name>
              <description>[23:19] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CTL_PA0_TRIM</name>
              <description>[18:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[13:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RFLDO_TRIM_OUTPUT</name>
              <description>[6:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x70003F80</resetValue>
        </register>
        <register>
          <name>CONFIG_RF_FRONTEND_DIV6</name>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>IFAMP_IB</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>LNA_IB</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>IFAMP_TRIM</name>
              <description>[23:19] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CTL_PA0_TRIM</name>
              <description>[18:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[13:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RFLDO_TRIM_OUTPUT</name>
              <description>[6:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x70003F80</resetValue>
        </register>
        <register>
          <name>CONFIG_RF_FRONTEND_DIV10</name>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>IFAMP_IB</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>LNA_IB</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>IFAMP_TRIM</name>
              <description>[23:19] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CTL_PA0_TRIM</name>
              <description>[18:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[13:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RFLDO_TRIM_OUTPUT</name>
              <description>[6:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x70003F80</resetValue>
        </register>
        <register>
          <name>CONFIG_RF_FRONTEND_DIV12</name>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>IFAMP_IB</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>LNA_IB</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>IFAMP_TRIM</name>
              <description>[23:19] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CTL_PA0_TRIM</name>
              <description>[18:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[13:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RFLDO_TRIM_OUTPUT</name>
              <description>[6:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x70003F80</resetValue>
        </register>
        <register>
          <name>CONFIG_RF_FRONTEND_DIV15</name>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>IFAMP_IB</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>LNA_IB</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>IFAMP_TRIM</name>
              <description>[23:19] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CTL_PA0_TRIM</name>
              <description>[18:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[13:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RFLDO_TRIM_OUTPUT</name>
              <description>[6:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x70003F80</resetValue>
        </register>
        <register>
          <name>CONFIG_RF_FRONTEND_DIV30</name>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>IFAMP_IB</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>LNA_IB</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>IFAMP_TRIM</name>
              <description>[23:19] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CTL_PA0_TRIM</name>
              <description>[18:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[13:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RFLDO_TRIM_OUTPUT</name>
              <description>[6:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x70003F80</resetValue>
        </register>
        <register>
          <name>CONFIG_SYNTH_DIV5</name>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DISABLE_CORNER_CAP</name>
              <description>[28:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>RFC_MDM_DEMIQMC0</name>
              <description>[27:12] Trim value for RF Core.
Value is read by RF Core ROM FW during RF Core initialization.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>LDOVCO_TRIM_OUTPUT</name>
              <description>[11:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SLDO_TRIM_OUTPUT</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xE0000000</resetValue>
        </register>
        <register>
          <name>CONFIG_SYNTH_DIV6</name>
          <addressOffset>0xe0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DISABLE_CORNER_CAP</name>
              <description>[28:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>RFC_MDM_DEMIQMC0</name>
              <description>[27:12] Trim value for RF Core.
Value is read by RF Core ROM FW during RF Core initialization.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>LDOVCO_TRIM_OUTPUT</name>
              <description>[11:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SLDO_TRIM_OUTPUT</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xE0000000</resetValue>
        </register>
        <register>
          <name>CONFIG_SYNTH_DIV10</name>
          <addressOffset>0xe4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DISABLE_CORNER_CAP</name>
              <description>[28:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>RFC_MDM_DEMIQMC0</name>
              <description>[27:12] Trim value for RF Core.
Value is read by RF Core ROM FW during RF Core initialization.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>LDOVCO_TRIM_OUTPUT</name>
              <description>[11:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SLDO_TRIM_OUTPUT</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xE0000000</resetValue>
        </register>
        <register>
          <name>CONFIG_SYNTH_DIV12</name>
          <addressOffset>0xe8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DISABLE_CORNER_CAP</name>
              <description>[28:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>RFC_MDM_DEMIQMC0</name>
              <description>[27:12] Trim value for RF Core.
Value is read by RF Core ROM FW during RF Core initialization.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>LDOVCO_TRIM_OUTPUT</name>
              <description>[11:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SLDO_TRIM_OUTPUT</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xE0000000</resetValue>
        </register>
        <register>
          <name>CONFIG_SYNTH_DIV15</name>
          <addressOffset>0xec</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DISABLE_CORNER_CAP</name>
              <description>[28:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>RFC_MDM_DEMIQMC0</name>
              <description>[27:12] Trim value for RF Core.
Value is read by RF Core ROM FW during RF Core initialization.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>LDOVCO_TRIM_OUTPUT</name>
              <description>[11:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SLDO_TRIM_OUTPUT</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xE0000000</resetValue>
        </register>
        <register>
          <name>CONFIG_SYNTH_DIV30</name>
          <addressOffset>0xf0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DISABLE_CORNER_CAP</name>
              <description>[28:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>RFC_MDM_DEMIQMC0</name>
              <description>[27:12] Trim value for RF Core.
Value is read by RF Core ROM FW during RF Core initialization.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>LDOVCO_TRIM_OUTPUT</name>
              <description>[11:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SLDO_TRIM_OUTPUT</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xE0000000</resetValue>
        </register>
        <register>
          <name>CONFIG_MISC_ADC_DIV5</name>
          <addressOffset>0xf4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>MIN_ALLOWED_RTRIM</name>
              <description>[21:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RSSI_OFFSET</name>
              <description>[16:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>QUANTCTLTHRES</name>
              <description>[8:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DACTRIM</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFC2014D</resetValue>
        </register>
        <register>
          <name>CONFIG_MISC_ADC_DIV6</name>
          <addressOffset>0xf8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>MIN_ALLOWED_RTRIM</name>
              <description>[21:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RSSI_OFFSET</name>
              <description>[16:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>QUANTCTLTHRES</name>
              <description>[8:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DACTRIM</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFC2014D</resetValue>
        </register>
        <register>
          <name>CONFIG_MISC_ADC_DIV10</name>
          <addressOffset>0xfc</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>MIN_ALLOWED_RTRIM</name>
              <description>[21:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RSSI_OFFSET</name>
              <description>[16:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>QUANTCTLTHRES</name>
              <description>[8:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DACTRIM</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFC2014D</resetValue>
        </register>
        <register>
          <name>CONFIG_MISC_ADC_DIV12</name>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>MIN_ALLOWED_RTRIM</name>
              <description>[21:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RSSI_OFFSET</name>
              <description>[16:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>QUANTCTLTHRES</name>
              <description>[8:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DACTRIM</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFC2014D</resetValue>
        </register>
        <register>
          <name>CONFIG_MISC_ADC_DIV15</name>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>MIN_ALLOWED_RTRIM</name>
              <description>[21:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RSSI_OFFSET</name>
              <description>[16:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>QUANTCTLTHRES</name>
              <description>[8:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DACTRIM</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFC2014D</resetValue>
        </register>
        <register>
          <name>CONFIG_MISC_ADC_DIV30</name>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>MIN_ALLOWED_RTRIM</name>
              <description>[21:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RSSI_OFFSET</name>
              <description>[16:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>QUANTCTLTHRES</name>
              <description>[8:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DACTRIM</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFC2014D</resetValue>
        </register>
        <register>
          <name>SHDW_DIE_ID_0</name>
          <addressOffset>0x118</addressOffset>
          <size>32</size>
          <description>Shadow of the DIE_ID_0 register in eFuse</description>
          <fields>
            <field>
              <name>ID_31_0</name>
              <description>[31:0] Shadow of the DIE_ID_0 register in eFuse row number 3</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SHDW_DIE_ID_1</name>
          <addressOffset>0x11c</addressOffset>
          <size>32</size>
          <description>Shadow of the DIE_ID_1 register in eFuse</description>
          <fields>
            <field>
              <name>ID_63_32</name>
              <description>[31:0] Shadow of the DIE_ID_1 register in eFuse row number 4</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SHDW_DIE_ID_2</name>
          <addressOffset>0x120</addressOffset>
          <size>32</size>
          <description>Shadow of the DIE_ID_2 register in eFuse</description>
          <fields>
            <field>
              <name>ID_95_64</name>
              <description>[31:0] Shadow of the DIE_ID_2 register in eFuse row number 5</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SHDW_DIE_ID_3</name>
          <addressOffset>0x124</addressOffset>
          <size>32</size>
          <description>Shadow of the DIE_ID_3 register in eFuse</description>
          <fields>
            <field>
              <name>ID_127_96</name>
              <description>[31:0] Shadow of the DIE_ID_3 register in eFuse row number 6</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SHDW_OSC_BIAS_LDO_TRIM</name>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>SET_RCOSC_HF_COARSE_RESISTOR</name>
              <description>[28:27] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>TRIMMAG</name>
              <description>[26:23] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>TRIMIREF</name>
              <description>[22:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>ITRIM_DIG_LDO</name>
              <description>[17:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VTRIM_DIG</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>VTRIM_COARSE</name>
              <description>[11:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RCOSCHF_CTRIM</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SHDW_ANA_TRIM</name>
          <addressOffset>0x13c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:27] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>BOD_BANDGAP_TRIM_CNF</name>
              <description>[26:25] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>VDDR_ENABLE_PG1</name>
              <description>[24:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>VDDR_OK_HYS</name>
              <description>[23:23] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>IPTAT_TRIM</name>
              <description>[22:21] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>VDDR_TRIM</name>
              <description>[20:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TRIMBOD_INTMODE</name>
              <description>[15:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>TRIMBOD_EXTMODE</name>
              <description>[10:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TRIMTEMP</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FLASH_NUMBER</name>
          <addressOffset>0x164</addressOffset>
          <size>32</size>
          <description>FLASH_NUMBER</description>
          <fields>
            <field>
              <name>LOT_NUMBER</name>
              <description>[31:0] Number of the manufacturing lot that produced this unit.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FLASH_COORDINATE</name>
          <addressOffset>0x16c</addressOffset>
          <size>32</size>
          <description>FLASH_COORDINATE</description>
          <fields>
            <field>
              <name>XCOORDINATE</name>
              <description>[31:16] X coordinate of this unit on the wafer.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>YCOORDINATE</name>
              <description>[15:0] Y coordinate of this unit on the wafer.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FLASH_E_P</name>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>PSU</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>ESU</name>
              <description>[23:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PVSU</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EVSU</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x17331A33</resetValue>
        </register>
        <register>
          <name>FLASH_C_E_P_R</name>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RVSU</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>PV_ACCESS</name>
              <description>[23:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>A_EXEZ_SETUP</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CVSU</name>
              <description>[11:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xA0A2000</resetValue>
        </register>
        <register>
          <name>FLASH_P_R_PV</name>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>PH</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RH</name>
              <description>[23:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PVH</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PVH2</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x26E0200</resetValue>
        </register>
        <register>
          <name>FLASH_EH_SEQ</name>
          <addressOffset>0x17c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>EH</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>SEQ</name>
              <description>[23:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VSTAT</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>SM_FREQUENCY</name>
              <description>[11:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x200F000</resetValue>
        </register>
        <register>
          <name>FLASH_VHV_E</name>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>VHV_E_START</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VHV_E_STEP_HIGHT</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>FLASH_PP</name>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>PUMP_SU</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[23:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MAX_PP</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x14</resetValue>
        </register>
        <register>
          <name>FLASH_PROG_EP</name>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>MAX_EP</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PROGRAM_PW</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFA00010</resetValue>
        </register>
        <register>
          <name>FLASH_ERA_PW</name>
          <addressOffset>0x18c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>ERASE_PW</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFA0</resetValue>
        </register>
        <register>
          <name>FLASH_VHV</name>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>TRIM13_P</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[23:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>VHV_P</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TRIM13_E</name>
              <description>[11:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[7:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>VHV_E</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x4</resetValue>
        </register>
        <register>
          <name>FLASH_VHV_PV</name>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>TRIM13_PV</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[23:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>VHV_PV</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VCG2P5</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VINH</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x80001</resetValue>
        </register>
        <register>
          <name>FLASH_V</name>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>VSL_P</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>VWL_P</name>
              <description>[23:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>V_READ</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>USER_ID</name>
          <addressOffset>0x294</addressOffset>
          <size>32</size>
          <description>User Identification.
Reading this register and the ICEPICK_DEVICE_ID register is the only support way of identifying a device.
The value of this register will be written to AON_WUC:JTAGUSERCODE by boot FW while in safezone.</description>
          <fields>
            <field>
              <name>PG_REV</name>
              <description>[31:28] Field used to distinguish revisions of the device.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>VER</name>
              <description>[27:26] Version number.

0x0: Bits [25:12] of this register has the stated meaning.

Any other setting indicate a different encoding of these bits.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>RESERVED23</name>
              <description>[25:23] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>SEQUENCE</name>
              <description>[22:19] Sequence.

Used to differentiate between marketing/orderable product where other fields of USER_ID is the same (temp range, flash size, voltage range etc)</description>
              <bitWidth>4</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>PKG</name>
              <description>[18:16] Package type.

0x0: 4x4mm QFN (RHB) package
0x1: 5x5mm QFN (RSM) package
0x2: 7x7mm QFN (RGZ) package
0x3: Wafer sale package (naked die)
0x4: 2.7x2.7mm WCSP (YFV)
0x5: 7x7mm QFN package with Wettable Flanks

Other values are reserved for future use.
Packages available for a specific device are shown in the device datasheet.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PROTOCOL</name>
              <description>[15:12] Protocols supported.

0x1: BLE 
0x2: RF4CE 
0x4: Zigbee/6lowpan
0x8: Proprietary

More than one protocol can be supported on same device - values above are then combined.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[11:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FLASH_OTP_DATA3</name>
          <addressOffset>0x2b0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>EC_STEP_SIZE</name>
              <description>[31:23] Internal. Only to be used through TI provided API.</description>
              <bitWidth>9</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>DO_PRECOND</name>
              <description>[22:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>MAX_EC_LEVEL</name>
              <description>[21:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>TRIM_1P7</name>
              <description>[17:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>FLASH_SIZE</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>WAIT_SYSCODE</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x110003</resetValue>
        </register>
        <register>
          <name>ANA2_TRIM</name>
          <addressOffset>0x2b4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RCOSCHFCTRIMFRACT_EN</name>
              <description>[31:31] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>RCOSCHFCTRIMFRACT</name>
              <description>[30:26] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[25:25] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>SET_RCOSC_HF_FINE_RESISTOR</name>
              <description>[24:23] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>ATESTLF_UDIGLDO_IBIAS_TRIM</name>
              <description>[22:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>NANOAMP_RES_TRIM</name>
              <description>[21:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DITHER_EN</name>
              <description>[11:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>DCDC_IPEAK</name>
              <description>[10:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DEAD_TIME_TRIM</name>
              <description>[7:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DCDC_LOW_EN_SEL</name>
              <description>[5:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DCDC_HIGH_EN_SEL</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x8240F87F</resetValue>
        </register>
        <register>
          <name>LDO_TRIM</name>
          <addressOffset>0x2b8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>VDDR_TRIM_SLEEP</name>
              <description>[28:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[23:19] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>GLDO_CURSRC</name>
              <description>[18:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[15:13] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>ITRIM_DIGLDO_LOAD</name>
              <description>[12:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>ITRIM_UDIGLDO</name>
              <description>[10:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>VTRIM_DELTA</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xE0F8E0FB</resetValue>
        </register>
        <register>
          <name>BAT_RC_LDO_TRIM</name>
          <addressOffset>0x2bc</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>VTRIM_BOD</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[23:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>VTRIM_UDIG</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RCOSCHF_ITUNE_TRIM</name>
              <description>[11:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MEASUREPER</name>
              <description>[1:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xF0F0F0FC</resetValue>
        </register>
        <register>
          <name>MAC_BLE_0</name>
          <addressOffset>0x2e8</addressOffset>
          <size>32</size>
          <description>MAC BLE Address 0</description>
          <fields>
            <field>
              <name>ADDR_0_31</name>
              <description>[31:0] The first 32-bits of the 64-bit MAC BLE address</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MAC_BLE_1</name>
          <addressOffset>0x2ec</addressOffset>
          <size>32</size>
          <description>MAC BLE Address 1</description>
          <fields>
            <field>
              <name>ADDR_32_63</name>
              <description>[31:0] The last 32-bits of the 64-bit MAC BLE address</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MAC_15_4_0</name>
          <addressOffset>0x2f0</addressOffset>
          <size>32</size>
          <description>MAC IEEE 802.15.4 Address 0</description>
          <fields>
            <field>
              <name>ADDR_0_31</name>
              <description>[31:0] The first 32-bits of the 64-bit MAC 15.4 address</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MAC_15_4_1</name>
          <addressOffset>0x2f4</addressOffset>
          <size>32</size>
          <description>MAC IEEE 802.15.4 Address 1</description>
          <fields>
            <field>
              <name>ADDR_32_63</name>
              <description>[31:0] The last 32-bits of the 64-bit MAC 15.4 address</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FLASH_OTP_DATA4</name>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>STANDBY_MODE_SEL_INT_WRT</name>
              <description>[31:31] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>STANDBY_PW_SEL_INT_WRT</name>
              <description>[30:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DIS_STANDBY_INT_WRT</name>
              <description>[28:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>DIS_IDLE_INT_WRT</name>
              <description>[27:27] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>VIN_AT_X_INT_WRT</name>
              <description>[26:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>STANDBY_MODE_SEL_EXT_WRT</name>
              <description>[23:23] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>STANDBY_PW_SEL_EXT_WRT</name>
              <description>[22:21] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>DIS_STANDBY_EXT_WRT</name>
              <description>[20:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>DIS_IDLE_EXT_WRT</name>
              <description>[19:19] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>VIN_AT_X_EXT_WRT</name>
              <description>[18:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>STANDBY_MODE_SEL_INT_RD</name>
              <description>[15:15] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>STANDBY_PW_SEL_INT_RD</name>
              <description>[14:13] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>DIS_STANDBY_INT_RD</name>
              <description>[12:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DIS_IDLE_INT_RD</name>
              <description>[11:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>VIN_AT_X_INT_RD</name>
              <description>[10:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>STANDBY_MODE_SEL_EXT_RD</name>
              <description>[7:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>STANDBY_PW_SEL_EXT_RD</name>
              <description>[6:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>DIS_STANDBY_EXT_RD</name>
              <description>[4:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DIS_IDLE_EXT_RD</name>
              <description>[3:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>VIN_AT_X_EXT_RD</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x98989F9F</resetValue>
        </register>
        <register>
          <name>MISC_TRIM</name>
          <addressOffset>0x30c</addressOffset>
          <size>32</size>
          <description>Miscellaneous Trim  Parameters</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TEMPVSLOPE</name>
              <description>[7:0] Signed byte value representing the TEMP slope with battery voltage, in degrees C / V, with four fractional bits.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFF33</resetValue>
        </register>
        <register>
          <name>RCOSC_HF_TEMPCOMP</name>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FINE_RESISTOR</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>CTRIM</name>
              <description>[23:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CTRIMFRACT_QUAD</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CTRIMFRACT_SLOPE</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3</resetValue>
        </register>
        <register>
          <name>TRIM_CAL_REVISION</name>
          <addressOffset>0x314</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FT1</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MP1</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ICEPICK_DEVICE_ID</name>
          <addressOffset>0x318</addressOffset>
          <size>32</size>
          <description>IcePick Device Identification
Reading this register and the USER_ID register is the only support way of identifying a device.</description>
          <fields>
            <field>
              <name>PG_REV</name>
              <description>[31:28] Field used to distinguish revisions of the device.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>WAFER_ID</name>
              <description>[27:12] Field used to identify silicon die.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>MANUFACTURER_ID</name>
              <description>[11:0] Manufacturer code.

0x02F: Texas Instruments</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x2B9BE02F</resetValue>
        </register>
        <register>
          <name>FCFG1_REVISION</name>
          <addressOffset>0x31c</addressOffset>
          <size>32</size>
          <description>Factory Configuration (FCFG1) Revision</description>
          <fields>
            <field>
              <name>REV</name>
              <description>[31:0] The revision number of the FCFG1 layout. This value will be read by application SW in order to determine which FCFG1 parameters that have valid values. This revision number must be incremented by 1 before any devices are to be produced if the FCFG1 layout has changed since the previous production of devices.
Value migth change without warning.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x26</resetValue>
        </register>
        <register>
          <name>MISC_OTP_DATA</name>
          <addressOffset>0x320</addressOffset>
          <size>32</size>
          <description>Misc OTP Data</description>
          <fields>
            <field>
              <name>RCOSC_HF_ITUNE</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>RCOSC_HF_CRIM</name>
              <description>[27:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>PER_M</name>
              <description>[19:15] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PER_E</name>
              <description>[14:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>MIN_ALLOWED_RTRIM_DIV5</name>
              <description>[11:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TEST_PROGRAM_REV</name>
              <description>[7:0] The revision of the test program used in the production process when FCFG1 was programmed.
Value migth change without warning.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xC000</resetValue>
        </register>
        <register>
          <name>IOCONF</name>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <description>IO Configuration</description>
          <fields>
            <field>
              <name>RESERVED7</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>GPIO_CNT</name>
              <description>[6:0] Number of available DIOs.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFF00</resetValue>
        </register>
        <register>
          <name>CONFIG_IF_ADC</name>
          <addressOffset>0x34c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FF2ADJ</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>FF3ADJ</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>INT3ADJ</name>
              <description>[23:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>FF1ADJ</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>AAFCAP</name>
              <description>[15:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>INT2ADJ</name>
              <description>[13:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>IFDIGLDO_TRIM_OUTPUT</name>
              <description>[9:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>IFANALDO_TRIM_OUTPUT</name>
              <description>[4:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3460F400</resetValue>
        </register>
        <register>
          <name>CONFIG_OSC_TOP</name>
          <addressOffset>0x350</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:30] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_ROW_Q12</name>
              <description>[29:26] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_COLUMN_Q12</name>
              <description>[25:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RCOSCLF_CTUNE_TRIM</name>
              <description>[9:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RCOSCLF_RTUNE_TRIM</name>
              <description>[1:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFC003C00</resetValue>
        </register>
        <register>
          <name>CONFIG_RF_FRONTEND</name>
          <addressOffset>0x354</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>IFAMP_IB</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>LNA_IB</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>IFAMP_TRIM</name>
              <description>[23:19] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>CTL_PA0_TRIM</name>
              <description>[18:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>PATRIMCOMPLETE_N</name>
              <description>[13:13] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED</name>
              <description>[12:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RFLDO_TRIM_OUTPUT</name>
              <description>[6:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x70001F80</resetValue>
        </register>
        <register>
          <name>CONFIG_SYNTH</name>
          <addressOffset>0x358</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DISABLE_CORNER_CAP</name>
              <description>[28:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>RFC_MDM_DEMIQMC0</name>
              <description>[27:12] Trim value for RF Core.
Value is read by RF Core ROM FW during RF Core initialization only on cc13x0.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>LDOVCO_TRIM_OUTPUT</name>
              <description>[11:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SLDO_TRIM_OUTPUT</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xE0000000</resetValue>
        </register>
        <register>
          <name>SOC_ADC_ABS_GAIN</name>
          <addressOffset>0x35c</addressOffset>
          <size>32</size>
          <description>AUX_ADC Gain in Absolute Reference Mode</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SOC_ADC_ABS_GAIN_TEMP1</name>
              <description>[15:0] SOC_ADC gain in absolute reference mode at temperature 1 (30C). Calculated in production test..</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF0000</resetValue>
        </register>
        <register>
          <name>SOC_ADC_REL_GAIN</name>
          <addressOffset>0x360</addressOffset>
          <size>32</size>
          <description>AUX_ADC Gain in Relative Reference Mode</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SOC_ADC_REL_GAIN_TEMP1</name>
              <description>[15:0] SOC_ADC gain in relative reference mode at temperature 1 (30C). Calculated in production test..</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF0000</resetValue>
        </register>
        <register>
          <name>SOC_ADC_OFFSET_INT</name>
          <addressOffset>0x368</addressOffset>
          <size>32</size>
          <description>AUX_ADC Temperature Offsets in Absolute Reference Mode</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>SOC_ADC_REL_OFFSET_TEMP1</name>
              <description>[23:16] SOC_ADC offset in relative reference mode at temperature 1 (30C). Signed 8-bit number. Calculated in production test..</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED8</name>
              <description>[15:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SOC_ADC_ABS_OFFSET_TEMP1</name>
              <description>[7:0] SOC_ADC offset in absolute reference mode at temperature 1 (30C). Signed 8-bit number. Calculated in production test..</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFF00FF00</resetValue>
        </register>
        <register>
          <name>SOC_ADC_REF_TRIM_AND_OFFSET_EXT</name>
          <addressOffset>0x36c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SOC_ADC_REF_VOLTAGE_TRIM_TEMP1</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFF80</resetValue>
        </register>
        <register>
          <name>AMPCOMP_TH1</name>
          <addressOffset>0x370</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>HPMRAMP3_LTH</name>
              <description>[23:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[17:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>HPMRAMP3_HTH</name>
              <description>[15:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>IBIASCAP_LPTOHP_OL_CNT</name>
              <description>[9:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>HPMRAMP1_TH</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFF7B828E</resetValue>
        </register>
        <register>
          <name>AMPCOMP_TH2</name>
          <addressOffset>0x374</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>LPMUPDATE_LTH</name>
              <description>[31:26] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[25:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>LPMUPDATE_HTM</name>
              <description>[23:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[17:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>ADC_COMP_AMPTH_LPM</name>
              <description>[15:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[9:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ADC_COMP_AMPTH_HPM</name>
              <description>[7:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[1:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x6B8B0303</resetValue>
        </register>
        <register>
          <name>AMPCOMP_CTRL1</name>
          <addressOffset>0x378</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:31] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>AMPCOMP_REQ_MODE</name>
              <description>[30:30] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[29:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>IBIAS_OFFSET</name>
              <description>[23:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>IBIAS_INIT</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>LPM_IBIAS_WAIT_CNT_FINAL</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CAP_STEP</name>
              <description>[7:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>IBIASCAP_HPTOLP_OL_CNT</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFF183F47</resetValue>
        </register>
        <register>
          <name>ANABYPASS_VALUE2</name>
          <addressOffset>0x37c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_IBIASTHERM</name>
              <description>[13:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>14</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFC3FF</resetValue>
        </register>
        <register>
          <name>CONFIG_MISC_ADC</name>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>MIN_ALLOWED_RTRIM</name>
              <description>[21:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RSSITRIMCOMPLETE_N</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RSSI_OFFSET</name>
              <description>[16:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>QUANTCTLTHRES</name>
              <description>[8:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DACTRIM</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFC0014D</resetValue>
        </register>
        <register>
          <name>VOLT_TRIM</name>
          <addressOffset>0x388</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>VDDR_TRIM_HH</name>
              <description>[28:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[23:21] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>VDDR_TRIM_H</name>
              <description>[20:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[15:13] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>VDDR_TRIM_SLEEP_H</name>
              <description>[12:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[7:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TRIMBOD_H</name>
              <description>[4:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xE0E0E0E0</resetValue>
        </register>
        <register>
          <name>OSC_CONF</name>
          <addressOffset>0x38c</addressOffset>
          <size>32</size>
          <description>OSC Configuration</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:30] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>ADC_SH_VBUF_EN</name>
              <description>[29:29] Trim value for DDI_0_OSC:ADCDOUBLERNANOAMPCTL.ADC_SH_VBUF_EN.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>ADC_SH_MODE_EN</name>
              <description>[28:28] Trim value for DDI_0_OSC:ADCDOUBLERNANOAMPCTL.ADC_SH_MODE_EN.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>ATESTLF_RCOSCLF_IBIAS_TRIM</name>
              <description>[27:27] Trim value for DDI_0_OSC:ATESTCTL.ATESTLF_RCOSCLF_IBIAS_TRIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>XOSCLF_REGULATOR_TRIM</name>
              <description>[26:25] Trim value for DDI_0_OSC:LFOSCCTL.XOSCLF_REGULATOR_TRIM.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>XOSCLF_CMIRRWR_RATIO</name>
              <description>[24:21] Trim value for DDI_0_OSC:LFOSCCTL.XOSCLF_CMIRRWR_RATIO.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>XOSC_HF_FAST_START</name>
              <description>[20:19] Trim value for DDI_0_OSC:CTL1.XOSC_HF_FAST_START.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>XOSC_OPTION</name>
              <description>[18:18] 0: XOSC_HF unavailable (may not be bonded out)
1: XOSC_HF available (default)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>HPOSC_OPTION</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>HPOSC_BIAS_HOLD_MODE_EN</name>
              <description>[16:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>HPOSC_CURRMIRR_RATIO</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>HPOSC_BIAS_RES_SET</name>
              <description>[11:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>HPOSC_FILTER_EN</name>
              <description>[7:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>HPOSC_BIAS_RECHARGE_DELAY</name>
              <description>[6:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[4:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>HPOSC_SERIES_CAP</name>
              <description>[2:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>HPOSC_DIV3_BYPASS</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xF0090000</resetValue>
        </register>
        <register>
          <name>FREQ_OFFSET</name>
          <addressOffset>0x390</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>HPOSC_COMP_P0</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>HPOSC_COMP_P1</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>HPOSC_COMP_P2</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CAP_TRIM</name>
          <addressOffset>0x394</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FLUX_CAP_0P28_TRIM</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>FLUX_CAP_0P4_TRIM</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>MISC_OTP_DATA_1</name>
          <addressOffset>0x398</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>PEAK_DET_ITRIM</name>
              <description>[28:27] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>HP_BUF_ITRIM</name>
              <description>[26:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>LP_BUF_ITRIM</name>
              <description>[23:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>DBLR_LOOP_FILTER_RESET_VOLTAGE</name>
              <description>[21:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>HPM_IBIAS_WAIT_CNT</name>
              <description>[19:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>LPM_IBIAS_WAIT_CNT</name>
              <description>[9:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>IDAC_STEP</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xE00403F8</resetValue>
        </register>
        <register>
          <name>PWD_CURR_20C</name>
          <addressOffset>0x39c</addressOffset>
          <size>32</size>
          <description>Power Down Current Control 20C</description>
          <fields>
            <field>
              <name>DELTA_CACHE_REF</name>
              <description>[31:24] Additional maximum current, in units of 1uA, with cache retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DELTA_RFMEM_RET</name>
              <description>[23:16] Additional maximum current, in 1uA units, with RF memory retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DELTA_XOSC_LPM</name>
              <description>[15:8] Additional maximum current, in units of 1uA, with XOSC_HF on in low-power mode</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BASELINE</name>
              <description>[7:0] Worst-case baseline maximum powerdown current, in units of 0.5uA</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x80BA608</resetValue>
        </register>
        <register>
          <name>PWD_CURR_35C</name>
          <addressOffset>0x3a0</addressOffset>
          <size>32</size>
          <description>Power Down Current Control 35C</description>
          <fields>
            <field>
              <name>DELTA_CACHE_REF</name>
              <description>[31:24] Additional maximum current, in units of 1uA, with cache retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DELTA_RFMEM_RET</name>
              <description>[23:16] Additional maximum current, in 1uA units, with RF memory retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DELTA_XOSC_LPM</name>
              <description>[15:8] Additional maximum current, in units of 1uA, with XOSC_HF on in low-power mode</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BASELINE</name>
              <description>[7:0] Worst-case baseline maximum powerdown current, in units of 0.5uA</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xC10A50A</resetValue>
        </register>
        <register>
          <name>PWD_CURR_50C</name>
          <addressOffset>0x3a4</addressOffset>
          <size>32</size>
          <description>Power Down Current Control 50C</description>
          <fields>
            <field>
              <name>DELTA_CACHE_REF</name>
              <description>[31:24] Additional maximum current, in units of 1uA, with cache retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DELTA_RFMEM_RET</name>
              <description>[23:16] Additional maximum current, in 1uA units, with RF memory retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DELTA_XOSC_LPM</name>
              <description>[15:8] Additional maximum current, in units of 1uA, with XOSC_HF on in low-power mode</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BASELINE</name>
              <description>[7:0] Worst-case baseline maximum powerdown current, in units of 0.5uA</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1218A20D</resetValue>
        </register>
        <register>
          <name>PWD_CURR_65C</name>
          <addressOffset>0x3a8</addressOffset>
          <size>32</size>
          <description>Power Down Current Control 65C</description>
          <fields>
            <field>
              <name>DELTA_CACHE_REF</name>
              <description>[31:24] Additional maximum current, in units of 1uA, with cache retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DELTA_RFMEM_RET</name>
              <description>[23:16] Additional maximum current, in 1uA units, with RF memory retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DELTA_XOSC_LPM</name>
              <description>[15:8] Additional maximum current, in units of 1uA, with XOSC_HF on in low-power mode</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BASELINE</name>
              <description>[7:0] Worst-case baseline maximum powerdown current, in units of 0.5uA</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1C259C14</resetValue>
        </register>
        <register>
          <name>PWD_CURR_80C</name>
          <addressOffset>0x3ac</addressOffset>
          <size>32</size>
          <description>Power Down Current Control 80C</description>
          <fields>
            <field>
              <name>DELTA_CACHE_REF</name>
              <description>[31:24] Additional maximum current, in units of 1uA, with cache retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DELTA_RFMEM_RET</name>
              <description>[23:16] Additional maximum current, in 1uA units, with RF memory retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DELTA_XOSC_LPM</name>
              <description>[15:8] Additional maximum current, in units of 1uA, with XOSC_HF on in low-power mode</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BASELINE</name>
              <description>[7:0] Worst-case baseline maximum powerdown current, in units of 0.5uA</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x2E3B9021</resetValue>
        </register>
        <register>
          <name>PWD_CURR_95C</name>
          <addressOffset>0x3b0</addressOffset>
          <size>32</size>
          <description>Power Down Current Control 95C</description>
          <fields>
            <field>
              <name>DELTA_CACHE_REF</name>
              <description>[31:24] Additional maximum current, in units of 1uA, with cache retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DELTA_RFMEM_RET</name>
              <description>[23:16] Additional maximum current, in 1uA units, with RF memory retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DELTA_XOSC_LPM</name>
              <description>[15:8] Additional maximum current, in units of 1uA, with XOSC_HF on in low-power mode</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BASELINE</name>
              <description>[7:0] Worst-case baseline maximum powerdown current, in units of 0.5uA</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x4C627A3B</resetValue>
        </register>
        <register>
          <name>PWD_CURR_110C</name>
          <addressOffset>0x3b4</addressOffset>
          <size>32</size>
          <description>Power Down Current Control 110C</description>
          <fields>
            <field>
              <name>DELTA_CACHE_REF</name>
              <description>[31:24] Additional maximum current, in units of 1uA, with cache retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DELTA_RFMEM_RET</name>
              <description>[23:16] Additional maximum current, in 1uA units, with RF memory retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DELTA_XOSC_LPM</name>
              <description>[15:8] Additional maximum current, in units of 1uA, with XOSC_HF on in low-power mode</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BASELINE</name>
              <description>[7:0] Worst-case baseline maximum powerdown current, in units of 0.5uA</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x789E706B</resetValue>
        </register>
        <register>
          <name>PWD_CURR_125C</name>
          <addressOffset>0x3b8</addressOffset>
          <size>32</size>
          <description>Power Down Current Control 125C</description>
          <fields>
            <field>
              <name>DELTA_CACHE_REF</name>
              <description>[31:24] Additional maximum current, in units of 1uA, with cache retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DELTA_RFMEM_RET</name>
              <description>[23:16] Additional maximum current, in 1uA units, with RF memory retention</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DELTA_XOSC_LPM</name>
              <description>[15:8] Additional maximum current, in units of 1uA, with XOSC_HF on in low-power mode</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BASELINE</name>
              <description>[7:0] Worst-case baseline maximum powerdown current, in units of 0.5uA</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xADE1809A</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLASH</name>
      <baseAddress>0x40030000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x4000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Flash sub-system registers, includes the Flash Memory Controller (FMC), flash read path, and an integrated Efuse controller and EFUSEROM.</description>
      <registers>
        <register>
          <name>STAT</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>FMC and Efuse Status</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>EFUSE_BLANK</name>
              <description>[15:15] Efuse scanning detected if fuse ROM is blank:
0 : Not blank
1 : Blank</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>EFUSE_TIMEOUT</name>
              <description>[14:14] Efuse scanning resulted in timeout error.
0 : No Timeout error
1 : Timeout Error</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>EFUSE_CRC_ERROR</name>
              <description>[13:13] Efuse scanning resulted in scan chain CRC error.
0 : No CRC error
1 : CRC Error</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>EFUSE_ERRCODE</name>
              <description>[12:8] Same as EFUSEERROR.CODE</description>
              <bitWidth>5</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[7:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SAMHOLD_DIS</name>
              <description>[2:2] Status indicator of flash sample and hold sequencing logic. This bit will go to 1 some delay after CFG.DIS_IDLE is set to 1.
0: Not disabled
1: Sample and hold disabled and stable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>BUSY</name>
              <description>[1:1] Fast version of the FMC FMSTAT.BUSY bit.
This flag is valid immediately after the operation setting it (FMSTAT.BUSY is delayed some cycles)
0 : Not busy
1 : Busy</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>POWER_MODE</name>
              <description>[0:0] Power state of the flash sub-system.
0 : Active
1 : Low power</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CFG</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>STANDBY_MODE_SEL</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>STANDBY_PW_SEL</name>
              <description>[7:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DIS_EFUSECLK</name>
              <description>[5:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>DIS_READACCESS</name>
              <description>[4:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>ENABLE_SWINTF</name>
              <description>[3:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[2:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DIS_STANDBY</name>
              <description>[1:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIS_IDLE</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SYSCODE_START</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED5</name>
              <description>[31:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>SYSCODE_START</name>
              <description>[4:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FLASH_SIZE</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SECTORS</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FWLOCK</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>FWLOCK</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FWFLAG</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>FWFLAG</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EFUSE</name>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED29</name>
              <description>[31:29] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>INSTRUCTION</name>
              <description>[28:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED16</name>
              <description>[23:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DUMPWORD</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EFUSEADDR</name>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>BLOCK</name>
              <description>[15:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>ROW</name>
              <description>[10:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>11</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DATAUPPER</name>
          <addressOffset>0x1008</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SPARE</name>
              <description>[7:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>P</name>
              <description>[2:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>R</name>
              <description>[1:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EEN</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DATALOWER</name>
          <addressOffset>0x100c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>DATA</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EFUSECFG</name>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>IDLEGATING</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[7:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>SLAVEPOWER</name>
              <description>[4:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[2:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>GATING</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>EFUSESTAT</name>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESETDONE</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>ACC</name>
          <addressOffset>0x1018</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>ACCUMULATOR</name>
              <description>[23:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>BOUNDARY</name>
          <addressOffset>0x101c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DISROW0</name>
              <description>[23:23] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>SPARE</name>
              <description>[22:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>EFC_SELF_TEST_ERROR</name>
              <description>[21:21] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>EFC_INSTRUCTION_INFO</name>
              <description>[20:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>EFC_INSTRUCTION_ERROR</name>
              <description>[19:19] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EFC_AUTOLOAD_ERROR</name>
              <description>[18:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>OUTPUTENABLE</name>
              <description>[17:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>SYS_ECC_SELF_TEST_EN</name>
              <description>[13:13] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>SYS_ECC_OVERRIDE_EN</name>
              <description>[12:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>EFC_FDI</name>
              <description>[11:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>SYS_DIEID_AUTOLOAD_EN</name>
              <description>[10:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>SYS_REPAIR_EN</name>
              <description>[9:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYS_WS_READ_STATES</name>
              <description>[7:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>INPUTENABLE</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EFUSEFLAG</name>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>KEY</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EFUSEKEY</name>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>CODE</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EFUSERELEASE</name>
          <addressOffset>0x1028</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>ODPYEAR</name>
              <description>[31:25] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>ODPMONTH</name>
              <description>[24:21] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>ODPDAY</name>
              <description>[20:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>EFUSEYEAR</name>
              <description>[15:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>EFUSEMONTH</name>
              <description>[8:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>EFUSEDAY</name>
              <description>[4:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EFUSEPINS</name>
          <addressOffset>0x102c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>EFC_SELF_TEST_DONE</name>
              <description>[15:15] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>EFC_SELF_TEST_ERROR</name>
              <description>[14:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>SYS_ECC_SELF_TEST_EN</name>
              <description>[13:13] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>EFC_INSTRUCTION_INFO</name>
              <description>[12:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>EFC_INSTRUCTION_ERROR</name>
              <description>[11:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>EFC_AUTOLOAD_ERROR</name>
              <description>[10:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>SYS_ECC_OVERRIDE_EN</name>
              <description>[9:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>EFC_READY</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EFC_FCLRZ</name>
              <description>[7:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>SYS_DIEID_AUTOLOAD_EN</name>
              <description>[6:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SYS_REPAIR_EN</name>
              <description>[5:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SYS_WS_READ_STATES</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EFUSECRA</name>
          <addressOffset>0x1030</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EFUSEREAD</name>
          <addressOffset>0x1034</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED10</name>
              <description>[31:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>22</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>DATABIT</name>
              <description>[9:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>READCLOCK</name>
              <description>[7:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DEBUG</name>
              <description>[3:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>SPARE</name>
              <description>[2:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MARGIN</name>
              <description>[1:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EFUSEPROGRAM</name>
          <addressOffset>0x1038</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>COMPAREDISABLE</name>
              <description>[30:30] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>CLOCKSTALL</name>
              <description>[29:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>VPPTOVDD</name>
              <description>[13:13] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>ITERATIONS</name>
              <description>[12:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>WRITECLOCK</name>
              <description>[8:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>9</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EFUSEERROR</name>
          <addressOffset>0x103c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DONE</name>
              <description>[5:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CODE</name>
              <description>[4:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SINGLEBIT</name>
          <addressOffset>0x1040</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FROMN</name>
              <description>[31:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>FROM0</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TWOBIT</name>
          <addressOffset>0x1044</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FROMN</name>
              <description>[31:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>FROM0</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SELFTESTCYC</name>
          <addressOffset>0x1048</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>CYCLES</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SELFTESTSIGN</name>
          <addressOffset>0x104c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>SIGNATURE</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FRDCTL</name>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RWAIT</name>
              <description>[11:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RM</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x200</resetValue>
        </register>
        <register>
          <name>FSPRD</name>
          <addressOffset>0x2004</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>DIS_PREEMPT</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RMBSEM</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[7:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RM1</name>
              <description>[1:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RM0</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FEDACCTL1</name>
          <addressOffset>0x2008</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>SUSP_IGNR</name>
              <description>[24:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>EDACEN</name>
              <description>[23:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FEDACCTL2</name>
          <addressOffset>0x200c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>SEC_THRESHOLD</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCOR_ERR_CNT</name>
          <addressOffset>0x2010</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>COR_ERR_CNT</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCOR_ERR_ADD</name>
          <addressOffset>0x2014</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FCOR_ERR_ADD</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCOR_ERR_POS</name>
          <addressOffset>0x2018</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>SERR_POS</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FEDACSTAT</name>
          <addressOffset>0x201c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED26</name>
              <description>[31:26] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>RVF_INT</name>
              <description>[25:25] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>FSM_DONE</name>
              <description>[24:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>ERR_PRF_FLG</name>
              <description>[23:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FUNC_ERR_ADD</name>
          <addressOffset>0x2020</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FUNC_ERR_ADD</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FEDACSDIS</name>
          <addressOffset>0x2024</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>SECTORID0</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FPRIM_ADD_TAG</name>
          <addressOffset>0x2028</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>PRIM_ADD_TAG</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FREDU_ADD_TAG</name>
          <addressOffset>0x202c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>REDU_ADD_TAG</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FBPROT</name>
          <addressOffset>0x2030</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PROTL1DIS</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FBSE</name>
          <addressOffset>0x2034</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>BSE</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FBBUSY</name>
          <addressOffset>0x2038</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BUSY</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFE</resetValue>
        </register>
        <register>
          <name>FBAC</name>
          <addressOffset>0x203c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED17</name>
              <description>[31:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>OTPPROTDIS</name>
              <description>[16:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>BAGP</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VREADS</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xF</resetValue>
        </register>
        <register>
          <name>FBFALLBACK</name>
          <addressOffset>0x2040</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED28</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>FSM_PWRSAV</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED20</name>
              <description>[23:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>REG_PWRSAV</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>BANKPWR7</name>
              <description>[15:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>BANKPWR6</name>
              <description>[13:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>BANKPWR5</name>
              <description>[11:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BANKPWR4</name>
              <description>[9:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BANKPWR3</name>
              <description>[7:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>BANKPWR2</name>
              <description>[5:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>BANKPWR1</name>
              <description>[3:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>BANKPWR0</name>
              <description>[1:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x505FFFF</resetValue>
        </register>
        <register>
          <name>FBPRDY</name>
          <addressOffset>0x2044</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED17</name>
              <description>[31:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>BANKBUSY</name>
              <description>[16:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PUMPRDY</name>
              <description>[15:15] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[14:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>14</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>BANKRDY</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFF00FE</resetValue>
        </register>
        <register>
          <name>FPAC1</name>
          <addressOffset>0x2048</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED28</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>PSLEEPTDIS</name>
              <description>[27:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PUMPRESET_PW</name>
              <description>[15:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[3:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PUMPPWR</name>
              <description>[1:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x2082081</resetValue>
        </register>
        <register>
          <name>FPAC2</name>
          <addressOffset>0x204c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PAGP</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FMAC</name>
          <addressOffset>0x2050</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>BANK</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FMSTAT</name>
          <addressOffset>0x2054</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED18</name>
              <description>[31:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>14</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RVSUSP</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RDVER</name>
              <description>[16:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RVF</name>
              <description>[15:15] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>ILA</name>
              <description>[14:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DBF</name>
              <description>[13:13] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>PGV</name>
              <description>[12:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PCV</name>
              <description>[11:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>EV</name>
              <description>[10:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CV</name>
              <description>[9:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>BUSY</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ERS</name>
              <description>[7:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>PGM</name>
              <description>[6:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>INVDAT</name>
              <description>[5:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>CSTAT</name>
              <description>[4:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>VOLSTAT</name>
              <description>[3:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>ESUSP</name>
              <description>[2:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PSUSP</name>
              <description>[1:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SLOCK</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FEMU_DMSW</name>
          <addressOffset>0x2058</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FEMU_DMSW</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FEMU_DLSW</name>
          <addressOffset>0x205c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FEMU_DLSW</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FEMU_ECC</name>
          <addressOffset>0x2060</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>EMU_ECC</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FLOCK</name>
          <addressOffset>0x2064</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>ENCOM</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x55AA</resetValue>
        </register>
        <register>
          <name>FEMU_ADDR</name>
          <addressOffset>0x2068</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>EMU_ADDR</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FDIAGCTL</name>
          <addressOffset>0x206c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>DIAGMODE</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FRAW_DATAH</name>
          <addressOffset>0x2070</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FRAW_DATAH</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FRAW_DATAL</name>
          <addressOffset>0x2074</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FRAW_DATAL</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FRAW_ECC</name>
          <addressOffset>0x2078</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RAW_ECC</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FPAR_OVR</name>
          <addressOffset>0x207c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>DAT_INV_PAR</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FVREADCT</name>
          <addressOffset>0x2080</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>VREADCT</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x8</resetValue>
        </register>
        <register>
          <name>FVHVCT1</name>
          <addressOffset>0x2084</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>TRIM13_E</name>
              <description>[23:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>VHVCT_E</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED8</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TRIM13_PV</name>
              <description>[7:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>VHVCT_PV</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x840088</resetValue>
        </register>
        <register>
          <name>FVHVCT2</name>
          <addressOffset>0x2088</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>TRIM13_P</name>
              <description>[23:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>VHVCT_P</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xA20000</resetValue>
        </register>
        <register>
          <name>FVHVCT3</name>
          <addressOffset>0x208c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED20</name>
              <description>[31:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>WCT</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[15:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>VHVCT_READ</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xF0000</resetValue>
        </register>
        <register>
          <name>FVNVCT</name>
          <addressOffset>0x2090</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED13</name>
              <description>[31:13] Internal. Only to be used through TI provided API.</description>
              <bitWidth>19</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>VCG2P5CT</name>
              <description>[12:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[7:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>VIN_CT</name>
              <description>[4:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x800</resetValue>
        </register>
        <register>
          <name>FVSLP</name>
          <addressOffset>0x2094</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VSL_P</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[11:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x8000</resetValue>
        </register>
        <register>
          <name>FVWLCT</name>
          <addressOffset>0x2098</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED5</name>
              <description>[31:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>VWLCT_P</name>
              <description>[4:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x8</resetValue>
        </register>
        <register>
          <name>FEFUSECTL</name>
          <addressOffset>0x209c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED27</name>
              <description>[31:27] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>CHAIN_SEL</name>
              <description>[26:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED18</name>
              <description>[23:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>WRITE_EN</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>BP_SEL</name>
              <description>[16:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[15:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>EF_CLRZ</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[7:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>EF_TEST</name>
              <description>[4:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>EFUSE_EN</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x701010A</resetValue>
        </register>
        <register>
          <name>FEFUSESTAT</name>
          <addressOffset>0x20a0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SHIFT_DONE</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FEFUSEDATA</name>
          <addressOffset>0x20a4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FEFUSEDATA</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSEQPMP</name>
          <addressOffset>0x20a8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED28</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>TRIM_3P4</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED22</name>
              <description>[23:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>TRIM_1P7</name>
              <description>[21:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>TRIM_0P8</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>VIN_AT_X</name>
              <description>[14:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[11:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>VIN_BY_PASS</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SEQ_PUMP</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x85080000</resetValue>
        </register>
        <register>
          <name>FCLKTRIM</name>
          <addressOffset>0x20ac</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>TRIM_EN</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ROM_TEST</name>
          <addressOffset>0x20b0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>ROM_KEY</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FEDACSDIS2</name>
          <addressOffset>0x20c0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>SECTORID2</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FBSTROBES</name>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>ECBIT</name>
              <description>[24:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>RWAIT2_FLCLK</name>
              <description>[18:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RWAIT_FLCLK</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>FLCLKEN</name>
              <description>[16:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[15:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>CTRLENZ</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>[7:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>NOCOLRED</name>
              <description>[6:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PRECOL</name>
              <description>[5:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TI_OTP</name>
              <description>[4:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>OTP</name>
              <description>[3:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>TEZ</name>
              <description>[2:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[1:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x104</resetValue>
        </register>
        <register>
          <name>FPSTROBES</name>
          <addressOffset>0x2104</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>EXECUTEZ</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[7:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>V3PWRDNZ</name>
              <description>[1:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>V5PWRDNZ</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x103</resetValue>
        </register>
        <register>
          <name>FBMODE</name>
          <addressOffset>0x2108</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MODE</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FTCR</name>
          <addressOffset>0x210c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED7</name>
              <description>[31:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TCR</name>
              <description>[6:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FADDR</name>
          <addressOffset>0x2110</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FADDR</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FPMTCTL</name>
          <addressOffset>0x2114</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>ADDR_INCR</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PBISTCTL</name>
          <addressOffset>0x2118</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>PBIST_KEY</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FTCTL</name>
          <addressOffset>0x211c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED17</name>
              <description>[31:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>WDATA_BLK_CLR</name>
              <description>[16:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[15:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>14</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TEST_EN</name>
              <description>[1:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FWPWRITE0</name>
          <addressOffset>0x2120</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FWPWRITE0</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>FWPWRITE1</name>
          <addressOffset>0x2124</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FWPWRITE1</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>FWPWRITE2</name>
          <addressOffset>0x2128</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FWPWRITE2</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>FWPWRITE3</name>
          <addressOffset>0x212c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FWPWRITE3</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>FWPWRITE4</name>
          <addressOffset>0x2130</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FWPWRITE4</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>FWPWRITE5</name>
          <addressOffset>0x2134</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FWPWRITE5</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>FWPWRITE6</name>
          <addressOffset>0x2138</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FWPWRITE6</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>FWPWRITE7</name>
          <addressOffset>0x213c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FWPWRITE7</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>FWPWRITE_ECC</name>
          <addressOffset>0x2140</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>ECCBYTES07_00</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>ECCBYTES15_08</name>
              <description>[23:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>ECCBYTES23_16</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ECCBYTES31_24</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>FSWSTAT</name>
          <addressOffset>0x2144</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SAFELV</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>FSM_GLBCTL</name>
          <addressOffset>0x2200</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLKSEL</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>FSM_STATE</name>
          <addressOffset>0x2204</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CTRLENZ</name>
              <description>[11:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>EXECUTEZ</name>
              <description>[10:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[9:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>FSM_ACT</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TIOTP_ACT</name>
              <description>[7:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>OTP_ACT</name>
              <description>[6:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xC00</resetValue>
        </register>
        <register>
          <name>FSM_STAT</name>
          <addressOffset>0x2208</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>NON_OP</name>
              <description>[2:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>OVR_PUL_CNT</name>
              <description>[1:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>INV_DAT</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x4</resetValue>
        </register>
        <register>
          <name>FSM_CMD</name>
          <addressOffset>0x220c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>FSMCMD</name>
              <description>[5:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_PE_OSU</name>
          <addressOffset>0x2210</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PGM_OSU</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ERA_OSU</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_VSTAT</name>
          <addressOffset>0x2214</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VSTAT_CNT</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[11:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3000</resetValue>
        </register>
        <register>
          <name>FSM_PE_VSU</name>
          <addressOffset>0x2218</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PGM_VSU</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ERA_VSU</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_CMP_VSU</name>
          <addressOffset>0x221c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>ADD_EXZ</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[11:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_EX_VAL</name>
          <addressOffset>0x2220</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>REP_VSU</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EXE_VALD</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x301</resetValue>
        </register>
        <register>
          <name>FSM_RD_H</name>
          <addressOffset>0x2224</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RD_H</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x5A</resetValue>
        </register>
        <register>
          <name>FSM_P_OH</name>
          <addressOffset>0x2228</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PGM_OH</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x100</resetValue>
        </register>
        <register>
          <name>FSM_ERA_OH</name>
          <addressOffset>0x222c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>ERA_OH</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>FSM_SAV_PPUL</name>
          <addressOffset>0x2230</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>SAV_P_PUL</name>
              <description>[11:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_PE_VH</name>
          <addressOffset>0x2234</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PGM_VH</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ERA_VH</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x100</resetValue>
        </register>
        <register>
          <name>FSM_PRG_PW</name>
          <addressOffset>0x2240</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PROG_PUL_WIDTH</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_ERA_PW</name>
          <addressOffset>0x2244</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FSM_ERA_PW</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_SAV_ERA_PUL</name>
          <addressOffset>0x2254</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>SAV_ERA_PUL</name>
              <description>[11:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_TIMER</name>
          <addressOffset>0x2258</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FSM_TIMER</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_MODE</name>
          <addressOffset>0x225c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED20</name>
              <description>[31:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>RDV_SUBMODE</name>
              <description>[19:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>PGM_SUBMODE</name>
              <description>[17:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>ERA_SUBMODE</name>
              <description>[15:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>SUBMODE</name>
              <description>[13:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>SAV_PGM_CMD</name>
              <description>[11:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>SAV_ERA_MODE</name>
              <description>[8:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>MODE</name>
              <description>[5:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CMD</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_PGM</name>
          <addressOffset>0x2260</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED26</name>
              <description>[31:26] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>PGM_BANK</name>
              <description>[25:23] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>PGM_ADDR</name>
              <description>[22:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_ERA</name>
          <addressOffset>0x2264</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED26</name>
              <description>[31:26] Internal. Only to be used through TI provided API.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>ERA_BANK</name>
              <description>[25:23] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>ERA_ADDR</name>
              <description>[22:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_PRG_PUL</name>
          <addressOffset>0x2268</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED20</name>
              <description>[31:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>BEG_EC_LEVEL</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>MAX_PRG_PUL</name>
              <description>[11:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x40032</resetValue>
        </register>
        <register>
          <name>FSM_ERA_PUL</name>
          <addressOffset>0x226c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED20</name>
              <description>[31:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>MAX_EC_LEVEL</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>MAX_ERA_PUL</name>
              <description>[11:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x40BB8</resetValue>
        </register>
        <register>
          <name>FSM_STEP_SIZE</name>
          <addressOffset>0x2270</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>EC_STEP_SIZE</name>
              <description>[24:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>9</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_PUL_CNTR</name>
          <addressOffset>0x2274</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Internal. Only to be used through TI provided API.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>CUR_EC_LEVEL</name>
              <description>[24:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>9</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>PUL_CNTR</name>
              <description>[11:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_EC_STEP_HEIGHT</name>
          <addressOffset>0x2278</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>EC_STEP_HEIGHT</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_ST_MACHINE</name>
          <addressOffset>0x227c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DO_PRECOND</name>
              <description>[23:23] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>FSM_INT_EN</name>
              <description>[22:22] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>ALL_BANKS</name>
              <description>[21:21] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>CMPV_ALLOWED</name>
              <description>[20:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>RANDOM</name>
              <description>[19:19] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>RV_SEC_EN</name>
              <description>[18:18] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RV_RES</name>
              <description>[17:17] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RV_INT_EN</name>
              <description>[16:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>ONE_TIME_GOOD</name>
              <description>[14:14] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[13:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DO_REDU_COL</name>
              <description>[11:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>DBG_SHORT_ROW</name>
              <description>[10:7] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[6:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PGM_SEC_COF_EN</name>
              <description>[5:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>PREC_STOP_EN</name>
              <description>[4:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DIS_TST_EN</name>
              <description>[3:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CMD_EN</name>
              <description>[2:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>INV_DATA</name>
              <description>[1:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>OVERRIDE</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x800500</resetValue>
        </register>
        <register>
          <name>FSM_FLES</name>
          <addressOffset>0x2280</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>BLK_TIOTP</name>
              <description>[11:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>BLK_OTP</name>
              <description>[7:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_WR_ENA</name>
          <addressOffset>0x2288</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Internal. Only to be used through TI provided API.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>WR_ENA</name>
              <description>[2:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x2</resetValue>
        </register>
        <register>
          <name>FSM_ACC_PP</name>
          <addressOffset>0x228c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FSM_ACC_PP</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_ACC_EP</name>
          <addressOffset>0x2290</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>ACC_EP</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_ADDR</name>
          <addressOffset>0x22a0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>BANK</name>
              <description>[30:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>CUR_ADDR</name>
              <description>[27:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_SECTOR</name>
          <addressOffset>0x22a4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>SECT_ERASED</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>FSM_SECTOR_EXTENSION</name>
              <description>[15:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SECTOR</name>
              <description>[7:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SEC_OUT</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF0000</resetValue>
        </register>
        <register>
          <name>FMC_REV_ID</name>
          <addressOffset>0x22a8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>MOD_VERSION</name>
              <description>[31:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>CONFIG_CRC</name>
              <description>[11:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_ERR_ADDR</name>
          <addressOffset>0x22ac</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FSM_ERR_ADDR</name>
              <description>[31:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[7:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>FSM_ERR_BANK</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_PGM_MAXPUL</name>
          <addressOffset>0x22b0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>FSM_PGM_MAXPUL</name>
              <description>[11:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_EXECUTE</name>
          <addressOffset>0x22b4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED20</name>
              <description>[31:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>SUSPEND_NOW</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[15:5] Internal. Only to be used through TI provided API.</description>
              <bitWidth>11</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>FSMEXECUTE</name>
              <description>[4:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xA000A</resetValue>
        </register>
        <register>
          <name>EEPROM_CFG</name>
          <addressOffset>0x22b8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>AUTOSTART_GRACE</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x10000</resetValue>
        </register>
        <register>
          <name>FSM_SECTOR1</name>
          <addressOffset>0x22c0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FSM_SECTOR1</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>FSM_SECTOR2</name>
          <addressOffset>0x22c4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FSM_SECTOR2</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_BSLE0</name>
          <addressOffset>0x22e0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FSM_BSLE0</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_BSLE1</name>
          <addressOffset>0x22e4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FSM_BSL1</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_BSLP0</name>
          <addressOffset>0x22f0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FSM_BSLP0</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FSM_BSLP1</name>
          <addressOffset>0x22f4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FSM_BSL1</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_BANK</name>
          <addressOffset>0x2400</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>EE_BANK_WIDTH</name>
              <description>[31:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>EE_NUM_BANK</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>MAIN_BANK_WIDTH</name>
              <description>[15:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MAIN_NUM_BANK</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x401</resetValue>
        </register>
        <register>
          <name>FCFG_WRAPPER</name>
          <addressOffset>0x2404</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>FAMILY_TYPE</name>
              <description>[31:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED21</name>
              <description>[23:21] Internal. Only to be used through TI provided API.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>MEM_MAP</name>
              <description>[20:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>CPU2</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>EE_IN_MAIN</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>ROM</name>
              <description>[11:11] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>IFLUSH</name>
              <description>[10:10] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>SIL3</name>
              <description>[9:9] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>ECCA</name>
              <description>[8:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AUTO_SUSP</name>
              <description>[7:6] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>UERR</name>
              <description>[5:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CPU_TYPE1</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x50009007</resetValue>
        </register>
        <register>
          <name>FCFG_BNK_TYPE</name>
          <addressOffset>0x2408</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B7_TYPE</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>B6_TYPE</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>B5_TYPE</name>
              <description>[23:20] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>B4_TYPE</name>
              <description>[19:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>B3_TYPE</name>
              <description>[15:12] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>B2_TYPE</name>
              <description>[11:8] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>B1_TYPE</name>
              <description>[7:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>B0_TYPE</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3</resetValue>
        </register>
        <register>
          <name>FCFG_B0_START</name>
          <addressOffset>0x2410</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B0_MAX_SECTOR</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>B0_MUX_FACTOR</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>B0_START_ADDR</name>
              <description>[23:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x2000000</resetValue>
        </register>
        <register>
          <name>FCFG_B1_START</name>
          <addressOffset>0x2414</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B1_MAX_SECTOR</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>B1_MUX_FACTOR</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>B1_START_ADDR</name>
              <description>[23:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B2_START</name>
          <addressOffset>0x2418</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B2_MAX_SECTOR</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>B2_MUX_FACTOR</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>B2_START_ADDR</name>
              <description>[23:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B3_START</name>
          <addressOffset>0x241c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B3_MAX_SECTOR</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>B3_MUX_FACTOR</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>B3_START_ADDR</name>
              <description>[23:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B4_START</name>
          <addressOffset>0x2420</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B4_MAX_SECTOR</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>B4_MUX_FACTOR</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>B4_START_ADDR</name>
              <description>[23:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B5_START</name>
          <addressOffset>0x2424</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B5_MAX_SECTOR</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>B5_MUX_FACTOR</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>B5_START_ADDR</name>
              <description>[23:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B6_START</name>
          <addressOffset>0x2428</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B6_MAX_SECTOR</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>B6_MUX_FACTOR</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>B6_START_ADDR</name>
              <description>[23:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B7_START</name>
          <addressOffset>0x242c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B7_MAX_SECTOR</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>B7_MUX_FACTOR</name>
              <description>[27:24] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>B7_START_ADDR</name>
              <description>[23:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B0_SSIZE0</name>
          <addressOffset>0x2430</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED28</name>
              <description>[31:28] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>B0_NUM_SECTORS</name>
              <description>[27:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[15:4] Internal. Only to be used through TI provided API.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>B0_SECT_SIZE</name>
              <description>[3:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x200004</resetValue>
        </register>
        <register>
          <name>FCFG_B0_SSIZE1</name>
          <addressOffset>0x2434</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B0_SSIZE2</name>
          <addressOffset>0x2438</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B0_SSIZE3</name>
          <addressOffset>0x243c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B1_SSIZE0</name>
          <addressOffset>0x2440</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B1_SECT_SIZE</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B1_SSIZE1</name>
          <addressOffset>0x2444</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B1_SSIZE2</name>
          <addressOffset>0x2448</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B1_SSIZE3</name>
          <addressOffset>0x244c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B2_SSIZE0</name>
          <addressOffset>0x2450</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B2_SECT_SIZE</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B2_SSIZE1</name>
          <addressOffset>0x2454</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B2_SSIZE2</name>
          <addressOffset>0x2458</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B2_SSIZE3</name>
          <addressOffset>0x245c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B3_SSIZE0</name>
          <addressOffset>0x2460</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B3_SECT_SIZE</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B3_SSIZE1</name>
          <addressOffset>0x2464</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B3_SSIZE2</name>
          <addressOffset>0x2468</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B3_SSIZE3</name>
          <addressOffset>0x246c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B4_SSIZE0</name>
          <addressOffset>0x2470</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B4_SECT_SIZE</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B4_SSIZE1</name>
          <addressOffset>0x2474</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B4_SSIZE2</name>
          <addressOffset>0x2478</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B4_SSIZE3</name>
          <addressOffset>0x247c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B5_SSIZE0</name>
          <addressOffset>0x2480</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B5_SECT_SIZE</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B5_SSIZE1</name>
          <addressOffset>0x2484</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B5_SSIZE2</name>
          <addressOffset>0x2488</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B5_SSIZE3</name>
          <addressOffset>0x248c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B6_SSIZE0</name>
          <addressOffset>0x2490</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B6_SECT_SIZE</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B6_SSIZE1</name>
          <addressOffset>0x2494</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B6_SSIZE2</name>
          <addressOffset>0x2498</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B6_SSIZE3</name>
          <addressOffset>0x249c</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B7_SSIZE0</name>
          <addressOffset>0x24a0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>B7_SECT_SIZE</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B7_SSIZE1</name>
          <addressOffset>0x24a4</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B7_SSIZE2</name>
          <addressOffset>0x24a8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FCFG_B7_SSIZE3</name>
          <addressOffset>0x24ac</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <baseAddress>0x40022000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <description>MCU GPIO - I/F for controlling and reading IO status and IO event status</description>
      <registers>
        <register>
          <name>DOUT3_0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Data Out 0 to 3

Alias register for byte access to each bit in DOUT31_0</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO3</name>
              <description>[24:24] Sets the state of the pin that is configured as DIO#3, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED17</name>
              <description>[23:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO2</name>
              <description>[16:16] Sets the state of the pin that is configured as DIO#2, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[15:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO1</name>
              <description>[8:8] Sets the state of the pin that is configured as DIO#1, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO0</name>
              <description>[0:0] Sets the state of the pin that is configured as DIO#0, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DOUT7_4</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Data Out 4 to 7

Alias register for byte access to each bit in DOUT31_0</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO7</name>
              <description>[24:24] Sets the state of the pin that is configured as DIO#7, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED17</name>
              <description>[23:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO6</name>
              <description>[16:16] Sets the state of the pin that is configured as DIO#6, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[15:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO5</name>
              <description>[8:8] Sets the state of the pin that is configured as DIO#5, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO4</name>
              <description>[0:0] Sets the state of the pin that is configured as DIO#4, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DOUT11_8</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Data Out 8 to 11

Alias register for byte access to each bit in DOUT31_0</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO11</name>
              <description>[24:24] Sets the state of the pin that is configured as DIO#11, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED17</name>
              <description>[23:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO10</name>
              <description>[16:16] Sets the state of the pin that is configured as DIO#10, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[15:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO9</name>
              <description>[8:8] Sets the state of the pin that is configured as DIO#9, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO8</name>
              <description>[0:0] Sets the state of the pin that is configured as DIO#8, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DOUT15_12</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Data Out 12 to 15

Alias register for byte access to each bit in DOUT31_0</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO15</name>
              <description>[24:24] Sets the state of the pin that is configured as DIO#15, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED17</name>
              <description>[23:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO14</name>
              <description>[16:16] Sets the state of the pin that is configured as DIO#14, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[15:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO13</name>
              <description>[8:8] Sets the state of the pin that is configured as DIO#13, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO12</name>
              <description>[0:0] Sets the state of the pin that is configured as DIO#12, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DOUT19_16</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Data Out 16 to 19

Alias register for byte access to each bit in DOUT31_0</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO19</name>
              <description>[24:24] Sets the state of the pin that is configured as DIO#19, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED17</name>
              <description>[23:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO18</name>
              <description>[16:16] Sets the state of the pin that is configured as DIO#18, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[15:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO17</name>
              <description>[8:8] Sets the state of the pin that is configured as DIO#17, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO16</name>
              <description>[0:0] Sets the state of the pin that is configured as DIO#16, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DOUT23_20</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Data Out 20 to 23

Alias register for byte access to each bit in DOUT31_0</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO23</name>
              <description>[24:24] Sets the state of the pin that is configured as DIO#23, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED17</name>
              <description>[23:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO22</name>
              <description>[16:16] Sets the state of the pin that is configured as DIO#22, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[15:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO21</name>
              <description>[8:8] Sets the state of the pin that is configured as DIO#21, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO20</name>
              <description>[0:0] Sets the state of the pin that is configured as DIO#20, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DOUT27_24</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Data Out 24 to 27

Alias register for byte access to each bit in DOUT31_0</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO27</name>
              <description>[24:24] Sets the state of the pin that is configured as DIO#27, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED17</name>
              <description>[23:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO26</name>
              <description>[16:16] Sets the state of the pin that is configured as DIO#26, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[15:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO25</name>
              <description>[8:8] Sets the state of the pin that is configured as DIO#25, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO24</name>
              <description>[0:0] Sets the state of the pin that is configured as DIO#24, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DOUT31_28</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Data Out 28 to 31

Alias register for byte access to each bit in DOUT31_0</description>
          <fields>
            <field>
              <name>RESERVED25</name>
              <description>[31:25] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO31</name>
              <description>[24:24] Sets the state of the pin that is configured as DIO#31, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED17</name>
              <description>[23:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO30</name>
              <description>[16:16] Sets the state of the pin that is configured as DIO#30, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED9</name>
              <description>[15:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO29</name>
              <description>[8:8] Sets the state of the pin that is configured as DIO#29, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO28</name>
              <description>[0:0] Sets the state of the pin that is configured as DIO#28, if the corresponding DOE31_0 bitfield is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DOUT31_0</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>Data Output for DIO 0 to 31</description>
          <fields>
            <field>
              <name>DIO31</name>
              <description>[31:31] Data output for DIO 31</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>DIO30</name>
              <description>[30:30] Data output for DIO 30</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>DIO29</name>
              <description>[29:29] Data output for DIO 29</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DIO28</name>
              <description>[28:28] Data output for DIO 28</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>DIO27</name>
              <description>[27:27] Data output for DIO 27</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>DIO26</name>
              <description>[26:26] Data output for DIO 26</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>DIO25</name>
              <description>[25:25] Data output for DIO 25</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO24</name>
              <description>[24:24] Data output for DIO 24</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DIO23</name>
              <description>[23:23] Data output for DIO 23</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>DIO22</name>
              <description>[22:22] Data output for DIO 22</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>DIO21</name>
              <description>[21:21] Data output for DIO 21</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>DIO20</name>
              <description>[20:20] Data output for DIO 20</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>DIO19</name>
              <description>[19:19] Data output for DIO 19</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>DIO18</name>
              <description>[18:18] Data output for DIO 18</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>DIO17</name>
              <description>[17:17] Data output for DIO 17</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO16</name>
              <description>[16:16] Data output for DIO 16</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DIO15</name>
              <description>[15:15] Data output for DIO 15</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>DIO14</name>
              <description>[14:14] Data output for DIO 14</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DIO13</name>
              <description>[13:13] Data output for DIO 13</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>DIO12</name>
              <description>[12:12] Data output for DIO 12</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DIO11</name>
              <description>[11:11] Data output for DIO 11</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>DIO10</name>
              <description>[10:10] Data output for DIO 10</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>DIO9</name>
              <description>[9:9] Data output for DIO 9</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO8</name>
              <description>[8:8] Data output for DIO 8</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DIO7</name>
              <description>[7:7] Data output for DIO 7</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>DIO6</name>
              <description>[6:6] Data output for DIO 6</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DIO5</name>
              <description>[5:5] Data output for DIO 5</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>DIO4</name>
              <description>[4:4] Data output for DIO 4</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DIO3</name>
              <description>[3:3] Data output for DIO 3</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DIO2</name>
              <description>[2:2] Data output for DIO 2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DIO1</name>
              <description>[1:1] Data output for DIO 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO0</name>
              <description>[0:0] Data output for DIO 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DOUTSET31_0</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>Data Out Set

Writing 1 to a bit position sets the corresponding bit in the DOUT31_0 register</description>
          <fields>
            <field>
              <name>DIO31</name>
              <description>[31:31] Set bit 31</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>DIO30</name>
              <description>[30:30] Set bit 30</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>DIO29</name>
              <description>[29:29] Set bit 29</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DIO28</name>
              <description>[28:28] Set bit 28</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>DIO27</name>
              <description>[27:27] Set bit 27</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>DIO26</name>
              <description>[26:26] Set bit 26</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>DIO25</name>
              <description>[25:25] Set bit 25</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO24</name>
              <description>[24:24] Set bit 24</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DIO23</name>
              <description>[23:23] Set bit 23</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>DIO22</name>
              <description>[22:22] Set bit 22</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>DIO21</name>
              <description>[21:21] Set bit 21</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>DIO20</name>
              <description>[20:20] Set bit 20</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>DIO19</name>
              <description>[19:19] Set bit 19</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>DIO18</name>
              <description>[18:18] Set bit 18</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>DIO17</name>
              <description>[17:17] Set bit 17</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO16</name>
              <description>[16:16] Set bit 16</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DIO15</name>
              <description>[15:15] Set bit 15</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>DIO14</name>
              <description>[14:14] Set bit 14</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DIO13</name>
              <description>[13:13] Set bit 13</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>DIO12</name>
              <description>[12:12] Set bit 12</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DIO11</name>
              <description>[11:11] Set bit 11</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>DIO10</name>
              <description>[10:10] Set bit 10</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>DIO9</name>
              <description>[9:9] Set bit 9</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO8</name>
              <description>[8:8] Set bit 8</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DIO7</name>
              <description>[7:7] Set bit 7</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>DIO6</name>
              <description>[6:6] Set bit 6</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DIO5</name>
              <description>[5:5] Set bit 5</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>DIO4</name>
              <description>[4:4] Set bit 4</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DIO3</name>
              <description>[3:3] Set bit 3</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DIO2</name>
              <description>[2:2] Set bit 2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DIO1</name>
              <description>[1:1] Set bit 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO0</name>
              <description>[0:0] Set bit 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DOUTCLR31_0</name>
          <addressOffset>0xa0</addressOffset>
          <size>32</size>
          <description>Data Out Clear

Writing 1 to a bit position clears the corresponding bit in the DOUT31_0 register</description>
          <fields>
            <field>
              <name>DIO31</name>
              <description>[31:31] Clears bit 31</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>DIO30</name>
              <description>[30:30] Clears bit 30</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>DIO29</name>
              <description>[29:29] Clears bit 29</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DIO28</name>
              <description>[28:28] Clears bit 28</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>DIO27</name>
              <description>[27:27] Clears bit 27</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>DIO26</name>
              <description>[26:26] Clears bit 26</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>DIO25</name>
              <description>[25:25] Clears bit 25</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO24</name>
              <description>[24:24] Clears bit 24</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DIO23</name>
              <description>[23:23] Clears bit 23</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>DIO22</name>
              <description>[22:22] Clears bit 22</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>DIO21</name>
              <description>[21:21] Clears bit 21</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>DIO20</name>
              <description>[20:20] Clears bit 20</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>DIO19</name>
              <description>[19:19] Clears bit 19</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>DIO18</name>
              <description>[18:18] Clears bit 18</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>DIO17</name>
              <description>[17:17] Clears bit 17</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO16</name>
              <description>[16:16] Clears bit 16</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DIO15</name>
              <description>[15:15] Clears bit 15</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>DIO14</name>
              <description>[14:14] Clears bit 14</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DIO13</name>
              <description>[13:13] Clears bit 13</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>DIO12</name>
              <description>[12:12] Clears bit 12</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DIO11</name>
              <description>[11:11] Clears bit 11</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>DIO10</name>
              <description>[10:10] Clears bit 10</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>DIO9</name>
              <description>[9:9] Clears bit 9</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO8</name>
              <description>[8:8] Clears bit 8</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DIO7</name>
              <description>[7:7] Clears bit 7</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>DIO6</name>
              <description>[6:6] Clears bit 6</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DIO5</name>
              <description>[5:5] Clears bit 5</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>DIO4</name>
              <description>[4:4] Clears bit 4</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DIO3</name>
              <description>[3:3] Clears bit 3</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DIO2</name>
              <description>[2:2] Clears bit 2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DIO1</name>
              <description>[1:1] Clears bit 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO0</name>
              <description>[0:0] Clears bit 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DOUTTGL31_0</name>
          <addressOffset>0xb0</addressOffset>
          <size>32</size>
          <description>Data Out Toggle

Writing 1 to a bit position will invert the corresponding DIO output.</description>
          <fields>
            <field>
              <name>DIO31</name>
              <description>[31:31] Toggles bit 31</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>DIO30</name>
              <description>[30:30] Toggles bit 30</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>DIO29</name>
              <description>[29:29] Toggles bit 29</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DIO28</name>
              <description>[28:28] Toggles bit 28</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>DIO27</name>
              <description>[27:27] Toggles bit 27</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>DIO26</name>
              <description>[26:26] Toggles bit 26</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>DIO25</name>
              <description>[25:25] Toggles bit 25</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO24</name>
              <description>[24:24] Toggles bit 24</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DIO23</name>
              <description>[23:23] Toggles bit 23</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>DIO22</name>
              <description>[22:22] Toggles bit 22</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>DIO21</name>
              <description>[21:21] Toggles bit 21</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>DIO20</name>
              <description>[20:20] Toggles bit 20</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>DIO19</name>
              <description>[19:19] Toggles bit 19</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>DIO18</name>
              <description>[18:18] Toggles bit 18</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>DIO17</name>
              <description>[17:17] Toggles bit 17</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO16</name>
              <description>[16:16] Toggles bit 16</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DIO15</name>
              <description>[15:15] Toggles bit 15</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>DIO14</name>
              <description>[14:14] Toggles bit 14</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DIO13</name>
              <description>[13:13] Toggles bit 13</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>DIO12</name>
              <description>[12:12] Toggles bit 12</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DIO11</name>
              <description>[11:11] Toggles bit 11</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>DIO10</name>
              <description>[10:10] Toggles bit 10</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>DIO9</name>
              <description>[9:9] Toggles bit 9</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO8</name>
              <description>[8:8] Toggles bit 8</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DIO7</name>
              <description>[7:7] Toggles bit 7</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>DIO6</name>
              <description>[6:6] Toggles bit 6</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DIO5</name>
              <description>[5:5] Toggles bit 5</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>DIO4</name>
              <description>[4:4] Toggles bit 4</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DIO3</name>
              <description>[3:3] Toggles bit 3</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DIO2</name>
              <description>[2:2] Toggles bit 2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DIO1</name>
              <description>[1:1] Toggles bit 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO0</name>
              <description>[0:0] Toggles bit 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DIN31_0</name>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <description>Data Input from DIO 0 to 31</description>
          <fields>
            <field>
              <name>DIO31</name>
              <description>[31:31] Data input from DIO 31</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>DIO30</name>
              <description>[30:30] Data input from DIO 30</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>DIO29</name>
              <description>[29:29] Data input from DIO 29</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DIO28</name>
              <description>[28:28] Data input from DIO 28</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>DIO27</name>
              <description>[27:27] Data input from DIO 27</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>DIO26</name>
              <description>[26:26] Data input from DIO 26</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>DIO25</name>
              <description>[25:25] Data input from DIO 25</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO24</name>
              <description>[24:24] Data input from DIO 24</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DIO23</name>
              <description>[23:23] Data input from DIO 23</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>DIO22</name>
              <description>[22:22] Data input from DIO 22</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>DIO21</name>
              <description>[21:21] Data input from DIO 21</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>DIO20</name>
              <description>[20:20] Data input from DIO 20</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>DIO19</name>
              <description>[19:19] Data input from DIO 19</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>DIO18</name>
              <description>[18:18] Data input from DIO 18</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>DIO17</name>
              <description>[17:17] Data input from DIO 17</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO16</name>
              <description>[16:16] Data input from DIO 16</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DIO15</name>
              <description>[15:15] Data input from DIO 15</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>DIO14</name>
              <description>[14:14] Data input from DIO 14</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DIO13</name>
              <description>[13:13] Data input from DIO 13</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>DIO12</name>
              <description>[12:12] Data input from DIO 12</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DIO11</name>
              <description>[11:11] Data input from DIO 11</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>DIO10</name>
              <description>[10:10] Data input from DIO 10</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>DIO9</name>
              <description>[9:9] Data input from DIO 9</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO8</name>
              <description>[8:8] Data input from DIO 8</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DIO7</name>
              <description>[7:7] Data input from DIO 7</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>DIO6</name>
              <description>[6:6] Data input from DIO 6</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DIO5</name>
              <description>[5:5] Data input from DIO 5</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>DIO4</name>
              <description>[4:4] Data input from DIO 4</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DIO3</name>
              <description>[3:3] Data input from DIO 3</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DIO2</name>
              <description>[2:2] Data input from DIO 2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DIO1</name>
              <description>[1:1] Data input from DIO 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO0</name>
              <description>[0:0] Data input from DIO 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DOE31_0</name>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <description>Data Output Enable for DIO 0 to 31</description>
          <fields>
            <field>
              <name>DIO31</name>
              <description>[31:31] Data output enable for DIO 31</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>DIO30</name>
              <description>[30:30] Data output enable for DIO 30</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>DIO29</name>
              <description>[29:29] Data output enable for DIO 29</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DIO28</name>
              <description>[28:28] Data output enable for DIO 28</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>DIO27</name>
              <description>[27:27] Data output enable for DIO 27</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>DIO26</name>
              <description>[26:26] Data output enable for DIO 26</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>DIO25</name>
              <description>[25:25] Data output enable for DIO 25</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO24</name>
              <description>[24:24] Data output enable for DIO 24</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DIO23</name>
              <description>[23:23] Data output enable for DIO 23</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>DIO22</name>
              <description>[22:22] Data output enable for DIO 22</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>DIO21</name>
              <description>[21:21] Data output enable for DIO 21</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>DIO20</name>
              <description>[20:20] Data output enable for DIO 20</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>DIO19</name>
              <description>[19:19] Data output enable for DIO 19</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>DIO18</name>
              <description>[18:18] Data output enable for DIO 18</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>DIO17</name>
              <description>[17:17] Data output enable for DIO 17</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO16</name>
              <description>[16:16] Data output enable for DIO 16</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DIO15</name>
              <description>[15:15] Data output enable for DIO 15</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>DIO14</name>
              <description>[14:14] Data output enable for DIO 14</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DIO13</name>
              <description>[13:13] Data output enable for DIO 13</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>DIO12</name>
              <description>[12:12] Data output enable for DIO 12</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DIO11</name>
              <description>[11:11] Data output enable for DIO 11</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>DIO10</name>
              <description>[10:10] Data output enable for DIO 10</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>DIO9</name>
              <description>[9:9] Data output enable for DIO 9</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO8</name>
              <description>[8:8] Data output enable for DIO 8</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DIO7</name>
              <description>[7:7] Data output enable for DIO 7</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>DIO6</name>
              <description>[6:6] Data output enable for DIO 6</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DIO5</name>
              <description>[5:5] Data output enable for DIO 5</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>DIO4</name>
              <description>[4:4] Data output enable for DIO 4</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DIO3</name>
              <description>[3:3] Data output enable for DIO 3</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DIO2</name>
              <description>[2:2] Data output enable for DIO 2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DIO1</name>
              <description>[1:1] Data output enable for DIO 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO0</name>
              <description>[0:0] Data output enable for DIO 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>EVFLAGS31_0</name>
          <addressOffset>0xe0</addressOffset>
          <size>32</size>
          <description>Event Register for DIO 0 to 31

Reading  this registers will return 1 for triggered event and 0 for non-triggered events. 
Writing a 1 to a bit field will clear the event. 

The configuration of events is done inside MCU IOC, e.g. events for DIO #0 is configured in IOC:IOCFG0.EDGE_DET and IOC:IOCFG0.EDGE_IRQ_EN.</description>
          <fields>
            <field>
              <name>DIO31</name>
              <description>[31:31] Event for DIO 31</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>DIO30</name>
              <description>[30:30] Event for DIO 30</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>DIO29</name>
              <description>[29:29] Event for DIO 29</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>DIO28</name>
              <description>[28:28] Event for DIO 28</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>DIO27</name>
              <description>[27:27] Event for DIO 27</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>DIO26</name>
              <description>[26:26] Event for DIO 26</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>DIO25</name>
              <description>[25:25] Event for DIO 25</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>DIO24</name>
              <description>[24:24] Event for DIO 24</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>DIO23</name>
              <description>[23:23] Event for DIO 23</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>DIO22</name>
              <description>[22:22] Event for DIO 22</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>DIO21</name>
              <description>[21:21] Event for DIO 21</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>DIO20</name>
              <description>[20:20] Event for DIO 20</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>DIO19</name>
              <description>[19:19] Event for DIO 19</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>DIO18</name>
              <description>[18:18] Event for DIO 18</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>DIO17</name>
              <description>[17:17] Event for DIO 17</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>DIO16</name>
              <description>[16:16] Event for DIO 16</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DIO15</name>
              <description>[15:15] Event for DIO 15</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>DIO14</name>
              <description>[14:14] Event for DIO 14</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DIO13</name>
              <description>[13:13] Event for DIO 13</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>DIO12</name>
              <description>[12:12] Event for DIO 12</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>DIO11</name>
              <description>[11:11] Event for DIO 11</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>DIO10</name>
              <description>[10:10] Event for DIO 10</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>DIO9</name>
              <description>[9:9] Event for DIO 9</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DIO8</name>
              <description>[8:8] Event for DIO 8</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DIO7</name>
              <description>[7:7] Event for DIO 7</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>DIO6</name>
              <description>[6:6] Event for DIO 6</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DIO5</name>
              <description>[5:5] Event for DIO 5</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>DIO4</name>
              <description>[4:4] Event for DIO 4</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DIO3</name>
              <description>[3:3] Event for DIO 3</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DIO2</name>
              <description>[2:2] Event for DIO 2</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>DIO1</name>
              <description>[1:1] Event for DIO 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DIO0</name>
              <description>[0:0] Event for DIO 0</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPT0</name>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>General Purpose Timer.</description>
      <registers>
        <register>
          <name>CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Configuration</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CFG</name>
              <description>[2:0] GPT Configuration
0x2- 0x3 - Reserved
0x5- 0x7 - Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>16BIT_TIMER</name>
                  <value>4</value>
                  <description>16-bit timer configuration.  
Configure for two 16-bit timers.
Also see TAMR.TAMR and TBMR.TBMR.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>32BIT_TIMER</name>
                  <value>0</value>
                  <description>32-bit timer configuration</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAMR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Timer A Mode</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TCACT</name>
              <description>[15:13] Timer Compare Action Select</description>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLRSET_ON_TO</name>
                  <value>7</value>
                  <description>Clear CCP output pin immediately and set on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETCLR_ON_TO</name>
                  <value>6</value>
                  <description>Set CCP output pin immediately and clear on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLRTOG_ON_TO</name>
                  <value>5</value>
                  <description>Clear CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETTOG_ON_TO</name>
                  <value>4</value>
                  <description>Set CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET_ON_TO</name>
                  <value>3</value>
                  <description>Set CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR_ON_TO</name>
                  <value>2</value>
                  <description>Clear CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TOG_ON_TO</name>
                  <value>1</value>
                  <description>Toggle State on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS_CMP</name>
                  <value>0</value>
                  <description>Disable compare operations</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACINTD</name>
              <description>[12:12] One-Shot/Periodic Interrupt Disable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS_TO_INTR</name>
                  <value>1</value>
                  <description>Time-out interrupt are disabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_TO_INTR</name>
                  <value>0</value>
                  <description>Time-out interrupt function as normal</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAPLO</name>
              <description>[11:11] GPTM Timer A PWM Legacy Operation

0  Legacy operation with CCP pin driven Low when the TAILR 
register is reloaded after the timer reaches 0.

1 CCP is driven High when the TAILR  register is reloaded after the timer reaches 0.

This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CCP_ON_TO</name>
                  <value>1</value>
                  <description>CCP output pin is set to 1 on time-out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <value>0</value>
                  <description>Legacy operation</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMRSU</name>
              <description>[10:10] Timer A Match Register Update mode
 
This bit defines when the TAMATCHR and TAPR registers are updated.

If the timer is disabled (CTL.TAEN = 0) when this bit is set, TAMATCHR and TAPR are updated when the timer is enabled.
If the timer is stalled (CTL.TASTALL = 1) when this bit is set, TAMATCHR and TAPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update TAMATCHR and TAPR, if used, on the next time-out.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update TAMATCHR and TAPR, if used, on the next cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAPWMIE</name>
              <description>[9:9] GPTM Timer A PWM Interrupt Enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output, as defined by the CTL.TAEVENT
In addition, when this bit is set and a capture event occurs, Timer A
automatically generates triggers to the DMA if the trigger capability is enabled by setting the CTL.TAOTE bit and the DMAEV.CAEDMAEN bit respectively.

0 Capture event interrupt is disabled.
1 Capture event interrupt is enabled.
This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Interrupt is enabled.  This bit is only valid in PWM mode.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Interrupt is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAILD</name>
              <description>[8:8] GPT Timer A PWM Interval Load Write</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update the TAR register with the value in the TAILR register on the next timeout. If the prescaler is used, update the TAPS register with the value in the TAPR register on the next timeout.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update the TAR register with the value in the TAILR register on the next clock cycle. If the pre-scaler is used, update the TAPS register with the value in the TAPR register on the next clock cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TASNAPS</name>
              <description>[7:7] GPT Timer A Snap-Shot Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>If Timer A is configured in the periodic mode, the actual free-running value of Timer A is loaded at the time-out event into the GPT Timer A (TAR) register.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Snap-shot mode is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAWOT</name>
              <description>[6:6] GPT Timer A Wait-On-Trigger</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAIT</name>
                  <value>1</value>
                  <description>If Timer A is enabled (CTL.TAEN = 1), Timer A does not begin counting until it receives a trigger from the timer in the previous position in the daisy chain. This bit must be clear for GPT Module 0, Timer A. This function is valid for one-shot, periodic, and PWM modes</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOWAIT</name>
                  <value>0</value>
                  <description>Timer A begins counting as soon as it is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMIE</name>
              <description>[5:5] GPT Timer A Match Interrupt Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>An interrupt is generated when the match value in TAMATCHR is reached in the one-shot and periodic modes.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>The match interrupt is disabled for match events. Additionally, output triggers on match events are prevented.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACDIR</name>
              <description>[4:4] GPT Timer A Count Direction</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UP</name>
                  <value>1</value>
                  <description>The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DOWN</name>
                  <value>0</value>
                  <description>The timer counts down.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAAMS</name>
              <description>[3:3] GPT Timer A Alternate Mode 

Note: To enable PWM mode, you must also clear TACM and then configure TAMR field to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <value>1</value>
                  <description>PWM mode is enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAP_COMP</name>
                  <value>0</value>
                  <description>Capture/Compare mode is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACM</name>
              <description>[2:2] GPT Timer A Capture Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EDGTIME</name>
                  <value>1</value>
                  <description>Edge-Time mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EDGCNT</name>
                  <value>0</value>
                  <description>Edge-Count mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMR</name>
              <description>[1:0] GPT Timer A Mode

0x0 Reserved
0x1 One-Shot Timer mode
0x2 Periodic Timer mode
0x3 Capture mode
The Timer mode is based on the timer configuration defined by bits 2:0 in the CFG register</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CAPTURE</name>
                  <value>3</value>
                  <description>Capture mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PERIODIC</name>
                  <value>2</value>
                  <description>Periodic Timer mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ONE_SHOT</name>
                  <value>1</value>
                  <description>One-Shot Timer mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBMR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Timer B Mode</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TCACT</name>
              <description>[15:13] Timer Compare Action Select</description>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLRSET_ON_TO</name>
                  <value>7</value>
                  <description>Clear CCP output pin immediately and set on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETCLR_ON_TO</name>
                  <value>6</value>
                  <description>Set CCP output pin immediately and clear on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLRTOG_ON_TO</name>
                  <value>5</value>
                  <description>Clear CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETTOG_ON_TO</name>
                  <value>4</value>
                  <description>Set CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET_ON_TO</name>
                  <value>3</value>
                  <description>Set CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR_ON_TO</name>
                  <value>2</value>
                  <description>Clear CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TOG_ON_TO</name>
                  <value>1</value>
                  <description>Toggle State on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS_CMP</name>
                  <value>0</value>
                  <description>Disable compare operations</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBCINTD</name>
              <description>[12:12] One-Shot/Periodic Interrupt Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS_TO_INTR</name>
                  <value>1</value>
                  <description>Mask Time-Out Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_TO_INTR</name>
                  <value>0</value>
                  <description>Normal Time-Out Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBPLO</name>
              <description>[11:11] GPTM Timer B PWM Legacy Operation

0  Legacy operation with CCP pin driven Low when the TBILR 
register is reloaded after the timer reaches 0.

1 CCP is driven High when the TBILR  register is reloaded after the timer reaches 0.

This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CCP_ON_TO</name>
                  <value>1</value>
                  <description>CCP output pin is set to 1 on time-out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <value>0</value>
                  <description>Legacy operation</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBMRSU</name>
              <description>[10:10] Timer B Match Register Update mode
 
This bit defines when the TBMATCHR and TBPR registers are updated

If the timer is disabled (CTL.TBEN is clear) when this bit is set, TBMATCHR and TBPR are updated when the timer is enabled.
If the timer is stalled (CTL.TBSTALL is set) when this bit is set, TBMATCHR and TBPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update TBMATCHR and TBPR, if used, on the next time-out.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update TBMATCHR and TBPR, if used, on the next cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBPWMIE</name>
              <description>[9:9] GPTM Timer B PWM Interrupt Enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output, as defined by the CTL.TBEVENT
In addition, when this bit is set and a capture event occurs, Timer A
automatically generates triggers to the DMA if the trigger capability is enabled by setting the CTL.TBOTE bit and the DMAEV.CBEDMAEN bit respectively.

0 Capture event interrupt is disabled.
1 Capture event interrupt is enabled.
This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Interrupt is enabled.  This bit is only valid in PWM mode.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Interrupt is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBILD</name>
              <description>[8:8] GPT Timer B PWM Interval Load Write</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update the TBR register with the value in the TBILR register on the next timeout. If the prescaler is used, update the TBPS register with the value in the TBPR register on the next timeout.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update the TBR register with the value in the TBILR register on the next clock cycle. If the pre-scaler is used, update the TBPS register with the value in the TBPR register on the next clock cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBSNAPS</name>
              <description>[7:7] GPT Timer B Snap-Shot Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>If Timer B is configured in the periodic mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Snap-shot mode is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBWOT</name>
              <description>[6:6] GPT Timer B Wait-On-Trigger</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAIT</name>
                  <value>1</value>
                  <description>If Timer B is enabled (CTL.TBEN is set), Timer B does not begin counting until it receives a trigger from the timer in the previous position in the daisy chain. This function is valid for one-shot, periodic, and PWM modes</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOWAIT</name>
                  <value>0</value>
                  <description>Timer B begins counting as soon as it is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBMIE</name>
              <description>[5:5] GPT Timer B Match Interrupt Enable.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>An interrupt is generated when the match value in the TBMATCHR register is reached in the one-shot and periodic modes.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>The match interrupt is disabled for match events. Additionally, output triggers on match events are prevented.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBCDIR</name>
              <description>[4:4] GPT Timer B Count Direction</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UP</name>
                  <value>1</value>
                  <description>The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DOWN</name>
                  <value>0</value>
                  <description>The timer counts down.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBAMS</name>
              <description>[3:3] GPT Timer B Alternate Mode 

Note: To enable PWM mode, you must also clear TBCM bit and configure TBMR field to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <value>1</value>
                  <description>PWM mode is enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAP_COMP</name>
                  <value>0</value>
                  <description>Capture/Compare mode is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBCM</name>
              <description>[2:2] GPT Timer B Capture Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EDGTIME</name>
                  <value>1</value>
                  <description>Edge-Time mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EDGCNT</name>
                  <value>0</value>
                  <description>Edge-Count mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBMR</name>
              <description>[1:0] GPT Timer B Mode

0x0 Reserved
0x1 One-Shot Timer mode
0x2 Periodic Timer mode
0x3 Capture mode
The Timer mode is based on the timer configuration defined by bits 2:0 in the CFG register</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CAPTURE</name>
                  <value>3</value>
                  <description>Capture mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PERIODIC</name>
                  <value>2</value>
                  <description>Periodic Timer mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ONE_SHOT</name>
                  <value>1</value>
                  <description>One-Shot Timer mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Control</description>
          <fields>
            <field>
              <name>RESERVED15</name>
              <description>[31:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>TBPWML</name>
              <description>[14:14] GPT Timer B PWM Output Level

0: Output is unaffected. 
1: Output is inverted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVERTED</name>
                  <value>1</value>
                  <description>Inverted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Not inverted</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[13:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBEVENT</name>
              <description>[11:10] GPT Timer B Event Mode

The values in this register are defined as follows:
Value Description
0x0 Positive edge
0x1 Negative edge
0x2 Reserved
0x3 Both edges
Note: If PWM output inversion is enabled, edge detection interrupt
behavior is reversed. Thus, if a positive-edge interrupt trigger
has been set and the PWM inversion generates a postive
edge, no event-trigger interrupt asserts. Instead, the interrupt
is generated on the negative edge of the PWM signal.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Both edges</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>0</value>
                  <description>Positive edge</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBSTALL</name>
              <description>[9:9] GPT Timer B Stall Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer B freezes counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer B continues counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBEN</name>
              <description>[8:8] GPT Timer B Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer B is enabled and begins counting or the capture logic is enabled based on CFG register.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer B is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>[7:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TAPWML</name>
              <description>[6:6] GPT Timer A PWM Output Level</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVERTED</name>
                  <value>1</value>
                  <description>Inverted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Not inverted</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[5:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TAEVENT</name>
              <description>[3:2] GPT Timer A Event Mode

The values in this register are defined as follows:
Value Description
0x0 Positive edge
0x1 Negative edge
0x2 Reserved
0x3 Both edges
Note: If PWM output inversion is enabled, edge detection interrupt
behavior is reversed. Thus, if a positive-edge interrupt trigger
has been set and the PWM inversion generates a postive
edge, no event-trigger interrupt asserts. Instead, the interrupt
is generated on the negative edge of the PWM signal.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Both edges</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>0</value>
                  <description>Positive edge</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TASTALL</name>
              <description>[1:1] GPT Timer A Stall Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer A freezes counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer A continues counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAEN</name>
              <description>[0:0] GPT Timer A Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer A is enabled and begins counting or the capture logic is enabled based on the CFG register.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer A is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Synch Register</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYNC3</name>
              <description>[7:6] Synchronize GPT Timer 3.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT3 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT3 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT3 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT3 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNC2</name>
              <description>[5:4] Synchronize GPT Timer 2.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT2 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT2 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT2 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT2 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNC1</name>
              <description>[3:2] Synchronize GPT Timer 1</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT1 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT1 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT1 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT1 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNC0</name>
              <description>[1:0] Synchronize GPT Timer 0</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT0 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT0 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT0 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT0 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Interrupt Mask
This register is used to enable the interrupts.
Associated registers:
RIS, MIS, ICLR</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABIM</name>
              <description>[13:13] Enabling this bit will make the RIS.DMABRIS interrupt propagate to MIS.DMABMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMIM</name>
              <description>[11:11] Enabling this bit will make the RIS.TBMRIS interrupt propagate to MIS.TBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CBEIM</name>
              <description>[10:10] Enabling this bit will make the RIS.CBERIS interrupt propagate to MIS.CBEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CBMIM</name>
              <description>[9:9] Enabling this bit will make the RIS.CBMRIS interrupt propagate to MIS.CBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBTOIM</name>
              <description>[8:8] Enabling this bit will make the RIS.TBTORIS interrupt propagate to MIS.TBTOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAAIM</name>
              <description>[5:5] Enabling this bit will make the RIS.DMAARIS interrupt propagate to MIS.DMAAMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMIM</name>
              <description>[4:4] Enabling this bit will make the RIS.TAMRIS interrupt propagate to MIS.TAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEIM</name>
              <description>[2:2] Enabling this bit will make the RIS.CAERIS interrupt propagate to MIS.CAEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CAMIM</name>
              <description>[1:1] Enabling this bit will make the RIS.CAMRIS interrupt propagate to MIS.CAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TATOIM</name>
              <description>[0:0] Enabling this bit will make the RIS.TATORIS interrupt propagate to MIS.TATOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Raw Interrupt Status
Associated registers:
IMR, MIS, ICLR</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABRIS</name>
              <description>[13:13] GPT Timer B DMA Done Raw Interrupt Status

0: Transfer has not completed
1: Transfer has completed</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMRIS</name>
              <description>[11:11] GPT Timer B Match Raw  Interrupt

0:  The match value has not been reached
1:  The match value is reached.

TBMR.TBMIE is set, and the match values in TBMATCHR and optionally TBPMR have been reached when configured in one-shot or periodic mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBERIS</name>
              <description>[10:10] GPT Timer B Capture Mode Event Raw Interrupt

0:  The event has not occured.
1:  The event has occured.

This interrupt asserts when the subtimer is configured in Input Edge-Time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMRIS</name>
              <description>[9:9] GPT Timer B Capture Mode Match Raw Interrupt

0:  The capture mode match for Timer B has not occurred.
1:  A capture mode match has occurred for Timer B. This interrupt
asserts when the values in the TBR and TBPR
match the values in the TBMATCHR and TBPMR
when configured in Input Edge-Time mode.

This bit is cleared by writing a 1 to the ICLR.CBMCINT bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTORIS</name>
              <description>[8:8] GPT Timer B Time-out Raw Interrupt

0:  Timer B has not timed out
1:  Timer B has timed out. 

This interrupt is asserted when a one-shot or periodic mode timer reaches its count limit. The count limit is 0 or the value loaded into TBILR, depending on the count direction.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAARIS</name>
              <description>[5:5] GPT Timer A DMA Done Raw Interrupt Status

0: Transfer has not completed
1: Transfer has completed</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMRIS</name>
              <description>[4:4] GPT Timer A Match Raw  Interrupt

0:  The match value has not been reached
1:  The match value is reached.

TAMR.TAMIE is set, and the match values in TAMATCHR and optionally TAPMR have been reached when configured in one-shot or periodic mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAERIS</name>
              <description>[2:2] GPT Timer A Capture Mode Event Raw Interrupt

0:  The event has not occured.
1:  The event has occured.

This interrupt asserts when the subtimer is configured in Input Edge-Time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMRIS</name>
              <description>[1:1] GPT Timer A Capture Mode Match Raw Interrupt

0:  The capture mode match for Timer A has not occurred.
1:  A capture mode match has occurred for Timer A. This interrupt
asserts when the values in the TAR and TAPR
match the values in the TAMATCHR and TAPMR
when configured in Input Edge-Time mode.

This bit is cleared by writing a 1 to the ICLR.CAMCINT bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATORIS</name>
              <description>[0:0] GPT Timer A Time-out Raw Interrupt

0:  Timer A has not timed out
1:  Timer A has timed out. 

This interrupt is asserted when a one-shot or periodic mode timer reaches its count limit. The count limit is 0 or the value loaded into TAILR, depending on the count direction.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Masked Interrupt Status
Values are result of bitwise AND operation between RIS and IMR
Assosciated clear register: ICLR</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABMIS</name>
              <description>[13:13] 0: No interrupt or interrupt not enabled
1: RIS.DMABRIS = 1 &amp;&amp; IMR.DMABIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMMIS</name>
              <description>[11:11] 0: No interrupt or interrupt not enabled
1: RIS.TBMRIS = 1 &amp;&amp; IMR.TBMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEMIS</name>
              <description>[10:10] 0: No interrupt or interrupt not enabled
1: RIS.CBERIS = 1 &amp;&amp; IMR.CBEIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMMIS</name>
              <description>[9:9] 0: No interrupt or interrupt not enabled
1: RIS.CBMRIS = 1 &amp;&amp; IMR.CBMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOMIS</name>
              <description>[8:8] 0: No interrupt or interrupt not enabled
1: RIS.TBTORIS = 1 &amp;&amp; IMR.TBTOIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAAMIS</name>
              <description>[5:5] 0: No interrupt or interrupt not enabled
1: RIS.DMAARIS = 1 &amp;&amp; IMR.DMAAIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMMIS</name>
              <description>[4:4] 0: No interrupt or interrupt not enabled
1: RIS.TAMRIS = 1 &amp;&amp; IMR.TAMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEMIS</name>
              <description>[2:2] 0: No interrupt or interrupt not enabled
1: RIS.CAERIS = 1 &amp;&amp; IMR.CAEIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMMIS</name>
              <description>[1:1] 0: No interrupt or interrupt not enabled
1: RIS.CAMRIS = 1 &amp;&amp; IMR.CAMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOMIS</name>
              <description>[0:0] 0: No interrupt or interrupt not enabled
1: RIS.TATORIS = 1 &amp;&amp; IMR.TATOIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ICLR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Interrupt Clear
This register is used to clear status bits in the RIS and MIS registers</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABINT</name>
              <description>[13:13] 0: Do nothing.
1: Clear RIS.DMABRIS and MIS.DMABMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMCINT</name>
              <description>[11:11] 0: Do nothing.
1: Clear RIS.TBMRIS and MIS.TBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBECINT</name>
              <description>[10:10] 0: Do nothing.
1: Clear RIS.CBERIS and MIS.CBEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMCINT</name>
              <description>[9:9] 0: Do nothing.
1: Clear RIS.CBMRIS and MIS.CBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOCINT</name>
              <description>[8:8] 0: Do nothing.
1: Clear RIS.TBTORIS and MIS.TBTOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAAINT</name>
              <description>[5:5] 0: Do nothing.
1: Clear RIS.DMAARIS and MIS.DMAAMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMCINT</name>
              <description>[4:4] 0: Do nothing.
1: Clear RIS.TAMRIS and MIS.TAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAECINT</name>
              <description>[2:2] 0: Do nothing.
1: Clear RIS.CAERIS and MIS.CAEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMCINT</name>
              <description>[1:1] 0: Do nothing.
1: Clear RIS.CAMRIS and MIS.CAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOCINT</name>
              <description>[0:0] 0: Do nothing.
1: Clear RIS.TATORIS and MIS.TATOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAILR</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Timer A Interval Load  Register</description>
          <fields>
            <field>
              <name>TAILR</name>
              <description>[31:0] GPT Timer A Interval Load  Register

Writing this field loads the counter for Timer A. A read returns the current value of TAILR.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBILR</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Timer B Interval Load  Register</description>
          <fields>
            <field>
              <name>TBILR</name>
              <description>[31:0] GPT Timer B Interval Load  Register

Writing this field loads the counter for Timer B. A read returns the current value of TBILR.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAMATCHR</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Timer A Match Register

Interrupts can be generated when the timer value is equal to the value in this register in one-shot or periodic mode.

In Edge-Count mode, this register along with TAILR, determines how many edge events are counted.
The total number of edge events counted is equal to the value in TAILR minus this value.

Note that in edge-count mode, when executing an up-count, the value of TAPR and TAILR must be greater than the value of TAPMR and this register.

In PWM mode, this value along with TAILR, determines the duty cycle of the output PWM signal.

When a 16/32-bit GPT is configured to one of the 32-bit modes, TAMATCHR appears as a 32-bit register. (The upper 16-bits correspond to the contents TBMATCHR).

In a 16-bit mode, the upper 16 bits of this register read as 0s and have no effect on the state of TBMATCHR.

Note : This register is updated internally (takes effect) based on TAMR.TAMRSU</description>
          <fields>
            <field>
              <name>TAMATCHR</name>
              <description>[31:0] GPT Timer A Match Register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBMATCHR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Timer B Match Register

 When a GPT is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of  TAMATCHR.
Reads from this register return the current match value of Timer B and writes are ignored.
In a 16-bit mode, bits 15:0 are used for the match value. Bits 31:16 are reserved in both cases.

Note : This register is updated internally (takes effect) based on TBMR.TBMRSU</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBMATCHR</name>
              <description>[15:0] GPT Timer B Match Register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAPR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale
This register allows software to extend the range of the timers when they are used individually.
When in one-shot or periodic down count modes, this register acts as a true prescaler for the timer counter.
When acting as a true prescaler, the prescaler counts down to 0 before the value in TAR and TAV registers are incremented.
In all other individual/split modes, this register is a linear extension of the upper range of the timer counter, holding bits 23:16 in the 16-bit modes of the 16/32-bit GPT.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] Timer A Pre-scale.

Prescaler ratio in one-shot and periodic count mode is TAPSR + 1, that is:

0: Prescaler ratio = 1
1: Prescaler ratio = 2
2: Prescaler ratio = 3
...
255: Prescaler ratio = 256</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPR</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale
This register allows software to extend the range of the timers when they are used individually.
When in one-shot or periodic down count modes, this register acts as a true prescaler for the timer counter.
When acting as a true prescaler, the prescaler counts down to 0 before the value in TBR and TBV registers are incremented.
In all other individual/split modes, this register is a linear extension of the upper range of the timer counter, holding bits 23:16 in the 16-bit modes of the 16/32-bit GPT.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] Timer B Pre-scale.

Prescale ratio in one-shot and periodic count mode is TBPSR + 1, that is:

0: Prescaler ratio = 1
1: Prescaler ratio = 2
2: Prescaler ratio = 3
...
255: Prescaler ratio = 256</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAPMR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale Match
This register allows software to extend the range of the TAMATCHR when used individually.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSMR</name>
              <description>[7:0] GPT Timer A Pre-scale Match.  In 16 bit mode this field holds bits 23 to 16.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPMR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale Match
This register allows software to extend the range of the TBMATCHR when used individually.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSMR</name>
              <description>[7:0] GPT Timer B Pre-scale Match Register.  In 16 bit mode this field holds bits 23 to 16.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Timer A Register
This register shows the current value of the Timer A counter in all cases except for Input Edge Count and Time modes. In the Input Edge Count mode, this register contains the number of edges that
have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.

When a GPT is configured to one of the 32-bit modes, this register appears as a 32-bit register (the upper 16-bits correspond to the contents of the Timer B (TBR) register). In
the16-bit Input Edge Count, Input Edge Time, and PWM modes, bits 15:0 contain the value of the counter and bits 23:16 contain the value of the prescaler, which is the upper 8 bits of the count. Bits
31:24 always read as 0. To read the value of the prescaler in 16-bit One-Shot and Periodic modes, read bits [23:16] in the TAV register. To read the value of the prescalar in periodic snapshot
mode, read the Timer A Prescale Snapshot (TAPS) register.</description>
          <fields>
            <field>
              <name>TAR</name>
              <description>[31:0] GPT Timer A Register    

Based on the value in the register field TAMR.TAILD, this register is updated with the value from TAILR register either on the next cycle or on the next timeout.

A read returns the current value of the Timer A Count Register, in all cases except for Input Edge count and Timer modes. 
In the Input Edge Count Mode, this register contains the number of edges that have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBR</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Timer B Register
This register shows the current value of the Timer B counter in all cases except for Input Edge Count and Time modes. In the Input Edge Count mode, this register contains the number of edges that
have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.

When a GPTM is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of the TAR register. Reads from this register return the current
value of Timer B. In a 16-bit mode, bits 15:0 contain the value of the counter and bits 23:16 contain the value of the prescaler in Input Edge Count, Input Edge Time, and PWM modes, which is the
upper 8 bits of the count. Bits 31:24 always read as 0. To read the value of the prescaler in 16-bit One-Shot and Periodic modes, read bits [23:16] in the TBV register. To read the value of the
prescalar in periodic snapshot mode, read the Timer B Prescale Snapshot (TBPS) register.</description>
          <fields>
            <field>
              <name>TBR</name>
              <description>[31:0] GPT Timer B Register

Based on the value in the register field TBMR.TBILD, this register is updated with the value from TBILR register either on the next cycle or on the next timeout.

A read returns the current value of the Timer B Count Register, in all cases except for Input Edge count and Timer modes. 
In the Input Edge Count Mode, this register contains the number of edges that have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAV</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>Timer A Value 
When read, this register shows the current, free-running value of Timer A in all modes. Softwarecan use this value to determine the time elapsed between an interrupt and the ISR entry when using
the snapshot feature with the periodic operating mode. When written, the value written into this register is loaded into the TAR register on the next clock cycle.

When a 16/32-bit GPTM is configured to one of the 32-bit modes, this register appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B Value (TBV) register). In a 16-bit mode, bits 15:0 contain the value of the counter and bits 23:16 contain the current, free-running value of the prescaler, which is the upper 8 bits of the count in Input Edge Count, Input Edge Time, PWM and one-shot or periodic up count modes. In one-shot or periodic
down count modes, the prescaler stored in 23:16 is a true prescaler, meaning bits 23:16 count down before decrementing the value in bits 15:0. The prescaler in bits 31:24 always reads as 0.</description>
          <fields>
            <field>
              <name>TAV</name>
              <description>[31:0] GPT Timer A Register
A read returns the current, free-running value of Timer A in all modes.
When written, the value written into this register is loaded into the
TAR register on the next clock cycle.
Note: In 16-bit mode, only the lower 16-bits of this
register can be written with a new value. Writes to the prescaler bits have no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBV</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Timer B Value 
When read, this register shows the current, free-running value of Timer B in all modes. Software can use this value to determine the time elapsed between an interrupt and the ISR entry. When
written, the value written into this register is loaded into the TBR register on the next clock cycle.

When a 16/32-bit GPTM is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of the TAV register. Reads from this register return
the current free-running value of Timer B. In a 16-bit mode, bits 15:0 contain the value of the counter and bits 23:16 contain the current, free-running value of the prescaler, which is the upper 8 bits of
the count in Input Edge Count, Input Edge Time, PWM and one-shot or periodic up count modes.
In one-shot or periodic down count modes, the prescaler stored in 23:16 is a true prescaler, meaning bits 23:16 count down before decrementing the value in bits 15:0. The prescaler in bits 31:24 always reads as 0.</description>
          <fields>
            <field>
              <name>TBV</name>
              <description>[31:0] GPT Timer B Register
A read returns the current, free-running value of Timer B in all modes.
When written, the value written into this register is loaded into the
TBR register on the next clock cycle.
Note: In 16-bit mode, only the lower 16-bits of this
register can be written with a new value. Writes to the prescaler bits have no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAPS</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale Snap-shot 

Based on the value in the register field TAMR.TAILD, this register is updated with the value from TAPR register either on the next cycle or on the next timeout.


This register shows the current value of the Timer A pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[7:0] GPT Timer A Pre-scaler</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale Snap-shot 

Based on the value in the register field TBMR.TBILD, this register is updated with the value from TBPR register either on the next cycle or on the next timeout.

This register shows the current value of the Timer B pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[7:0] GPT Timer B Pre-scaler</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAPV</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale Value 
This register shows the current value of the Timer A free running pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[7:0] GPT Timer A Pre-scaler Value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPV</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale Value 
This register shows the current value of the Timer B free running pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[7:0] GPT Timer B Pre-scaler Value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMAEV</name>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <description>DMA Event 
This register allows software to enable/disable GPT DMA trigger events.</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Software should not rely on the value of a reserved field.  Writing any other value may result in undefined behavior.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMDMAEN</name>
              <description>[11:11] GPT Timer B Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEDMAEN</name>
              <description>[10:10] GPT Timer B Capture Event DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMDMAEN</name>
              <description>[9:9] GPT Timer B Capture Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTODMAEN</name>
              <description>[8:8] GPT Timer B Time-Out DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[7:5] Software should not rely on the value of a reserved field.  Writing any other value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMDMAEN</name>
              <description>[4:4] GPT Timer A Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEDMAEN</name>
              <description>[2:2] GPT Timer A Capture Event DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMDMAEN</name>
              <description>[1:1] GPT Timer A Capture Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATODMAEN</name>
              <description>[0:0] GPT Timer A Time-Out DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>VERSION</name>
          <addressOffset>0xfb0</addressOffset>
          <size>32</size>
          <description>Peripheral Version
This register provides information regarding the GPT version</description>
          <fields>
            <field>
              <name>VERSION</name>
              <description>[31:0] Timer Revision.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x400</resetValue>
        </register>
        <register>
          <name>ANDCCP</name>
          <addressOffset>0xfb4</addressOffset>
          <size>32</size>
          <description>Combined CCP Output
This register is used to logically AND CCP output pairs for each timer</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CCP_AND_EN</name>
              <description>[0:0] Enables AND operation of the CCP outputs for timers A and B.

0 : PWM outputs of Timer A and Timer B are the internal generated PWM signals of the respective timers.
1 : PWM output of Timer A is ANDed version of Timer A and Timer B PWM signals and Timer B PWM ouput is Timer B PWM signal only.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPT1</name>
      <baseAddress>0x40011000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>General Purpose Timer.</description>
      <registers>
        <register>
          <name>CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Configuration</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CFG</name>
              <description>[2:0] GPT Configuration
0x2- 0x3 - Reserved
0x5- 0x7 - Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>16BIT_TIMER</name>
                  <value>4</value>
                  <description>16-bit timer configuration.  
Configure for two 16-bit timers.
Also see TAMR.TAMR and TBMR.TBMR.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>32BIT_TIMER</name>
                  <value>0</value>
                  <description>32-bit timer configuration</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAMR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Timer A Mode</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TCACT</name>
              <description>[15:13] Timer Compare Action Select</description>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLRSET_ON_TO</name>
                  <value>7</value>
                  <description>Clear CCP output pin immediately and set on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETCLR_ON_TO</name>
                  <value>6</value>
                  <description>Set CCP output pin immediately and clear on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLRTOG_ON_TO</name>
                  <value>5</value>
                  <description>Clear CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETTOG_ON_TO</name>
                  <value>4</value>
                  <description>Set CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET_ON_TO</name>
                  <value>3</value>
                  <description>Set CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR_ON_TO</name>
                  <value>2</value>
                  <description>Clear CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TOG_ON_TO</name>
                  <value>1</value>
                  <description>Toggle State on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS_CMP</name>
                  <value>0</value>
                  <description>Disable compare operations</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACINTD</name>
              <description>[12:12] One-Shot/Periodic Interrupt Disable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS_TO_INTR</name>
                  <value>1</value>
                  <description>Time-out interrupt are disabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_TO_INTR</name>
                  <value>0</value>
                  <description>Time-out interrupt function as normal</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAPLO</name>
              <description>[11:11] GPTM Timer A PWM Legacy Operation

0  Legacy operation with CCP pin driven Low when the TAILR 
register is reloaded after the timer reaches 0.

1 CCP is driven High when the TAILR  register is reloaded after the timer reaches 0.

This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CCP_ON_TO</name>
                  <value>1</value>
                  <description>CCP output pin is set to 1 on time-out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <value>0</value>
                  <description>Legacy operation</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMRSU</name>
              <description>[10:10] Timer A Match Register Update mode
 
This bit defines when the TAMATCHR and TAPR registers are updated.

If the timer is disabled (CTL.TAEN = 0) when this bit is set, TAMATCHR and TAPR are updated when the timer is enabled.
If the timer is stalled (CTL.TASTALL = 1) when this bit is set, TAMATCHR and TAPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update TAMATCHR and TAPR, if used, on the next time-out.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update TAMATCHR and TAPR, if used, on the next cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAPWMIE</name>
              <description>[9:9] GPTM Timer A PWM Interrupt Enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output, as defined by the CTL.TAEVENT
In addition, when this bit is set and a capture event occurs, Timer A
automatically generates triggers to the DMA if the trigger capability is enabled by setting the CTL.TAOTE bit and the DMAEV.CAEDMAEN bit respectively.

0 Capture event interrupt is disabled.
1 Capture event interrupt is enabled.
This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Interrupt is enabled.  This bit is only valid in PWM mode.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Interrupt is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAILD</name>
              <description>[8:8] GPT Timer A PWM Interval Load Write</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update the TAR register with the value in the TAILR register on the next timeout. If the prescaler is used, update the TAPS register with the value in the TAPR register on the next timeout.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update the TAR register with the value in the TAILR register on the next clock cycle. If the pre-scaler is used, update the TAPS register with the value in the TAPR register on the next clock cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TASNAPS</name>
              <description>[7:7] GPT Timer A Snap-Shot Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>If Timer A is configured in the periodic mode, the actual free-running value of Timer A is loaded at the time-out event into the GPT Timer A (TAR) register.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Snap-shot mode is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAWOT</name>
              <description>[6:6] GPT Timer A Wait-On-Trigger</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAIT</name>
                  <value>1</value>
                  <description>If Timer A is enabled (CTL.TAEN = 1), Timer A does not begin counting until it receives a trigger from the timer in the previous position in the daisy chain. This bit must be clear for GPT Module 0, Timer A. This function is valid for one-shot, periodic, and PWM modes</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOWAIT</name>
                  <value>0</value>
                  <description>Timer A begins counting as soon as it is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMIE</name>
              <description>[5:5] GPT Timer A Match Interrupt Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>An interrupt is generated when the match value in TAMATCHR is reached in the one-shot and periodic modes.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>The match interrupt is disabled for match events. Additionally, output triggers on match events are prevented.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACDIR</name>
              <description>[4:4] GPT Timer A Count Direction</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UP</name>
                  <value>1</value>
                  <description>The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DOWN</name>
                  <value>0</value>
                  <description>The timer counts down.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAAMS</name>
              <description>[3:3] GPT Timer A Alternate Mode 

Note: To enable PWM mode, you must also clear TACM and then configure TAMR field to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <value>1</value>
                  <description>PWM mode is enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAP_COMP</name>
                  <value>0</value>
                  <description>Capture/Compare mode is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACM</name>
              <description>[2:2] GPT Timer A Capture Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EDGTIME</name>
                  <value>1</value>
                  <description>Edge-Time mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EDGCNT</name>
                  <value>0</value>
                  <description>Edge-Count mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMR</name>
              <description>[1:0] GPT Timer A Mode

0x0 Reserved
0x1 One-Shot Timer mode
0x2 Periodic Timer mode
0x3 Capture mode
The Timer mode is based on the timer configuration defined by bits 2:0 in the CFG register</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CAPTURE</name>
                  <value>3</value>
                  <description>Capture mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PERIODIC</name>
                  <value>2</value>
                  <description>Periodic Timer mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ONE_SHOT</name>
                  <value>1</value>
                  <description>One-Shot Timer mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBMR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Timer B Mode</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TCACT</name>
              <description>[15:13] Timer Compare Action Select</description>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLRSET_ON_TO</name>
                  <value>7</value>
                  <description>Clear CCP output pin immediately and set on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETCLR_ON_TO</name>
                  <value>6</value>
                  <description>Set CCP output pin immediately and clear on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLRTOG_ON_TO</name>
                  <value>5</value>
                  <description>Clear CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETTOG_ON_TO</name>
                  <value>4</value>
                  <description>Set CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET_ON_TO</name>
                  <value>3</value>
                  <description>Set CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR_ON_TO</name>
                  <value>2</value>
                  <description>Clear CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TOG_ON_TO</name>
                  <value>1</value>
                  <description>Toggle State on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS_CMP</name>
                  <value>0</value>
                  <description>Disable compare operations</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBCINTD</name>
              <description>[12:12] One-Shot/Periodic Interrupt Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS_TO_INTR</name>
                  <value>1</value>
                  <description>Mask Time-Out Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_TO_INTR</name>
                  <value>0</value>
                  <description>Normal Time-Out Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBPLO</name>
              <description>[11:11] GPTM Timer B PWM Legacy Operation

0  Legacy operation with CCP pin driven Low when the TBILR 
register is reloaded after the timer reaches 0.

1 CCP is driven High when the TBILR  register is reloaded after the timer reaches 0.

This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CCP_ON_TO</name>
                  <value>1</value>
                  <description>CCP output pin is set to 1 on time-out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <value>0</value>
                  <description>Legacy operation</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBMRSU</name>
              <description>[10:10] Timer B Match Register Update mode
 
This bit defines when the TBMATCHR and TBPR registers are updated

If the timer is disabled (CTL.TBEN is clear) when this bit is set, TBMATCHR and TBPR are updated when the timer is enabled.
If the timer is stalled (CTL.TBSTALL is set) when this bit is set, TBMATCHR and TBPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update TBMATCHR and TBPR, if used, on the next time-out.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update TBMATCHR and TBPR, if used, on the next cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBPWMIE</name>
              <description>[9:9] GPTM Timer B PWM Interrupt Enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output, as defined by the CTL.TBEVENT
In addition, when this bit is set and a capture event occurs, Timer A
automatically generates triggers to the DMA if the trigger capability is enabled by setting the CTL.TBOTE bit and the DMAEV.CBEDMAEN bit respectively.

0 Capture event interrupt is disabled.
1 Capture event interrupt is enabled.
This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Interrupt is enabled.  This bit is only valid in PWM mode.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Interrupt is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBILD</name>
              <description>[8:8] GPT Timer B PWM Interval Load Write</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update the TBR register with the value in the TBILR register on the next timeout. If the prescaler is used, update the TBPS register with the value in the TBPR register on the next timeout.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update the TBR register with the value in the TBILR register on the next clock cycle. If the pre-scaler is used, update the TBPS register with the value in the TBPR register on the next clock cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBSNAPS</name>
              <description>[7:7] GPT Timer B Snap-Shot Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>If Timer B is configured in the periodic mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Snap-shot mode is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBWOT</name>
              <description>[6:6] GPT Timer B Wait-On-Trigger</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAIT</name>
                  <value>1</value>
                  <description>If Timer B is enabled (CTL.TBEN is set), Timer B does not begin counting until it receives a trigger from the timer in the previous position in the daisy chain. This function is valid for one-shot, periodic, and PWM modes</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOWAIT</name>
                  <value>0</value>
                  <description>Timer B begins counting as soon as it is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBMIE</name>
              <description>[5:5] GPT Timer B Match Interrupt Enable.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>An interrupt is generated when the match value in the TBMATCHR register is reached in the one-shot and periodic modes.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>The match interrupt is disabled for match events. Additionally, output triggers on match events are prevented.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBCDIR</name>
              <description>[4:4] GPT Timer B Count Direction</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UP</name>
                  <value>1</value>
                  <description>The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DOWN</name>
                  <value>0</value>
                  <description>The timer counts down.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBAMS</name>
              <description>[3:3] GPT Timer B Alternate Mode 

Note: To enable PWM mode, you must also clear TBCM bit and configure TBMR field to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <value>1</value>
                  <description>PWM mode is enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAP_COMP</name>
                  <value>0</value>
                  <description>Capture/Compare mode is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBCM</name>
              <description>[2:2] GPT Timer B Capture Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EDGTIME</name>
                  <value>1</value>
                  <description>Edge-Time mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EDGCNT</name>
                  <value>0</value>
                  <description>Edge-Count mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBMR</name>
              <description>[1:0] GPT Timer B Mode

0x0 Reserved
0x1 One-Shot Timer mode
0x2 Periodic Timer mode
0x3 Capture mode
The Timer mode is based on the timer configuration defined by bits 2:0 in the CFG register</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CAPTURE</name>
                  <value>3</value>
                  <description>Capture mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PERIODIC</name>
                  <value>2</value>
                  <description>Periodic Timer mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ONE_SHOT</name>
                  <value>1</value>
                  <description>One-Shot Timer mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Control</description>
          <fields>
            <field>
              <name>RESERVED15</name>
              <description>[31:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>TBPWML</name>
              <description>[14:14] GPT Timer B PWM Output Level

0: Output is unaffected. 
1: Output is inverted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVERTED</name>
                  <value>1</value>
                  <description>Inverted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Not inverted</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[13:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBEVENT</name>
              <description>[11:10] GPT Timer B Event Mode

The values in this register are defined as follows:
Value Description
0x0 Positive edge
0x1 Negative edge
0x2 Reserved
0x3 Both edges
Note: If PWM output inversion is enabled, edge detection interrupt
behavior is reversed. Thus, if a positive-edge interrupt trigger
has been set and the PWM inversion generates a postive
edge, no event-trigger interrupt asserts. Instead, the interrupt
is generated on the negative edge of the PWM signal.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Both edges</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>0</value>
                  <description>Positive edge</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBSTALL</name>
              <description>[9:9] GPT Timer B Stall Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer B freezes counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer B continues counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBEN</name>
              <description>[8:8] GPT Timer B Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer B is enabled and begins counting or the capture logic is enabled based on CFG register.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer B is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>[7:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TAPWML</name>
              <description>[6:6] GPT Timer A PWM Output Level</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVERTED</name>
                  <value>1</value>
                  <description>Inverted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Not inverted</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[5:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TAEVENT</name>
              <description>[3:2] GPT Timer A Event Mode

The values in this register are defined as follows:
Value Description
0x0 Positive edge
0x1 Negative edge
0x2 Reserved
0x3 Both edges
Note: If PWM output inversion is enabled, edge detection interrupt
behavior is reversed. Thus, if a positive-edge interrupt trigger
has been set and the PWM inversion generates a postive
edge, no event-trigger interrupt asserts. Instead, the interrupt
is generated on the negative edge of the PWM signal.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Both edges</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>0</value>
                  <description>Positive edge</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TASTALL</name>
              <description>[1:1] GPT Timer A Stall Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer A freezes counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer A continues counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAEN</name>
              <description>[0:0] GPT Timer A Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer A is enabled and begins counting or the capture logic is enabled based on the CFG register.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer A is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Synch Register</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYNC3</name>
              <description>[7:6] Synchronize GPT Timer 3.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT3 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT3 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT3 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT3 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNC2</name>
              <description>[5:4] Synchronize GPT Timer 2.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT2 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT2 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT2 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT2 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNC1</name>
              <description>[3:2] Synchronize GPT Timer 1</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT1 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT1 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT1 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT1 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNC0</name>
              <description>[1:0] Synchronize GPT Timer 0</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT0 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT0 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT0 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT0 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Interrupt Mask
This register is used to enable the interrupts.
Associated registers:
RIS, MIS, ICLR</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABIM</name>
              <description>[13:13] Enabling this bit will make the RIS.DMABRIS interrupt propagate to MIS.DMABMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMIM</name>
              <description>[11:11] Enabling this bit will make the RIS.TBMRIS interrupt propagate to MIS.TBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CBEIM</name>
              <description>[10:10] Enabling this bit will make the RIS.CBERIS interrupt propagate to MIS.CBEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CBMIM</name>
              <description>[9:9] Enabling this bit will make the RIS.CBMRIS interrupt propagate to MIS.CBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBTOIM</name>
              <description>[8:8] Enabling this bit will make the RIS.TBTORIS interrupt propagate to MIS.TBTOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAAIM</name>
              <description>[5:5] Enabling this bit will make the RIS.DMAARIS interrupt propagate to MIS.DMAAMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMIM</name>
              <description>[4:4] Enabling this bit will make the RIS.TAMRIS interrupt propagate to MIS.TAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEIM</name>
              <description>[2:2] Enabling this bit will make the RIS.CAERIS interrupt propagate to MIS.CAEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CAMIM</name>
              <description>[1:1] Enabling this bit will make the RIS.CAMRIS interrupt propagate to MIS.CAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TATOIM</name>
              <description>[0:0] Enabling this bit will make the RIS.TATORIS interrupt propagate to MIS.TATOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Raw Interrupt Status
Associated registers:
IMR, MIS, ICLR</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABRIS</name>
              <description>[13:13] GPT Timer B DMA Done Raw Interrupt Status

0: Transfer has not completed
1: Transfer has completed</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMRIS</name>
              <description>[11:11] GPT Timer B Match Raw  Interrupt

0:  The match value has not been reached
1:  The match value is reached.

TBMR.TBMIE is set, and the match values in TBMATCHR and optionally TBPMR have been reached when configured in one-shot or periodic mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBERIS</name>
              <description>[10:10] GPT Timer B Capture Mode Event Raw Interrupt

0:  The event has not occured.
1:  The event has occured.

This interrupt asserts when the subtimer is configured in Input Edge-Time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMRIS</name>
              <description>[9:9] GPT Timer B Capture Mode Match Raw Interrupt

0:  The capture mode match for Timer B has not occurred.
1:  A capture mode match has occurred for Timer B. This interrupt
asserts when the values in the TBR and TBPR
match the values in the TBMATCHR and TBPMR
when configured in Input Edge-Time mode.

This bit is cleared by writing a 1 to the ICLR.CBMCINT bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTORIS</name>
              <description>[8:8] GPT Timer B Time-out Raw Interrupt

0:  Timer B has not timed out
1:  Timer B has timed out. 

This interrupt is asserted when a one-shot or periodic mode timer reaches its count limit. The count limit is 0 or the value loaded into TBILR, depending on the count direction.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAARIS</name>
              <description>[5:5] GPT Timer A DMA Done Raw Interrupt Status

0: Transfer has not completed
1: Transfer has completed</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMRIS</name>
              <description>[4:4] GPT Timer A Match Raw  Interrupt

0:  The match value has not been reached
1:  The match value is reached.

TAMR.TAMIE is set, and the match values in TAMATCHR and optionally TAPMR have been reached when configured in one-shot or periodic mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAERIS</name>
              <description>[2:2] GPT Timer A Capture Mode Event Raw Interrupt

0:  The event has not occured.
1:  The event has occured.

This interrupt asserts when the subtimer is configured in Input Edge-Time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMRIS</name>
              <description>[1:1] GPT Timer A Capture Mode Match Raw Interrupt

0:  The capture mode match for Timer A has not occurred.
1:  A capture mode match has occurred for Timer A. This interrupt
asserts when the values in the TAR and TAPR
match the values in the TAMATCHR and TAPMR
when configured in Input Edge-Time mode.

This bit is cleared by writing a 1 to the ICLR.CAMCINT bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATORIS</name>
              <description>[0:0] GPT Timer A Time-out Raw Interrupt

0:  Timer A has not timed out
1:  Timer A has timed out. 

This interrupt is asserted when a one-shot or periodic mode timer reaches its count limit. The count limit is 0 or the value loaded into TAILR, depending on the count direction.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Masked Interrupt Status
Values are result of bitwise AND operation between RIS and IMR
Assosciated clear register: ICLR</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABMIS</name>
              <description>[13:13] 0: No interrupt or interrupt not enabled
1: RIS.DMABRIS = 1 &amp;&amp; IMR.DMABIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMMIS</name>
              <description>[11:11] 0: No interrupt or interrupt not enabled
1: RIS.TBMRIS = 1 &amp;&amp; IMR.TBMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEMIS</name>
              <description>[10:10] 0: No interrupt or interrupt not enabled
1: RIS.CBERIS = 1 &amp;&amp; IMR.CBEIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMMIS</name>
              <description>[9:9] 0: No interrupt or interrupt not enabled
1: RIS.CBMRIS = 1 &amp;&amp; IMR.CBMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOMIS</name>
              <description>[8:8] 0: No interrupt or interrupt not enabled
1: RIS.TBTORIS = 1 &amp;&amp; IMR.TBTOIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAAMIS</name>
              <description>[5:5] 0: No interrupt or interrupt not enabled
1: RIS.DMAARIS = 1 &amp;&amp; IMR.DMAAIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMMIS</name>
              <description>[4:4] 0: No interrupt or interrupt not enabled
1: RIS.TAMRIS = 1 &amp;&amp; IMR.TAMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEMIS</name>
              <description>[2:2] 0: No interrupt or interrupt not enabled
1: RIS.CAERIS = 1 &amp;&amp; IMR.CAEIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMMIS</name>
              <description>[1:1] 0: No interrupt or interrupt not enabled
1: RIS.CAMRIS = 1 &amp;&amp; IMR.CAMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOMIS</name>
              <description>[0:0] 0: No interrupt or interrupt not enabled
1: RIS.TATORIS = 1 &amp;&amp; IMR.TATOIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ICLR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Interrupt Clear
This register is used to clear status bits in the RIS and MIS registers</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABINT</name>
              <description>[13:13] 0: Do nothing.
1: Clear RIS.DMABRIS and MIS.DMABMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMCINT</name>
              <description>[11:11] 0: Do nothing.
1: Clear RIS.TBMRIS and MIS.TBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBECINT</name>
              <description>[10:10] 0: Do nothing.
1: Clear RIS.CBERIS and MIS.CBEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMCINT</name>
              <description>[9:9] 0: Do nothing.
1: Clear RIS.CBMRIS and MIS.CBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOCINT</name>
              <description>[8:8] 0: Do nothing.
1: Clear RIS.TBTORIS and MIS.TBTOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAAINT</name>
              <description>[5:5] 0: Do nothing.
1: Clear RIS.DMAARIS and MIS.DMAAMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMCINT</name>
              <description>[4:4] 0: Do nothing.
1: Clear RIS.TAMRIS and MIS.TAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAECINT</name>
              <description>[2:2] 0: Do nothing.
1: Clear RIS.CAERIS and MIS.CAEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMCINT</name>
              <description>[1:1] 0: Do nothing.
1: Clear RIS.CAMRIS and MIS.CAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOCINT</name>
              <description>[0:0] 0: Do nothing.
1: Clear RIS.TATORIS and MIS.TATOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAILR</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Timer A Interval Load  Register</description>
          <fields>
            <field>
              <name>TAILR</name>
              <description>[31:0] GPT Timer A Interval Load  Register

Writing this field loads the counter for Timer A. A read returns the current value of TAILR.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBILR</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Timer B Interval Load  Register</description>
          <fields>
            <field>
              <name>TBILR</name>
              <description>[31:0] GPT Timer B Interval Load  Register

Writing this field loads the counter for Timer B. A read returns the current value of TBILR.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAMATCHR</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Timer A Match Register

Interrupts can be generated when the timer value is equal to the value in this register in one-shot or periodic mode.

In Edge-Count mode, this register along with TAILR, determines how many edge events are counted.
The total number of edge events counted is equal to the value in TAILR minus this value.

Note that in edge-count mode, when executing an up-count, the value of TAPR and TAILR must be greater than the value of TAPMR and this register.

In PWM mode, this value along with TAILR, determines the duty cycle of the output PWM signal.

When a 16/32-bit GPT is configured to one of the 32-bit modes, TAMATCHR appears as a 32-bit register. (The upper 16-bits correspond to the contents TBMATCHR).

In a 16-bit mode, the upper 16 bits of this register read as 0s and have no effect on the state of TBMATCHR.

Note : This register is updated internally (takes effect) based on TAMR.TAMRSU</description>
          <fields>
            <field>
              <name>TAMATCHR</name>
              <description>[31:0] GPT Timer A Match Register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBMATCHR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Timer B Match Register

 When a GPT is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of  TAMATCHR.
Reads from this register return the current match value of Timer B and writes are ignored.
In a 16-bit mode, bits 15:0 are used for the match value. Bits 31:16 are reserved in both cases.

Note : This register is updated internally (takes effect) based on TBMR.TBMRSU</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBMATCHR</name>
              <description>[15:0] GPT Timer B Match Register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAPR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale
This register allows software to extend the range of the timers when they are used individually.
When in one-shot or periodic down count modes, this register acts as a true prescaler for the timer counter.
When acting as a true prescaler, the prescaler counts down to 0 before the value in TAR and TAV registers are incremented.
In all other individual/split modes, this register is a linear extension of the upper range of the timer counter, holding bits 23:16 in the 16-bit modes of the 16/32-bit GPT.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] Timer A Pre-scale.

Prescaler ratio in one-shot and periodic count mode is TAPSR + 1, that is:

0: Prescaler ratio = 1
1: Prescaler ratio = 2
2: Prescaler ratio = 3
...
255: Prescaler ratio = 256</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPR</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale
This register allows software to extend the range of the timers when they are used individually.
When in one-shot or periodic down count modes, this register acts as a true prescaler for the timer counter.
When acting as a true prescaler, the prescaler counts down to 0 before the value in TBR and TBV registers are incremented.
In all other individual/split modes, this register is a linear extension of the upper range of the timer counter, holding bits 23:16 in the 16-bit modes of the 16/32-bit GPT.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] Timer B Pre-scale.

Prescale ratio in one-shot and periodic count mode is TBPSR + 1, that is:

0: Prescaler ratio = 1
1: Prescaler ratio = 2
2: Prescaler ratio = 3
...
255: Prescaler ratio = 256</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAPMR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale Match
This register allows software to extend the range of the TAMATCHR when used individually.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSMR</name>
              <description>[7:0] GPT Timer A Pre-scale Match.  In 16 bit mode this field holds bits 23 to 16.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPMR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale Match
This register allows software to extend the range of the TBMATCHR when used individually.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSMR</name>
              <description>[7:0] GPT Timer B Pre-scale Match Register.  In 16 bit mode this field holds bits 23 to 16.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Timer A Register
This register shows the current value of the Timer A counter in all cases except for Input Edge Count and Time modes. In the Input Edge Count mode, this register contains the number of edges that
have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.

When a GPT is configured to one of the 32-bit modes, this register appears as a 32-bit register (the upper 16-bits correspond to the contents of the Timer B (TBR) register). In
the16-bit Input Edge Count, Input Edge Time, and PWM modes, bits 15:0 contain the value of the counter and bits 23:16 contain the value of the prescaler, which is the upper 8 bits of the count. Bits
31:24 always read as 0. To read the value of the prescaler in 16-bit One-Shot and Periodic modes, read bits [23:16] in the TAV register. To read the value of the prescalar in periodic snapshot
mode, read the Timer A Prescale Snapshot (TAPS) register.</description>
          <fields>
            <field>
              <name>TAR</name>
              <description>[31:0] GPT Timer A Register    

Based on the value in the register field TAMR.TAILD, this register is updated with the value from TAILR register either on the next cycle or on the next timeout.

A read returns the current value of the Timer A Count Register, in all cases except for Input Edge count and Timer modes. 
In the Input Edge Count Mode, this register contains the number of edges that have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBR</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Timer B Register
This register shows the current value of the Timer B counter in all cases except for Input Edge Count and Time modes. In the Input Edge Count mode, this register contains the number of edges that
have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.

When a GPTM is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of the TAR register. Reads from this register return the current
value of Timer B. In a 16-bit mode, bits 15:0 contain the value of the counter and bits 23:16 contain the value of the prescaler in Input Edge Count, Input Edge Time, and PWM modes, which is the
upper 8 bits of the count. Bits 31:24 always read as 0. To read the value of the prescaler in 16-bit One-Shot and Periodic modes, read bits [23:16] in the TBV register. To read the value of the
prescalar in periodic snapshot mode, read the Timer B Prescale Snapshot (TBPS) register.</description>
          <fields>
            <field>
              <name>TBR</name>
              <description>[31:0] GPT Timer B Register

Based on the value in the register field TBMR.TBILD, this register is updated with the value from TBILR register either on the next cycle or on the next timeout.

A read returns the current value of the Timer B Count Register, in all cases except for Input Edge count and Timer modes. 
In the Input Edge Count Mode, this register contains the number of edges that have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAV</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>Timer A Value 
When read, this register shows the current, free-running value of Timer A in all modes. Softwarecan use this value to determine the time elapsed between an interrupt and the ISR entry when using
the snapshot feature with the periodic operating mode. When written, the value written into this register is loaded into the TAR register on the next clock cycle.

When a 16/32-bit GPTM is configured to one of the 32-bit modes, this register appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B Value (TBV) register). In a 16-bit mode, bits 15:0 contain the value of the counter and bits 23:16 contain the current, free-running value of the prescaler, which is the upper 8 bits of the count in Input Edge Count, Input Edge Time, PWM and one-shot or periodic up count modes. In one-shot or periodic
down count modes, the prescaler stored in 23:16 is a true prescaler, meaning bits 23:16 count down before decrementing the value in bits 15:0. The prescaler in bits 31:24 always reads as 0.</description>
          <fields>
            <field>
              <name>TAV</name>
              <description>[31:0] GPT Timer A Register
A read returns the current, free-running value of Timer A in all modes.
When written, the value written into this register is loaded into the
TAR register on the next clock cycle.
Note: In 16-bit mode, only the lower 16-bits of this
register can be written with a new value. Writes to the prescaler bits have no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBV</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Timer B Value 
When read, this register shows the current, free-running value of Timer B in all modes. Software can use this value to determine the time elapsed between an interrupt and the ISR entry. When
written, the value written into this register is loaded into the TBR register on the next clock cycle.

When a 16/32-bit GPTM is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of the TAV register. Reads from this register return
the current free-running value of Timer B. In a 16-bit mode, bits 15:0 contain the value of the counter and bits 23:16 contain the current, free-running value of the prescaler, which is the upper 8 bits of
the count in Input Edge Count, Input Edge Time, PWM and one-shot or periodic up count modes.
In one-shot or periodic down count modes, the prescaler stored in 23:16 is a true prescaler, meaning bits 23:16 count down before decrementing the value in bits 15:0. The prescaler in bits 31:24 always reads as 0.</description>
          <fields>
            <field>
              <name>TBV</name>
              <description>[31:0] GPT Timer B Register
A read returns the current, free-running value of Timer B in all modes.
When written, the value written into this register is loaded into the
TBR register on the next clock cycle.
Note: In 16-bit mode, only the lower 16-bits of this
register can be written with a new value. Writes to the prescaler bits have no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAPS</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale Snap-shot 

Based on the value in the register field TAMR.TAILD, this register is updated with the value from TAPR register either on the next cycle or on the next timeout.


This register shows the current value of the Timer A pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[7:0] GPT Timer A Pre-scaler</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale Snap-shot 

Based on the value in the register field TBMR.TBILD, this register is updated with the value from TBPR register either on the next cycle or on the next timeout.

This register shows the current value of the Timer B pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[7:0] GPT Timer B Pre-scaler</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAPV</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale Value 
This register shows the current value of the Timer A free running pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[7:0] GPT Timer A Pre-scaler Value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPV</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale Value 
This register shows the current value of the Timer B free running pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[7:0] GPT Timer B Pre-scaler Value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMAEV</name>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <description>DMA Event 
This register allows software to enable/disable GPT DMA trigger events.</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Software should not rely on the value of a reserved field.  Writing any other value may result in undefined behavior.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMDMAEN</name>
              <description>[11:11] GPT Timer B Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEDMAEN</name>
              <description>[10:10] GPT Timer B Capture Event DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMDMAEN</name>
              <description>[9:9] GPT Timer B Capture Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTODMAEN</name>
              <description>[8:8] GPT Timer B Time-Out DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[7:5] Software should not rely on the value of a reserved field.  Writing any other value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMDMAEN</name>
              <description>[4:4] GPT Timer A Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEDMAEN</name>
              <description>[2:2] GPT Timer A Capture Event DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMDMAEN</name>
              <description>[1:1] GPT Timer A Capture Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATODMAEN</name>
              <description>[0:0] GPT Timer A Time-Out DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>VERSION</name>
          <addressOffset>0xfb0</addressOffset>
          <size>32</size>
          <description>Peripheral Version
This register provides information regarding the GPT version</description>
          <fields>
            <field>
              <name>VERSION</name>
              <description>[31:0] Timer Revision.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x400</resetValue>
        </register>
        <register>
          <name>ANDCCP</name>
          <addressOffset>0xfb4</addressOffset>
          <size>32</size>
          <description>Combined CCP Output
This register is used to logically AND CCP output pairs for each timer</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CCP_AND_EN</name>
              <description>[0:0] Enables AND operation of the CCP outputs for timers A and B.

0 : PWM outputs of Timer A and Timer B are the internal generated PWM signals of the respective timers.
1 : PWM output of Timer A is ANDed version of Timer A and Timer B PWM signals and Timer B PWM ouput is Timer B PWM signal only.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPT2</name>
      <baseAddress>0x40012000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>General Purpose Timer.</description>
      <registers>
        <register>
          <name>CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Configuration</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CFG</name>
              <description>[2:0] GPT Configuration
0x2- 0x3 - Reserved
0x5- 0x7 - Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>16BIT_TIMER</name>
                  <value>4</value>
                  <description>16-bit timer configuration.  
Configure for two 16-bit timers.
Also see TAMR.TAMR and TBMR.TBMR.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>32BIT_TIMER</name>
                  <value>0</value>
                  <description>32-bit timer configuration</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAMR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Timer A Mode</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TCACT</name>
              <description>[15:13] Timer Compare Action Select</description>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLRSET_ON_TO</name>
                  <value>7</value>
                  <description>Clear CCP output pin immediately and set on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETCLR_ON_TO</name>
                  <value>6</value>
                  <description>Set CCP output pin immediately and clear on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLRTOG_ON_TO</name>
                  <value>5</value>
                  <description>Clear CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETTOG_ON_TO</name>
                  <value>4</value>
                  <description>Set CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET_ON_TO</name>
                  <value>3</value>
                  <description>Set CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR_ON_TO</name>
                  <value>2</value>
                  <description>Clear CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TOG_ON_TO</name>
                  <value>1</value>
                  <description>Toggle State on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS_CMP</name>
                  <value>0</value>
                  <description>Disable compare operations</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACINTD</name>
              <description>[12:12] One-Shot/Periodic Interrupt Disable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS_TO_INTR</name>
                  <value>1</value>
                  <description>Time-out interrupt are disabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_TO_INTR</name>
                  <value>0</value>
                  <description>Time-out interrupt function as normal</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAPLO</name>
              <description>[11:11] GPTM Timer A PWM Legacy Operation

0  Legacy operation with CCP pin driven Low when the TAILR 
register is reloaded after the timer reaches 0.

1 CCP is driven High when the TAILR  register is reloaded after the timer reaches 0.

This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CCP_ON_TO</name>
                  <value>1</value>
                  <description>CCP output pin is set to 1 on time-out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <value>0</value>
                  <description>Legacy operation</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMRSU</name>
              <description>[10:10] Timer A Match Register Update mode
 
This bit defines when the TAMATCHR and TAPR registers are updated.

If the timer is disabled (CTL.TAEN = 0) when this bit is set, TAMATCHR and TAPR are updated when the timer is enabled.
If the timer is stalled (CTL.TASTALL = 1) when this bit is set, TAMATCHR and TAPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update TAMATCHR and TAPR, if used, on the next time-out.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update TAMATCHR and TAPR, if used, on the next cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAPWMIE</name>
              <description>[9:9] GPTM Timer A PWM Interrupt Enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output, as defined by the CTL.TAEVENT
In addition, when this bit is set and a capture event occurs, Timer A
automatically generates triggers to the DMA if the trigger capability is enabled by setting the CTL.TAOTE bit and the DMAEV.CAEDMAEN bit respectively.

0 Capture event interrupt is disabled.
1 Capture event interrupt is enabled.
This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Interrupt is enabled.  This bit is only valid in PWM mode.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Interrupt is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAILD</name>
              <description>[8:8] GPT Timer A PWM Interval Load Write</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update the TAR register with the value in the TAILR register on the next timeout. If the prescaler is used, update the TAPS register with the value in the TAPR register on the next timeout.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update the TAR register with the value in the TAILR register on the next clock cycle. If the pre-scaler is used, update the TAPS register with the value in the TAPR register on the next clock cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TASNAPS</name>
              <description>[7:7] GPT Timer A Snap-Shot Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>If Timer A is configured in the periodic mode, the actual free-running value of Timer A is loaded at the time-out event into the GPT Timer A (TAR) register.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Snap-shot mode is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAWOT</name>
              <description>[6:6] GPT Timer A Wait-On-Trigger</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAIT</name>
                  <value>1</value>
                  <description>If Timer A is enabled (CTL.TAEN = 1), Timer A does not begin counting until it receives a trigger from the timer in the previous position in the daisy chain. This bit must be clear for GPT Module 0, Timer A. This function is valid for one-shot, periodic, and PWM modes</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOWAIT</name>
                  <value>0</value>
                  <description>Timer A begins counting as soon as it is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMIE</name>
              <description>[5:5] GPT Timer A Match Interrupt Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>An interrupt is generated when the match value in TAMATCHR is reached in the one-shot and periodic modes.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>The match interrupt is disabled for match events. Additionally, output triggers on match events are prevented.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACDIR</name>
              <description>[4:4] GPT Timer A Count Direction</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UP</name>
                  <value>1</value>
                  <description>The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DOWN</name>
                  <value>0</value>
                  <description>The timer counts down.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAAMS</name>
              <description>[3:3] GPT Timer A Alternate Mode 

Note: To enable PWM mode, you must also clear TACM and then configure TAMR field to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <value>1</value>
                  <description>PWM mode is enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAP_COMP</name>
                  <value>0</value>
                  <description>Capture/Compare mode is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACM</name>
              <description>[2:2] GPT Timer A Capture Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EDGTIME</name>
                  <value>1</value>
                  <description>Edge-Time mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EDGCNT</name>
                  <value>0</value>
                  <description>Edge-Count mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMR</name>
              <description>[1:0] GPT Timer A Mode

0x0 Reserved
0x1 One-Shot Timer mode
0x2 Periodic Timer mode
0x3 Capture mode
The Timer mode is based on the timer configuration defined by bits 2:0 in the CFG register</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CAPTURE</name>
                  <value>3</value>
                  <description>Capture mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PERIODIC</name>
                  <value>2</value>
                  <description>Periodic Timer mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ONE_SHOT</name>
                  <value>1</value>
                  <description>One-Shot Timer mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBMR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Timer B Mode</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TCACT</name>
              <description>[15:13] Timer Compare Action Select</description>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLRSET_ON_TO</name>
                  <value>7</value>
                  <description>Clear CCP output pin immediately and set on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETCLR_ON_TO</name>
                  <value>6</value>
                  <description>Set CCP output pin immediately and clear on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLRTOG_ON_TO</name>
                  <value>5</value>
                  <description>Clear CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETTOG_ON_TO</name>
                  <value>4</value>
                  <description>Set CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET_ON_TO</name>
                  <value>3</value>
                  <description>Set CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR_ON_TO</name>
                  <value>2</value>
                  <description>Clear CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TOG_ON_TO</name>
                  <value>1</value>
                  <description>Toggle State on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS_CMP</name>
                  <value>0</value>
                  <description>Disable compare operations</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBCINTD</name>
              <description>[12:12] One-Shot/Periodic Interrupt Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS_TO_INTR</name>
                  <value>1</value>
                  <description>Mask Time-Out Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_TO_INTR</name>
                  <value>0</value>
                  <description>Normal Time-Out Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBPLO</name>
              <description>[11:11] GPTM Timer B PWM Legacy Operation

0  Legacy operation with CCP pin driven Low when the TBILR 
register is reloaded after the timer reaches 0.

1 CCP is driven High when the TBILR  register is reloaded after the timer reaches 0.

This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CCP_ON_TO</name>
                  <value>1</value>
                  <description>CCP output pin is set to 1 on time-out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <value>0</value>
                  <description>Legacy operation</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBMRSU</name>
              <description>[10:10] Timer B Match Register Update mode
 
This bit defines when the TBMATCHR and TBPR registers are updated

If the timer is disabled (CTL.TBEN is clear) when this bit is set, TBMATCHR and TBPR are updated when the timer is enabled.
If the timer is stalled (CTL.TBSTALL is set) when this bit is set, TBMATCHR and TBPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update TBMATCHR and TBPR, if used, on the next time-out.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update TBMATCHR and TBPR, if used, on the next cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBPWMIE</name>
              <description>[9:9] GPTM Timer B PWM Interrupt Enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output, as defined by the CTL.TBEVENT
In addition, when this bit is set and a capture event occurs, Timer A
automatically generates triggers to the DMA if the trigger capability is enabled by setting the CTL.TBOTE bit and the DMAEV.CBEDMAEN bit respectively.

0 Capture event interrupt is disabled.
1 Capture event interrupt is enabled.
This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Interrupt is enabled.  This bit is only valid in PWM mode.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Interrupt is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBILD</name>
              <description>[8:8] GPT Timer B PWM Interval Load Write</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update the TBR register with the value in the TBILR register on the next timeout. If the prescaler is used, update the TBPS register with the value in the TBPR register on the next timeout.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update the TBR register with the value in the TBILR register on the next clock cycle. If the pre-scaler is used, update the TBPS register with the value in the TBPR register on the next clock cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBSNAPS</name>
              <description>[7:7] GPT Timer B Snap-Shot Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>If Timer B is configured in the periodic mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Snap-shot mode is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBWOT</name>
              <description>[6:6] GPT Timer B Wait-On-Trigger</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAIT</name>
                  <value>1</value>
                  <description>If Timer B is enabled (CTL.TBEN is set), Timer B does not begin counting until it receives a trigger from the timer in the previous position in the daisy chain. This function is valid for one-shot, periodic, and PWM modes</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOWAIT</name>
                  <value>0</value>
                  <description>Timer B begins counting as soon as it is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBMIE</name>
              <description>[5:5] GPT Timer B Match Interrupt Enable.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>An interrupt is generated when the match value in the TBMATCHR register is reached in the one-shot and periodic modes.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>The match interrupt is disabled for match events. Additionally, output triggers on match events are prevented.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBCDIR</name>
              <description>[4:4] GPT Timer B Count Direction</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UP</name>
                  <value>1</value>
                  <description>The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DOWN</name>
                  <value>0</value>
                  <description>The timer counts down.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBAMS</name>
              <description>[3:3] GPT Timer B Alternate Mode 

Note: To enable PWM mode, you must also clear TBCM bit and configure TBMR field to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <value>1</value>
                  <description>PWM mode is enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAP_COMP</name>
                  <value>0</value>
                  <description>Capture/Compare mode is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBCM</name>
              <description>[2:2] GPT Timer B Capture Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EDGTIME</name>
                  <value>1</value>
                  <description>Edge-Time mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EDGCNT</name>
                  <value>0</value>
                  <description>Edge-Count mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBMR</name>
              <description>[1:0] GPT Timer B Mode

0x0 Reserved
0x1 One-Shot Timer mode
0x2 Periodic Timer mode
0x3 Capture mode
The Timer mode is based on the timer configuration defined by bits 2:0 in the CFG register</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CAPTURE</name>
                  <value>3</value>
                  <description>Capture mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PERIODIC</name>
                  <value>2</value>
                  <description>Periodic Timer mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ONE_SHOT</name>
                  <value>1</value>
                  <description>One-Shot Timer mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Control</description>
          <fields>
            <field>
              <name>RESERVED15</name>
              <description>[31:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>TBPWML</name>
              <description>[14:14] GPT Timer B PWM Output Level

0: Output is unaffected. 
1: Output is inverted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVERTED</name>
                  <value>1</value>
                  <description>Inverted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Not inverted</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[13:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBEVENT</name>
              <description>[11:10] GPT Timer B Event Mode

The values in this register are defined as follows:
Value Description
0x0 Positive edge
0x1 Negative edge
0x2 Reserved
0x3 Both edges
Note: If PWM output inversion is enabled, edge detection interrupt
behavior is reversed. Thus, if a positive-edge interrupt trigger
has been set and the PWM inversion generates a postive
edge, no event-trigger interrupt asserts. Instead, the interrupt
is generated on the negative edge of the PWM signal.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Both edges</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>0</value>
                  <description>Positive edge</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBSTALL</name>
              <description>[9:9] GPT Timer B Stall Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer B freezes counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer B continues counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBEN</name>
              <description>[8:8] GPT Timer B Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer B is enabled and begins counting or the capture logic is enabled based on CFG register.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer B is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>[7:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TAPWML</name>
              <description>[6:6] GPT Timer A PWM Output Level</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVERTED</name>
                  <value>1</value>
                  <description>Inverted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Not inverted</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[5:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TAEVENT</name>
              <description>[3:2] GPT Timer A Event Mode

The values in this register are defined as follows:
Value Description
0x0 Positive edge
0x1 Negative edge
0x2 Reserved
0x3 Both edges
Note: If PWM output inversion is enabled, edge detection interrupt
behavior is reversed. Thus, if a positive-edge interrupt trigger
has been set and the PWM inversion generates a postive
edge, no event-trigger interrupt asserts. Instead, the interrupt
is generated on the negative edge of the PWM signal.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Both edges</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>0</value>
                  <description>Positive edge</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TASTALL</name>
              <description>[1:1] GPT Timer A Stall Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer A freezes counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer A continues counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAEN</name>
              <description>[0:0] GPT Timer A Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer A is enabled and begins counting or the capture logic is enabled based on the CFG register.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer A is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Synch Register</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYNC3</name>
              <description>[7:6] Synchronize GPT Timer 3.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT3 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT3 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT3 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT3 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNC2</name>
              <description>[5:4] Synchronize GPT Timer 2.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT2 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT2 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT2 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT2 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNC1</name>
              <description>[3:2] Synchronize GPT Timer 1</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT1 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT1 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT1 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT1 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNC0</name>
              <description>[1:0] Synchronize GPT Timer 0</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT0 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT0 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT0 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT0 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Interrupt Mask
This register is used to enable the interrupts.
Associated registers:
RIS, MIS, ICLR</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABIM</name>
              <description>[13:13] Enabling this bit will make the RIS.DMABRIS interrupt propagate to MIS.DMABMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMIM</name>
              <description>[11:11] Enabling this bit will make the RIS.TBMRIS interrupt propagate to MIS.TBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CBEIM</name>
              <description>[10:10] Enabling this bit will make the RIS.CBERIS interrupt propagate to MIS.CBEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CBMIM</name>
              <description>[9:9] Enabling this bit will make the RIS.CBMRIS interrupt propagate to MIS.CBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBTOIM</name>
              <description>[8:8] Enabling this bit will make the RIS.TBTORIS interrupt propagate to MIS.TBTOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAAIM</name>
              <description>[5:5] Enabling this bit will make the RIS.DMAARIS interrupt propagate to MIS.DMAAMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMIM</name>
              <description>[4:4] Enabling this bit will make the RIS.TAMRIS interrupt propagate to MIS.TAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEIM</name>
              <description>[2:2] Enabling this bit will make the RIS.CAERIS interrupt propagate to MIS.CAEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CAMIM</name>
              <description>[1:1] Enabling this bit will make the RIS.CAMRIS interrupt propagate to MIS.CAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TATOIM</name>
              <description>[0:0] Enabling this bit will make the RIS.TATORIS interrupt propagate to MIS.TATOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Raw Interrupt Status
Associated registers:
IMR, MIS, ICLR</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABRIS</name>
              <description>[13:13] GPT Timer B DMA Done Raw Interrupt Status

0: Transfer has not completed
1: Transfer has completed</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMRIS</name>
              <description>[11:11] GPT Timer B Match Raw  Interrupt

0:  The match value has not been reached
1:  The match value is reached.

TBMR.TBMIE is set, and the match values in TBMATCHR and optionally TBPMR have been reached when configured in one-shot or periodic mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBERIS</name>
              <description>[10:10] GPT Timer B Capture Mode Event Raw Interrupt

0:  The event has not occured.
1:  The event has occured.

This interrupt asserts when the subtimer is configured in Input Edge-Time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMRIS</name>
              <description>[9:9] GPT Timer B Capture Mode Match Raw Interrupt

0:  The capture mode match for Timer B has not occurred.
1:  A capture mode match has occurred for Timer B. This interrupt
asserts when the values in the TBR and TBPR
match the values in the TBMATCHR and TBPMR
when configured in Input Edge-Time mode.

This bit is cleared by writing a 1 to the ICLR.CBMCINT bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTORIS</name>
              <description>[8:8] GPT Timer B Time-out Raw Interrupt

0:  Timer B has not timed out
1:  Timer B has timed out. 

This interrupt is asserted when a one-shot or periodic mode timer reaches its count limit. The count limit is 0 or the value loaded into TBILR, depending on the count direction.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAARIS</name>
              <description>[5:5] GPT Timer A DMA Done Raw Interrupt Status

0: Transfer has not completed
1: Transfer has completed</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMRIS</name>
              <description>[4:4] GPT Timer A Match Raw  Interrupt

0:  The match value has not been reached
1:  The match value is reached.

TAMR.TAMIE is set, and the match values in TAMATCHR and optionally TAPMR have been reached when configured in one-shot or periodic mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAERIS</name>
              <description>[2:2] GPT Timer A Capture Mode Event Raw Interrupt

0:  The event has not occured.
1:  The event has occured.

This interrupt asserts when the subtimer is configured in Input Edge-Time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMRIS</name>
              <description>[1:1] GPT Timer A Capture Mode Match Raw Interrupt

0:  The capture mode match for Timer A has not occurred.
1:  A capture mode match has occurred for Timer A. This interrupt
asserts when the values in the TAR and TAPR
match the values in the TAMATCHR and TAPMR
when configured in Input Edge-Time mode.

This bit is cleared by writing a 1 to the ICLR.CAMCINT bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATORIS</name>
              <description>[0:0] GPT Timer A Time-out Raw Interrupt

0:  Timer A has not timed out
1:  Timer A has timed out. 

This interrupt is asserted when a one-shot or periodic mode timer reaches its count limit. The count limit is 0 or the value loaded into TAILR, depending on the count direction.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Masked Interrupt Status
Values are result of bitwise AND operation between RIS and IMR
Assosciated clear register: ICLR</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABMIS</name>
              <description>[13:13] 0: No interrupt or interrupt not enabled
1: RIS.DMABRIS = 1 &amp;&amp; IMR.DMABIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMMIS</name>
              <description>[11:11] 0: No interrupt or interrupt not enabled
1: RIS.TBMRIS = 1 &amp;&amp; IMR.TBMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEMIS</name>
              <description>[10:10] 0: No interrupt or interrupt not enabled
1: RIS.CBERIS = 1 &amp;&amp; IMR.CBEIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMMIS</name>
              <description>[9:9] 0: No interrupt or interrupt not enabled
1: RIS.CBMRIS = 1 &amp;&amp; IMR.CBMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOMIS</name>
              <description>[8:8] 0: No interrupt or interrupt not enabled
1: RIS.TBTORIS = 1 &amp;&amp; IMR.TBTOIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAAMIS</name>
              <description>[5:5] 0: No interrupt or interrupt not enabled
1: RIS.DMAARIS = 1 &amp;&amp; IMR.DMAAIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMMIS</name>
              <description>[4:4] 0: No interrupt or interrupt not enabled
1: RIS.TAMRIS = 1 &amp;&amp; IMR.TAMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEMIS</name>
              <description>[2:2] 0: No interrupt or interrupt not enabled
1: RIS.CAERIS = 1 &amp;&amp; IMR.CAEIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMMIS</name>
              <description>[1:1] 0: No interrupt or interrupt not enabled
1: RIS.CAMRIS = 1 &amp;&amp; IMR.CAMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOMIS</name>
              <description>[0:0] 0: No interrupt or interrupt not enabled
1: RIS.TATORIS = 1 &amp;&amp; IMR.TATOIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ICLR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Interrupt Clear
This register is used to clear status bits in the RIS and MIS registers</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABINT</name>
              <description>[13:13] 0: Do nothing.
1: Clear RIS.DMABRIS and MIS.DMABMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMCINT</name>
              <description>[11:11] 0: Do nothing.
1: Clear RIS.TBMRIS and MIS.TBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBECINT</name>
              <description>[10:10] 0: Do nothing.
1: Clear RIS.CBERIS and MIS.CBEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMCINT</name>
              <description>[9:9] 0: Do nothing.
1: Clear RIS.CBMRIS and MIS.CBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOCINT</name>
              <description>[8:8] 0: Do nothing.
1: Clear RIS.TBTORIS and MIS.TBTOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAAINT</name>
              <description>[5:5] 0: Do nothing.
1: Clear RIS.DMAARIS and MIS.DMAAMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMCINT</name>
              <description>[4:4] 0: Do nothing.
1: Clear RIS.TAMRIS and MIS.TAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAECINT</name>
              <description>[2:2] 0: Do nothing.
1: Clear RIS.CAERIS and MIS.CAEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMCINT</name>
              <description>[1:1] 0: Do nothing.
1: Clear RIS.CAMRIS and MIS.CAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOCINT</name>
              <description>[0:0] 0: Do nothing.
1: Clear RIS.TATORIS and MIS.TATOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAILR</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Timer A Interval Load  Register</description>
          <fields>
            <field>
              <name>TAILR</name>
              <description>[31:0] GPT Timer A Interval Load  Register

Writing this field loads the counter for Timer A. A read returns the current value of TAILR.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBILR</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Timer B Interval Load  Register</description>
          <fields>
            <field>
              <name>TBILR</name>
              <description>[31:0] GPT Timer B Interval Load  Register

Writing this field loads the counter for Timer B. A read returns the current value of TBILR.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAMATCHR</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Timer A Match Register

Interrupts can be generated when the timer value is equal to the value in this register in one-shot or periodic mode.

In Edge-Count mode, this register along with TAILR, determines how many edge events are counted.
The total number of edge events counted is equal to the value in TAILR minus this value.

Note that in edge-count mode, when executing an up-count, the value of TAPR and TAILR must be greater than the value of TAPMR and this register.

In PWM mode, this value along with TAILR, determines the duty cycle of the output PWM signal.

When a 16/32-bit GPT is configured to one of the 32-bit modes, TAMATCHR appears as a 32-bit register. (The upper 16-bits correspond to the contents TBMATCHR).

In a 16-bit mode, the upper 16 bits of this register read as 0s and have no effect on the state of TBMATCHR.

Note : This register is updated internally (takes effect) based on TAMR.TAMRSU</description>
          <fields>
            <field>
              <name>TAMATCHR</name>
              <description>[31:0] GPT Timer A Match Register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBMATCHR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Timer B Match Register

 When a GPT is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of  TAMATCHR.
Reads from this register return the current match value of Timer B and writes are ignored.
In a 16-bit mode, bits 15:0 are used for the match value. Bits 31:16 are reserved in both cases.

Note : This register is updated internally (takes effect) based on TBMR.TBMRSU</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBMATCHR</name>
              <description>[15:0] GPT Timer B Match Register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAPR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale
This register allows software to extend the range of the timers when they are used individually.
When in one-shot or periodic down count modes, this register acts as a true prescaler for the timer counter.
When acting as a true prescaler, the prescaler counts down to 0 before the value in TAR and TAV registers are incremented.
In all other individual/split modes, this register is a linear extension of the upper range of the timer counter, holding bits 23:16 in the 16-bit modes of the 16/32-bit GPT.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] Timer A Pre-scale.

Prescaler ratio in one-shot and periodic count mode is TAPSR + 1, that is:

0: Prescaler ratio = 1
1: Prescaler ratio = 2
2: Prescaler ratio = 3
...
255: Prescaler ratio = 256</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPR</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale
This register allows software to extend the range of the timers when they are used individually.
When in one-shot or periodic down count modes, this register acts as a true prescaler for the timer counter.
When acting as a true prescaler, the prescaler counts down to 0 before the value in TBR and TBV registers are incremented.
In all other individual/split modes, this register is a linear extension of the upper range of the timer counter, holding bits 23:16 in the 16-bit modes of the 16/32-bit GPT.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] Timer B Pre-scale.

Prescale ratio in one-shot and periodic count mode is TBPSR + 1, that is:

0: Prescaler ratio = 1
1: Prescaler ratio = 2
2: Prescaler ratio = 3
...
255: Prescaler ratio = 256</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAPMR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale Match
This register allows software to extend the range of the TAMATCHR when used individually.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSMR</name>
              <description>[7:0] GPT Timer A Pre-scale Match.  In 16 bit mode this field holds bits 23 to 16.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPMR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale Match
This register allows software to extend the range of the TBMATCHR when used individually.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSMR</name>
              <description>[7:0] GPT Timer B Pre-scale Match Register.  In 16 bit mode this field holds bits 23 to 16.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Timer A Register
This register shows the current value of the Timer A counter in all cases except for Input Edge Count and Time modes. In the Input Edge Count mode, this register contains the number of edges that
have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.

When a GPT is configured to one of the 32-bit modes, this register appears as a 32-bit register (the upper 16-bits correspond to the contents of the Timer B (TBR) register). In
the16-bit Input Edge Count, Input Edge Time, and PWM modes, bits 15:0 contain the value of the counter and bits 23:16 contain the value of the prescaler, which is the upper 8 bits of the count. Bits
31:24 always read as 0. To read the value of the prescaler in 16-bit One-Shot and Periodic modes, read bits [23:16] in the TAV register. To read the value of the prescalar in periodic snapshot
mode, read the Timer A Prescale Snapshot (TAPS) register.</description>
          <fields>
            <field>
              <name>TAR</name>
              <description>[31:0] GPT Timer A Register    

Based on the value in the register field TAMR.TAILD, this register is updated with the value from TAILR register either on the next cycle or on the next timeout.

A read returns the current value of the Timer A Count Register, in all cases except for Input Edge count and Timer modes. 
In the Input Edge Count Mode, this register contains the number of edges that have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBR</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Timer B Register
This register shows the current value of the Timer B counter in all cases except for Input Edge Count and Time modes. In the Input Edge Count mode, this register contains the number of edges that
have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.

When a GPTM is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of the TAR register. Reads from this register return the current
value of Timer B. In a 16-bit mode, bits 15:0 contain the value of the counter and bits 23:16 contain the value of the prescaler in Input Edge Count, Input Edge Time, and PWM modes, which is the
upper 8 bits of the count. Bits 31:24 always read as 0. To read the value of the prescaler in 16-bit One-Shot and Periodic modes, read bits [23:16] in the TBV register. To read the value of the
prescalar in periodic snapshot mode, read the Timer B Prescale Snapshot (TBPS) register.</description>
          <fields>
            <field>
              <name>TBR</name>
              <description>[31:0] GPT Timer B Register

Based on the value in the register field TBMR.TBILD, this register is updated with the value from TBILR register either on the next cycle or on the next timeout.

A read returns the current value of the Timer B Count Register, in all cases except for Input Edge count and Timer modes. 
In the Input Edge Count Mode, this register contains the number of edges that have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAV</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>Timer A Value 
When read, this register shows the current, free-running value of Timer A in all modes. Softwarecan use this value to determine the time elapsed between an interrupt and the ISR entry when using
the snapshot feature with the periodic operating mode. When written, the value written into this register is loaded into the TAR register on the next clock cycle.

When a 16/32-bit GPTM is configured to one of the 32-bit modes, this register appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B Value (TBV) register). In a 16-bit mode, bits 15:0 contain the value of the counter and bits 23:16 contain the current, free-running value of the prescaler, which is the upper 8 bits of the count in Input Edge Count, Input Edge Time, PWM and one-shot or periodic up count modes. In one-shot or periodic
down count modes, the prescaler stored in 23:16 is a true prescaler, meaning bits 23:16 count down before decrementing the value in bits 15:0. The prescaler in bits 31:24 always reads as 0.</description>
          <fields>
            <field>
              <name>TAV</name>
              <description>[31:0] GPT Timer A Register
A read returns the current, free-running value of Timer A in all modes.
When written, the value written into this register is loaded into the
TAR register on the next clock cycle.
Note: In 16-bit mode, only the lower 16-bits of this
register can be written with a new value. Writes to the prescaler bits have no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBV</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Timer B Value 
When read, this register shows the current, free-running value of Timer B in all modes. Software can use this value to determine the time elapsed between an interrupt and the ISR entry. When
written, the value written into this register is loaded into the TBR register on the next clock cycle.

When a 16/32-bit GPTM is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of the TAV register. Reads from this register return
the current free-running value of Timer B. In a 16-bit mode, bits 15:0 contain the value of the counter and bits 23:16 contain the current, free-running value of the prescaler, which is the upper 8 bits of
the count in Input Edge Count, Input Edge Time, PWM and one-shot or periodic up count modes.
In one-shot or periodic down count modes, the prescaler stored in 23:16 is a true prescaler, meaning bits 23:16 count down before decrementing the value in bits 15:0. The prescaler in bits 31:24 always reads as 0.</description>
          <fields>
            <field>
              <name>TBV</name>
              <description>[31:0] GPT Timer B Register
A read returns the current, free-running value of Timer B in all modes.
When written, the value written into this register is loaded into the
TBR register on the next clock cycle.
Note: In 16-bit mode, only the lower 16-bits of this
register can be written with a new value. Writes to the prescaler bits have no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAPS</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale Snap-shot 

Based on the value in the register field TAMR.TAILD, this register is updated with the value from TAPR register either on the next cycle or on the next timeout.


This register shows the current value of the Timer A pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[7:0] GPT Timer A Pre-scaler</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale Snap-shot 

Based on the value in the register field TBMR.TBILD, this register is updated with the value from TBPR register either on the next cycle or on the next timeout.

This register shows the current value of the Timer B pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[7:0] GPT Timer B Pre-scaler</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAPV</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale Value 
This register shows the current value of the Timer A free running pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[7:0] GPT Timer A Pre-scaler Value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPV</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale Value 
This register shows the current value of the Timer B free running pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[7:0] GPT Timer B Pre-scaler Value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMAEV</name>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <description>DMA Event 
This register allows software to enable/disable GPT DMA trigger events.</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Software should not rely on the value of a reserved field.  Writing any other value may result in undefined behavior.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMDMAEN</name>
              <description>[11:11] GPT Timer B Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEDMAEN</name>
              <description>[10:10] GPT Timer B Capture Event DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMDMAEN</name>
              <description>[9:9] GPT Timer B Capture Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTODMAEN</name>
              <description>[8:8] GPT Timer B Time-Out DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[7:5] Software should not rely on the value of a reserved field.  Writing any other value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMDMAEN</name>
              <description>[4:4] GPT Timer A Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEDMAEN</name>
              <description>[2:2] GPT Timer A Capture Event DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMDMAEN</name>
              <description>[1:1] GPT Timer A Capture Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATODMAEN</name>
              <description>[0:0] GPT Timer A Time-Out DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>VERSION</name>
          <addressOffset>0xfb0</addressOffset>
          <size>32</size>
          <description>Peripheral Version
This register provides information regarding the GPT version</description>
          <fields>
            <field>
              <name>VERSION</name>
              <description>[31:0] Timer Revision.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x400</resetValue>
        </register>
        <register>
          <name>ANDCCP</name>
          <addressOffset>0xfb4</addressOffset>
          <size>32</size>
          <description>Combined CCP Output
This register is used to logically AND CCP output pairs for each timer</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CCP_AND_EN</name>
              <description>[0:0] Enables AND operation of the CCP outputs for timers A and B.

0 : PWM outputs of Timer A and Timer B are the internal generated PWM signals of the respective timers.
1 : PWM output of Timer A is ANDed version of Timer A and Timer B PWM signals and Timer B PWM ouput is Timer B PWM signal only.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPT3</name>
      <baseAddress>0x40013000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>General Purpose Timer.</description>
      <registers>
        <register>
          <name>CFG</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Configuration</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CFG</name>
              <description>[2:0] GPT Configuration
0x2- 0x3 - Reserved
0x5- 0x7 - Reserved</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>16BIT_TIMER</name>
                  <value>4</value>
                  <description>16-bit timer configuration.  
Configure for two 16-bit timers.
Also see TAMR.TAMR and TBMR.TBMR.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>32BIT_TIMER</name>
                  <value>0</value>
                  <description>32-bit timer configuration</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAMR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Timer A Mode</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TCACT</name>
              <description>[15:13] Timer Compare Action Select</description>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLRSET_ON_TO</name>
                  <value>7</value>
                  <description>Clear CCP output pin immediately and set on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETCLR_ON_TO</name>
                  <value>6</value>
                  <description>Set CCP output pin immediately and clear on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLRTOG_ON_TO</name>
                  <value>5</value>
                  <description>Clear CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETTOG_ON_TO</name>
                  <value>4</value>
                  <description>Set CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET_ON_TO</name>
                  <value>3</value>
                  <description>Set CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR_ON_TO</name>
                  <value>2</value>
                  <description>Clear CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TOG_ON_TO</name>
                  <value>1</value>
                  <description>Toggle State on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS_CMP</name>
                  <value>0</value>
                  <description>Disable compare operations</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACINTD</name>
              <description>[12:12] One-Shot/Periodic Interrupt Disable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS_TO_INTR</name>
                  <value>1</value>
                  <description>Time-out interrupt are disabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_TO_INTR</name>
                  <value>0</value>
                  <description>Time-out interrupt function as normal</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAPLO</name>
              <description>[11:11] GPTM Timer A PWM Legacy Operation

0  Legacy operation with CCP pin driven Low when the TAILR 
register is reloaded after the timer reaches 0.

1 CCP is driven High when the TAILR  register is reloaded after the timer reaches 0.

This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CCP_ON_TO</name>
                  <value>1</value>
                  <description>CCP output pin is set to 1 on time-out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <value>0</value>
                  <description>Legacy operation</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMRSU</name>
              <description>[10:10] Timer A Match Register Update mode
 
This bit defines when the TAMATCHR and TAPR registers are updated.

If the timer is disabled (CTL.TAEN = 0) when this bit is set, TAMATCHR and TAPR are updated when the timer is enabled.
If the timer is stalled (CTL.TASTALL = 1) when this bit is set, TAMATCHR and TAPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update TAMATCHR and TAPR, if used, on the next time-out.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update TAMATCHR and TAPR, if used, on the next cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAPWMIE</name>
              <description>[9:9] GPTM Timer A PWM Interrupt Enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output, as defined by the CTL.TAEVENT
In addition, when this bit is set and a capture event occurs, Timer A
automatically generates triggers to the DMA if the trigger capability is enabled by setting the CTL.TAOTE bit and the DMAEV.CAEDMAEN bit respectively.

0 Capture event interrupt is disabled.
1 Capture event interrupt is enabled.
This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Interrupt is enabled.  This bit is only valid in PWM mode.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Interrupt is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAILD</name>
              <description>[8:8] GPT Timer A PWM Interval Load Write</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update the TAR register with the value in the TAILR register on the next timeout. If the prescaler is used, update the TAPS register with the value in the TAPR register on the next timeout.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update the TAR register with the value in the TAILR register on the next clock cycle. If the pre-scaler is used, update the TAPS register with the value in the TAPR register on the next clock cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TASNAPS</name>
              <description>[7:7] GPT Timer A Snap-Shot Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>If Timer A is configured in the periodic mode, the actual free-running value of Timer A is loaded at the time-out event into the GPT Timer A (TAR) register.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Snap-shot mode is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAWOT</name>
              <description>[6:6] GPT Timer A Wait-On-Trigger</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAIT</name>
                  <value>1</value>
                  <description>If Timer A is enabled (CTL.TAEN = 1), Timer A does not begin counting until it receives a trigger from the timer in the previous position in the daisy chain. This bit must be clear for GPT Module 0, Timer A. This function is valid for one-shot, periodic, and PWM modes</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOWAIT</name>
                  <value>0</value>
                  <description>Timer A begins counting as soon as it is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMIE</name>
              <description>[5:5] GPT Timer A Match Interrupt Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>An interrupt is generated when the match value in TAMATCHR is reached in the one-shot and periodic modes.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>The match interrupt is disabled for match events. Additionally, output triggers on match events are prevented.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACDIR</name>
              <description>[4:4] GPT Timer A Count Direction</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UP</name>
                  <value>1</value>
                  <description>The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DOWN</name>
                  <value>0</value>
                  <description>The timer counts down.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAAMS</name>
              <description>[3:3] GPT Timer A Alternate Mode 

Note: To enable PWM mode, you must also clear TACM and then configure TAMR field to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <value>1</value>
                  <description>PWM mode is enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAP_COMP</name>
                  <value>0</value>
                  <description>Capture/Compare mode is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TACM</name>
              <description>[2:2] GPT Timer A Capture Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EDGTIME</name>
                  <value>1</value>
                  <description>Edge-Time mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EDGCNT</name>
                  <value>0</value>
                  <description>Edge-Count mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMR</name>
              <description>[1:0] GPT Timer A Mode

0x0 Reserved
0x1 One-Shot Timer mode
0x2 Periodic Timer mode
0x3 Capture mode
The Timer mode is based on the timer configuration defined by bits 2:0 in the CFG register</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CAPTURE</name>
                  <value>3</value>
                  <description>Capture mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PERIODIC</name>
                  <value>2</value>
                  <description>Periodic Timer mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ONE_SHOT</name>
                  <value>1</value>
                  <description>One-Shot Timer mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBMR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Timer B Mode</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TCACT</name>
              <description>[15:13] Timer Compare Action Select</description>
              <bitWidth>3</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLRSET_ON_TO</name>
                  <value>7</value>
                  <description>Clear CCP output pin immediately and set on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETCLR_ON_TO</name>
                  <value>6</value>
                  <description>Set CCP output pin immediately and clear on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLRTOG_ON_TO</name>
                  <value>5</value>
                  <description>Clear CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SETTOG_ON_TO</name>
                  <value>4</value>
                  <description>Set CCP output pin immediately and toggle on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SET_ON_TO</name>
                  <value>3</value>
                  <description>Set CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLR_ON_TO</name>
                  <value>2</value>
                  <description>Clear CCP output pin on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TOG_ON_TO</name>
                  <value>1</value>
                  <description>Toggle State on Time-Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS_CMP</name>
                  <value>0</value>
                  <description>Disable compare operations</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBCINTD</name>
              <description>[12:12] One-Shot/Periodic Interrupt Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS_TO_INTR</name>
                  <value>1</value>
                  <description>Mask Time-Out Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EN_TO_INTR</name>
                  <value>0</value>
                  <description>Normal Time-Out Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBPLO</name>
              <description>[11:11] GPTM Timer B PWM Legacy Operation

0  Legacy operation with CCP pin driven Low when the TBILR 
register is reloaded after the timer reaches 0.

1 CCP is driven High when the TBILR  register is reloaded after the timer reaches 0.

This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CCP_ON_TO</name>
                  <value>1</value>
                  <description>CCP output pin is set to 1 on time-out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEGACY</name>
                  <value>0</value>
                  <description>Legacy operation</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBMRSU</name>
              <description>[10:10] Timer B Match Register Update mode
 
This bit defines when the TBMATCHR and TBPR registers are updated

If the timer is disabled (CTL.TBEN is clear) when this bit is set, TBMATCHR and TBPR are updated when the timer is enabled.
If the timer is stalled (CTL.TBSTALL is set) when this bit is set, TBMATCHR and TBPR are updated according to the configuration of this bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update TBMATCHR and TBPR, if used, on the next time-out.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update TBMATCHR and TBPR, if used, on the next cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBPWMIE</name>
              <description>[9:9] GPTM Timer B PWM Interrupt Enable
This bit enables interrupts in PWM mode on rising, falling, or both edges of the CCP output, as defined by the CTL.TBEVENT
In addition, when this bit is set and a capture event occurs, Timer A
automatically generates triggers to the DMA if the trigger capability is enabled by setting the CTL.TBOTE bit and the DMAEV.CBEDMAEN bit respectively.

0 Capture event interrupt is disabled.
1 Capture event interrupt is enabled.
This bit is only valid in PWM mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Interrupt is enabled.  This bit is only valid in PWM mode.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Interrupt is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBILD</name>
              <description>[8:8] GPT Timer B PWM Interval Load Write</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TOUPDATE</name>
                  <value>1</value>
                  <description>Update the TBR register with the value in the TBILR register on the next timeout. If the prescaler is used, update the TBPS register with the value in the TBPR register on the next timeout.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CYCLEUPDATE</name>
                  <value>0</value>
                  <description>Update the TBR register with the value in the TBILR register on the next clock cycle. If the pre-scaler is used, update the TBPS register with the value in the TBPR register on the next clock cycle.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBSNAPS</name>
              <description>[7:7] GPT Timer B Snap-Shot Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>If Timer B is configured in the periodic mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Snap-shot mode is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBWOT</name>
              <description>[6:6] GPT Timer B Wait-On-Trigger</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAIT</name>
                  <value>1</value>
                  <description>If Timer B is enabled (CTL.TBEN is set), Timer B does not begin counting until it receives a trigger from the timer in the previous position in the daisy chain. This function is valid for one-shot, periodic, and PWM modes</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOWAIT</name>
                  <value>0</value>
                  <description>Timer B begins counting as soon as it is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBMIE</name>
              <description>[5:5] GPT Timer B Match Interrupt Enable.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>An interrupt is generated when the match value in the TBMATCHR register is reached in the one-shot and periodic modes.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>The match interrupt is disabled for match events. Additionally, output triggers on match events are prevented.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBCDIR</name>
              <description>[4:4] GPT Timer B Count Direction</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UP</name>
                  <value>1</value>
                  <description>The timer counts up. When counting up, the timer starts from a value of 0x0.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DOWN</name>
                  <value>0</value>
                  <description>The timer counts down.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBAMS</name>
              <description>[3:3] GPT Timer B Alternate Mode 

Note: To enable PWM mode, you must also clear TBCM bit and configure TBMR field to 0x2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <value>1</value>
                  <description>PWM mode is enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CAP_COMP</name>
                  <value>0</value>
                  <description>Capture/Compare mode is enabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBCM</name>
              <description>[2:2] GPT Timer B Capture Mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EDGTIME</name>
                  <value>1</value>
                  <description>Edge-Time mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EDGCNT</name>
                  <value>0</value>
                  <description>Edge-Count mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBMR</name>
              <description>[1:0] GPT Timer B Mode

0x0 Reserved
0x1 One-Shot Timer mode
0x2 Periodic Timer mode
0x3 Capture mode
The Timer mode is based on the timer configuration defined by bits 2:0 in the CFG register</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CAPTURE</name>
                  <value>3</value>
                  <description>Capture mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PERIODIC</name>
                  <value>2</value>
                  <description>Periodic Timer mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ONE_SHOT</name>
                  <value>1</value>
                  <description>One-Shot Timer mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Control</description>
          <fields>
            <field>
              <name>RESERVED15</name>
              <description>[31:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>TBPWML</name>
              <description>[14:14] GPT Timer B PWM Output Level

0: Output is unaffected. 
1: Output is inverted.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVERTED</name>
                  <value>1</value>
                  <description>Inverted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Not inverted</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[13:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBEVENT</name>
              <description>[11:10] GPT Timer B Event Mode

The values in this register are defined as follows:
Value Description
0x0 Positive edge
0x1 Negative edge
0x2 Reserved
0x3 Both edges
Note: If PWM output inversion is enabled, edge detection interrupt
behavior is reversed. Thus, if a positive-edge interrupt trigger
has been set and the PWM inversion generates a postive
edge, no event-trigger interrupt asserts. Instead, the interrupt
is generated on the negative edge of the PWM signal.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Both edges</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>0</value>
                  <description>Positive edge</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBSTALL</name>
              <description>[9:9] GPT Timer B Stall Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer B freezes counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer B continues counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBEN</name>
              <description>[8:8] GPT Timer B Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer B is enabled and begins counting or the capture logic is enabled based on CFG register.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer B is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>[7:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TAPWML</name>
              <description>[6:6] GPT Timer A PWM Output Level</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>INVERTED</name>
                  <value>1</value>
                  <description>Inverted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Not inverted</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[5:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TAEVENT</name>
              <description>[3:2] GPT Timer A Event Mode

The values in this register are defined as follows:
Value Description
0x0 Positive edge
0x1 Negative edge
0x2 Reserved
0x3 Both edges
Note: If PWM output inversion is enabled, edge detection interrupt
behavior is reversed. Thus, if a positive-edge interrupt trigger
has been set and the PWM inversion generates a postive
edge, no event-trigger interrupt asserts. Instead, the interrupt
is generated on the negative edge of the PWM signal.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Both edges</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>0</value>
                  <description>Positive edge</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TASTALL</name>
              <description>[1:1] GPT Timer A Stall Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer A freezes counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer A continues counting while the processor is halted by the debugger.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAEN</name>
              <description>[0:0] GPT Timer A Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Timer A is enabled and begins counting or the capture logic is enabled based on the CFG register.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Timer A is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SYNC</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Synch Register</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SYNC3</name>
              <description>[7:6] Synchronize GPT Timer 3.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT3 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT3 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT3 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT3 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNC2</name>
              <description>[5:4] Synchronize GPT Timer 2.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT2 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT2 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT2 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT2 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNC1</name>
              <description>[3:2] Synchronize GPT Timer 1</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT1 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT1 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT1 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT1 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNC0</name>
              <description>[1:0] Synchronize GPT Timer 0</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>A timeout event for both Timer A and Timer B of GPT0 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERB</name>
                  <value>2</value>
                  <description>A timeout event for Timer B of GPT0 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TIMERA</name>
                  <value>1</value>
                  <description>A timeout event for Timer A of GPT0 is triggered</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NOSYNC</name>
                  <value>0</value>
                  <description>No Sync. GPT0 is not affected.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IMR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Interrupt Mask
This register is used to enable the interrupts.
Associated registers:
RIS, MIS, ICLR</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABIM</name>
              <description>[13:13] Enabling this bit will make the RIS.DMABRIS interrupt propagate to MIS.DMABMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMIM</name>
              <description>[11:11] Enabling this bit will make the RIS.TBMRIS interrupt propagate to MIS.TBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CBEIM</name>
              <description>[10:10] Enabling this bit will make the RIS.CBERIS interrupt propagate to MIS.CBEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CBMIM</name>
              <description>[9:9] Enabling this bit will make the RIS.CBMRIS interrupt propagate to MIS.CBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TBTOIM</name>
              <description>[8:8] Enabling this bit will make the RIS.TBTORIS interrupt propagate to MIS.TBTOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAAIM</name>
              <description>[5:5] Enabling this bit will make the RIS.DMAARIS interrupt propagate to MIS.DMAAMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TAMIM</name>
              <description>[4:4] Enabling this bit will make the RIS.TAMRIS interrupt propagate to MIS.TAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEIM</name>
              <description>[2:2] Enabling this bit will make the RIS.CAERIS interrupt propagate to MIS.CAEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CAMIM</name>
              <description>[1:1] Enabling this bit will make the RIS.CAMRIS interrupt propagate to MIS.CAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TATOIM</name>
              <description>[0:0] Enabling this bit will make the RIS.TATORIS interrupt propagate to MIS.TATOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Raw Interrupt Status
Associated registers:
IMR, MIS, ICLR</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABRIS</name>
              <description>[13:13] GPT Timer B DMA Done Raw Interrupt Status

0: Transfer has not completed
1: Transfer has completed</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMRIS</name>
              <description>[11:11] GPT Timer B Match Raw  Interrupt

0:  The match value has not been reached
1:  The match value is reached.

TBMR.TBMIE is set, and the match values in TBMATCHR and optionally TBPMR have been reached when configured in one-shot or periodic mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBERIS</name>
              <description>[10:10] GPT Timer B Capture Mode Event Raw Interrupt

0:  The event has not occured.
1:  The event has occured.

This interrupt asserts when the subtimer is configured in Input Edge-Time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMRIS</name>
              <description>[9:9] GPT Timer B Capture Mode Match Raw Interrupt

0:  The capture mode match for Timer B has not occurred.
1:  A capture mode match has occurred for Timer B. This interrupt
asserts when the values in the TBR and TBPR
match the values in the TBMATCHR and TBPMR
when configured in Input Edge-Time mode.

This bit is cleared by writing a 1 to the ICLR.CBMCINT bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTORIS</name>
              <description>[8:8] GPT Timer B Time-out Raw Interrupt

0:  Timer B has not timed out
1:  Timer B has timed out. 

This interrupt is asserted when a one-shot or periodic mode timer reaches its count limit. The count limit is 0 or the value loaded into TBILR, depending on the count direction.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAARIS</name>
              <description>[5:5] GPT Timer A DMA Done Raw Interrupt Status

0: Transfer has not completed
1: Transfer has completed</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMRIS</name>
              <description>[4:4] GPT Timer A Match Raw  Interrupt

0:  The match value has not been reached
1:  The match value is reached.

TAMR.TAMIE is set, and the match values in TAMATCHR and optionally TAPMR have been reached when configured in one-shot or periodic mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAERIS</name>
              <description>[2:2] GPT Timer A Capture Mode Event Raw Interrupt

0:  The event has not occured.
1:  The event has occured.

This interrupt asserts when the subtimer is configured in Input Edge-Time mode</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMRIS</name>
              <description>[1:1] GPT Timer A Capture Mode Match Raw Interrupt

0:  The capture mode match for Timer A has not occurred.
1:  A capture mode match has occurred for Timer A. This interrupt
asserts when the values in the TAR and TAPR
match the values in the TAMATCHR and TAPMR
when configured in Input Edge-Time mode.

This bit is cleared by writing a 1 to the ICLR.CAMCINT bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATORIS</name>
              <description>[0:0] GPT Timer A Time-out Raw Interrupt

0:  Timer A has not timed out
1:  Timer A has timed out. 

This interrupt is asserted when a one-shot or periodic mode timer reaches its count limit. The count limit is 0 or the value loaded into TAILR, depending on the count direction.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Masked Interrupt Status
Values are result of bitwise AND operation between RIS and IMR
Assosciated clear register: ICLR</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABMIS</name>
              <description>[13:13] 0: No interrupt or interrupt not enabled
1: RIS.DMABRIS = 1 &amp;&amp; IMR.DMABIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMMIS</name>
              <description>[11:11] 0: No interrupt or interrupt not enabled
1: RIS.TBMRIS = 1 &amp;&amp; IMR.TBMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEMIS</name>
              <description>[10:10] 0: No interrupt or interrupt not enabled
1: RIS.CBERIS = 1 &amp;&amp; IMR.CBEIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMMIS</name>
              <description>[9:9] 0: No interrupt or interrupt not enabled
1: RIS.CBMRIS = 1 &amp;&amp; IMR.CBMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOMIS</name>
              <description>[8:8] 0: No interrupt or interrupt not enabled
1: RIS.TBTORIS = 1 &amp;&amp; IMR.TBTOIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAAMIS</name>
              <description>[5:5] 0: No interrupt or interrupt not enabled
1: RIS.DMAARIS = 1 &amp;&amp; IMR.DMAAIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMMIS</name>
              <description>[4:4] 0: No interrupt or interrupt not enabled
1: RIS.TAMRIS = 1 &amp;&amp; IMR.TAMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEMIS</name>
              <description>[2:2] 0: No interrupt or interrupt not enabled
1: RIS.CAERIS = 1 &amp;&amp; IMR.CAEIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMMIS</name>
              <description>[1:1] 0: No interrupt or interrupt not enabled
1: RIS.CAMRIS = 1 &amp;&amp; IMR.CAMIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOMIS</name>
              <description>[0:0] 0: No interrupt or interrupt not enabled
1: RIS.TATORIS = 1 &amp;&amp; IMR.TATOIM = 1</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ICLR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Interrupt Clear
This register is used to clear status bits in the RIS and MIS registers</description>
          <fields>
            <field>
              <name>RESERVED14</name>
              <description>[31:14] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>18</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>DMABINT</name>
              <description>[13:13] 0: Do nothing.
1: Clear RIS.DMABRIS and MIS.DMABMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[12:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMCINT</name>
              <description>[11:11] 0: Do nothing.
1: Clear RIS.TBMRIS and MIS.TBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBECINT</name>
              <description>[10:10] 0: Do nothing.
1: Clear RIS.CBERIS and MIS.CBEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMCINT</name>
              <description>[9:9] 0: Do nothing.
1: Clear RIS.CBMRIS and MIS.CBMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTOCINT</name>
              <description>[8:8] 0: Do nothing.
1: Clear RIS.TBTORIS and MIS.TBTOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DMAAINT</name>
              <description>[5:5] 0: Do nothing.
1: Clear RIS.DMAARIS and MIS.DMAAMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMCINT</name>
              <description>[4:4] 0: Do nothing.
1: Clear RIS.TAMRIS and MIS.TAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAECINT</name>
              <description>[2:2] 0: Do nothing.
1: Clear RIS.CAERIS and MIS.CAEMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMCINT</name>
              <description>[1:1] 0: Do nothing.
1: Clear RIS.CAMRIS and MIS.CAMMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATOCINT</name>
              <description>[0:0] 0: Do nothing.
1: Clear RIS.TATORIS and MIS.TATOMIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAILR</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Timer A Interval Load  Register</description>
          <fields>
            <field>
              <name>TAILR</name>
              <description>[31:0] GPT Timer A Interval Load  Register

Writing this field loads the counter for Timer A. A read returns the current value of TAILR.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBILR</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Timer B Interval Load  Register</description>
          <fields>
            <field>
              <name>TBILR</name>
              <description>[31:0] GPT Timer B Interval Load  Register

Writing this field loads the counter for Timer B. A read returns the current value of TBILR.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAMATCHR</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Timer A Match Register

Interrupts can be generated when the timer value is equal to the value in this register in one-shot or periodic mode.

In Edge-Count mode, this register along with TAILR, determines how many edge events are counted.
The total number of edge events counted is equal to the value in TAILR minus this value.

Note that in edge-count mode, when executing an up-count, the value of TAPR and TAILR must be greater than the value of TAPMR and this register.

In PWM mode, this value along with TAILR, determines the duty cycle of the output PWM signal.

When a 16/32-bit GPT is configured to one of the 32-bit modes, TAMATCHR appears as a 32-bit register. (The upper 16-bits correspond to the contents TBMATCHR).

In a 16-bit mode, the upper 16 bits of this register read as 0s and have no effect on the state of TBMATCHR.

Note : This register is updated internally (takes effect) based on TAMR.TAMRSU</description>
          <fields>
            <field>
              <name>TAMATCHR</name>
              <description>[31:0] GPT Timer A Match Register</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBMATCHR</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Timer B Match Register

 When a GPT is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of  TAMATCHR.
Reads from this register return the current match value of Timer B and writes are ignored.
In a 16-bit mode, bits 15:0 are used for the match value. Bits 31:16 are reserved in both cases.

Note : This register is updated internally (takes effect) based on TBMR.TBMRSU</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>TBMATCHR</name>
              <description>[15:0] GPT Timer B Match Register</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAPR</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale
This register allows software to extend the range of the timers when they are used individually.
When in one-shot or periodic down count modes, this register acts as a true prescaler for the timer counter.
When acting as a true prescaler, the prescaler counts down to 0 before the value in TAR and TAV registers are incremented.
In all other individual/split modes, this register is a linear extension of the upper range of the timer counter, holding bits 23:16 in the 16-bit modes of the 16/32-bit GPT.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSR</name>
              <description>[7:0] Timer A Pre-scale.

Prescaler ratio in one-shot and periodic count mode is TAPSR + 1, that is:

0: Prescaler ratio = 1
1: Prescaler ratio = 2
2: Prescaler ratio = 3
...
255: Prescaler ratio = 256</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPR</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale
This register allows software to extend the range of the timers when they are used individually.
When in one-shot or periodic down count modes, this register acts as a true prescaler for the timer counter.
When acting as a true prescaler, the prescaler counts down to 0 before the value in TBR and TBV registers are incremented.
In all other individual/split modes, this register is a linear extension of the upper range of the timer counter, holding bits 23:16 in the 16-bit modes of the 16/32-bit GPT.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSR</name>
              <description>[7:0] Timer B Pre-scale.

Prescale ratio in one-shot and periodic count mode is TBPSR + 1, that is:

0: Prescaler ratio = 1
1: Prescaler ratio = 2
2: Prescaler ratio = 3
...
255: Prescaler ratio = 256</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAPMR</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale Match
This register allows software to extend the range of the TAMATCHR when used individually.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TAPSMR</name>
              <description>[7:0] GPT Timer A Pre-scale Match.  In 16 bit mode this field holds bits 23 to 16.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPMR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale Match
This register allows software to extend the range of the TBMATCHR when used individually.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TBPSMR</name>
              <description>[7:0] GPT Timer B Pre-scale Match Register.  In 16 bit mode this field holds bits 23 to 16.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Timer A Register
This register shows the current value of the Timer A counter in all cases except for Input Edge Count and Time modes. In the Input Edge Count mode, this register contains the number of edges that
have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.

When a GPT is configured to one of the 32-bit modes, this register appears as a 32-bit register (the upper 16-bits correspond to the contents of the Timer B (TBR) register). In
the16-bit Input Edge Count, Input Edge Time, and PWM modes, bits 15:0 contain the value of the counter and bits 23:16 contain the value of the prescaler, which is the upper 8 bits of the count. Bits
31:24 always read as 0. To read the value of the prescaler in 16-bit One-Shot and Periodic modes, read bits [23:16] in the TAV register. To read the value of the prescalar in periodic snapshot
mode, read the Timer A Prescale Snapshot (TAPS) register.</description>
          <fields>
            <field>
              <name>TAR</name>
              <description>[31:0] GPT Timer A Register    

Based on the value in the register field TAMR.TAILD, this register is updated with the value from TAILR register either on the next cycle or on the next timeout.

A read returns the current value of the Timer A Count Register, in all cases except for Input Edge count and Timer modes. 
In the Input Edge Count Mode, this register contains the number of edges that have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBR</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Timer B Register
This register shows the current value of the Timer B counter in all cases except for Input Edge Count and Time modes. In the Input Edge Count mode, this register contains the number of edges that
have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.

When a GPTM is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of the TAR register. Reads from this register return the current
value of Timer B. In a 16-bit mode, bits 15:0 contain the value of the counter and bits 23:16 contain the value of the prescaler in Input Edge Count, Input Edge Time, and PWM modes, which is the
upper 8 bits of the count. Bits 31:24 always read as 0. To read the value of the prescaler in 16-bit One-Shot and Periodic modes, read bits [23:16] in the TBV register. To read the value of the
prescalar in periodic snapshot mode, read the Timer B Prescale Snapshot (TBPS) register.</description>
          <fields>
            <field>
              <name>TBR</name>
              <description>[31:0] GPT Timer B Register

Based on the value in the register field TBMR.TBILD, this register is updated with the value from TBILR register either on the next cycle or on the next timeout.

A read returns the current value of the Timer B Count Register, in all cases except for Input Edge count and Timer modes. 
In the Input Edge Count Mode, this register contains the number of edges that have occurred. In the Input Edge Time mode, this register contains the time at which the last edge event took place.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAV</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>Timer A Value 
When read, this register shows the current, free-running value of Timer A in all modes. Softwarecan use this value to determine the time elapsed between an interrupt and the ISR entry when using
the snapshot feature with the periodic operating mode. When written, the value written into this register is loaded into the TAR register on the next clock cycle.

When a 16/32-bit GPTM is configured to one of the 32-bit modes, this register appears as a 32-bit register (the upper 16-bits correspond to the contents of the GPTM Timer B Value (TBV) register). In a 16-bit mode, bits 15:0 contain the value of the counter and bits 23:16 contain the current, free-running value of the prescaler, which is the upper 8 bits of the count in Input Edge Count, Input Edge Time, PWM and one-shot or periodic up count modes. In one-shot or periodic
down count modes, the prescaler stored in 23:16 is a true prescaler, meaning bits 23:16 count down before decrementing the value in bits 15:0. The prescaler in bits 31:24 always reads as 0.</description>
          <fields>
            <field>
              <name>TAV</name>
              <description>[31:0] GPT Timer A Register
A read returns the current, free-running value of Timer A in all modes.
When written, the value written into this register is loaded into the
TAR register on the next clock cycle.
Note: In 16-bit mode, only the lower 16-bits of this
register can be written with a new value. Writes to the prescaler bits have no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>TBV</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Timer B Value 
When read, this register shows the current, free-running value of Timer B in all modes. Software can use this value to determine the time elapsed between an interrupt and the ISR entry. When
written, the value written into this register is loaded into the TBR register on the next clock cycle.

When a 16/32-bit GPTM is configured to one of the 32-bit modes, the contents of bits 15:0 in this register are loaded into the upper 16 bits of the TAV register. Reads from this register return
the current free-running value of Timer B. In a 16-bit mode, bits 15:0 contain the value of the counter and bits 23:16 contain the current, free-running value of the prescaler, which is the upper 8 bits of
the count in Input Edge Count, Input Edge Time, PWM and one-shot or periodic up count modes.
In one-shot or periodic down count modes, the prescaler stored in 23:16 is a true prescaler, meaning bits 23:16 count down before decrementing the value in bits 15:0. The prescaler in bits 31:24 always reads as 0.</description>
          <fields>
            <field>
              <name>TBV</name>
              <description>[31:0] GPT Timer B Register
A read returns the current, free-running value of Timer B in all modes.
When written, the value written into this register is loaded into the
TBR register on the next clock cycle.
Note: In 16-bit mode, only the lower 16-bits of this
register can be written with a new value. Writes to the prescaler bits have no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>TAPS</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale Snap-shot 

Based on the value in the register field TAMR.TAILD, this register is updated with the value from TAPR register either on the next cycle or on the next timeout.


This register shows the current value of the Timer A pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[7:0] GPT Timer A Pre-scaler</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPS</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale Snap-shot 

Based on the value in the register field TBMR.TBILD, this register is updated with the value from TBPR register either on the next cycle or on the next timeout.

This register shows the current value of the Timer B pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSS</name>
              <description>[7:0] GPT Timer B Pre-scaler</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TAPV</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>Timer A Pre-scale Value 
This register shows the current value of the Timer A free running pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[7:0] GPT Timer A Pre-scaler Value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TBPV</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>Timer B Pre-scale Value 
This register shows the current value of the Timer B free running pre-scaler in the 16-bit mode.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PSV</name>
              <description>[7:0] GPT Timer B Pre-scaler Value</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMAEV</name>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <description>DMA Event 
This register allows software to enable/disable GPT DMA trigger events.</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Software should not rely on the value of a reserved field.  Writing any other value may result in undefined behavior.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TBMDMAEN</name>
              <description>[11:11] GPT Timer B Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>CBEDMAEN</name>
              <description>[10:10] GPT Timer B Capture Event DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>CBMDMAEN</name>
              <description>[9:9] GPT Timer B Capture Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TBTODMAEN</name>
              <description>[8:8] GPT Timer B Time-Out DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED5</name>
              <description>[7:5] Software should not rely on the value of a reserved field.  Writing any other value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TAMDMAEN</name>
              <description>[4:4] GPT Timer A Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[3:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CAEDMAEN</name>
              <description>[2:2] GPT Timer A Capture Event DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAMDMAEN</name>
              <description>[1:1] GPT Timer A Capture Match DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TATODMAEN</name>
              <description>[0:0] GPT Timer A Time-Out DMA Trigger Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>VERSION</name>
          <addressOffset>0xfb0</addressOffset>
          <size>32</size>
          <description>Peripheral Version
This register provides information regarding the GPT version</description>
          <fields>
            <field>
              <name>VERSION</name>
              <description>[31:0] Timer Revision.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x400</resetValue>
        </register>
        <register>
          <name>ANDCCP</name>
          <addressOffset>0xfb4</addressOffset>
          <size>32</size>
          <description>Combined CCP Output
This register is used to logically AND CCP output pairs for each timer</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CCP_AND_EN</name>
              <description>[0:0] Enables AND operation of the CCP outputs for timers A and B.

0 : PWM outputs of Timer A and Timer B are the internal generated PWM signals of the respective timers.
1 : PWM output of Timer A is ANDed version of Timer A and Timer B PWM signals and Timer B PWM ouput is Timer B PWM signal only.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <baseAddress>0x40002000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>I2CMaster/Slave Serial Controler</description>
      <registers>
        <register>
          <name>SOAR</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Slave Own Address
This register consists of seven address bits that identify this I2C device on the I2C bus.</description>
          <fields>
            <field>
              <name>RESERVED7</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>OAR</name>
              <description>[6:0] I2C slave own address
This field specifies bits a6 through a0 of the slave address.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SSTAT</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Slave Status 
Note: This register shares address with SCTL, meaning that this register functions as a control register when written, and a status register when read.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>FBR</name>
              <description>[2:2] First byte received

0: The first byte has not been received.
1: The first byte following the slave's own address has been received.

This bit is only valid when the RREQ bit is set and is automatically cleared when data has been read from the SDR register.
Note: This bit is not used for slave transmit operations.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TREQ</name>
              <description>[1:1] Transmit request

0: No outstanding transmit request.
1: The I2C controller has been addressed as a slave transmitter and is using clock stretching to delay the master until data has been written to the SDR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RREQ</name>
              <description>[0:0] Receive request

0: No outstanding receive data
1: The I2C controller has outstanding receive data from the I2C master and is using clock stretching to delay the master until data has been read from the SDR register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SCTL</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Slave Control
Note: This register shares address with SSTAT, meaning that this register functions as a control register when written, and a status register when read.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved field.  Writing any other value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DA</name>
              <description>[0:0] Device active

0: Disables the I2C slave operation
1: Enables the I2C slave operation</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SDR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Slave Data
This register contains the data to be transmitted when in the Slave Transmit state, and the data received when in the Slave Receive state.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] Data for transfer
This field contains the data for transfer during a slave receive or transmit operation.  When written the register data is used as transmit data.  When read, this register returns the last data received.
Data is stored until next update, either by a system write for transmit or by an external master for receive.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SIMR</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Slave Interrupt Mask
This register controls whether a raw interrupt is promoted to a controller interrupt.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>STOPIM</name>
              <description>[2:2] Stop condition interrupt mask

0: The SRIS.STOPRIS interrupt is suppressed and not sent to the interrupt controller.
1: The SRIS.STOPRIS interrupt is enabled and sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STARTIM</name>
              <description>[1:1] Start condition interrupt mask

0: The SRIS.STARTRIS interrupt is suppressed and not sent to the interrupt controller.
1: The SRIS.STARTRIS interrupt is enabled and sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DATAIM</name>
              <description>[0:0] Data interrupt mask

0: The SRIS.DATARIS interrupt is suppressed and not sent to the interrupt controller.
1: The SRIS.DATARIS interrupt is enabled and sent to the interrupt controller.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SRIS</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Slave Raw Interrupt Status
This register shows the unmasked interrupt status.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>STOPRIS</name>
              <description>[2:2] Stop condition raw interrupt status

0: No interrupt
1: A Stop condition interrupt is pending.

This bit is cleared by writing a 1 to SICR.STOPIC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>STARTRIS</name>
              <description>[1:1] Start condition raw interrupt status

0: No interrupt
1: A Start condition interrupt is pending.

This bit is cleared by writing a 1 to SICR.STARTIC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DATARIS</name>
              <description>[0:0] Data raw interrupt status

0: No interrupt
1: A data received or data requested interrupt is pending.

This bit is cleared by writing a 1 to the SICR.DATAIC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SMIS</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Slave Masked Interrupt Status
This register show which interrupt is active (based on result from SRIS and SIMR).</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>STOPMIS</name>
              <description>[2:2] Stop condition masked interrupt status

0: An interrupt has not occurred or is masked/disabled.
1: An unmasked Stop condition interrupt is pending.

This bit is cleared by writing a 1 to the SICR.STOPIC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>STARTMIS</name>
              <description>[1:1] Start condition masked interrupt status

0: An interrupt has not occurred or is masked/disabled.
1: An unmasked Start condition interrupt is pending.

This bit is cleared by writing a 1 to the SICR.STARTIC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DATAMIS</name>
              <description>[0:0] Data masked interrupt status

0: An interrupt has not occurred or is masked/disabled.
1: An unmasked data received or data requested interrupt is pending.

This bit is cleared by writing a 1 to the SICR.DATAIC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SICR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Slave Interrupt Clear
This register clears the raw interrupt SRIS.</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>STOPIC</name>
              <description>[2:2] Stop condition interrupt clear

Writing 1 to this bit clears SRIS.STOPRIS and SMIS.STOPMIS.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>STARTIC</name>
              <description>[1:1] Start condition interrupt clear

Writing 1 to this bit clears SRIS.STARTRIS SMIS.STARTMIS.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>DATAIC</name>
              <description>[0:0] Data interrupt clear

Writing 1 to this bit clears SRIS.DATARIS SMIS.DATAMIS.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MSA</name>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <description>Master Salve Address
This register contains seven address bits of the slave to be accessed by the master (a6-a0), and an RS bit determining if the next operation is a receive or transmit.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SA</name>
              <description>[7:1] I2C master slave address
Defines which slave is addressed for the transaction in master mode</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RS</name>
              <description>[0:0] Receive or Send
This bit-field specifies if the next operation is a receive (high) or a transmit/send (low) from the addressed slave SA.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RX</name>
                  <value>1</value>
                  <description>Receive data from slave</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TX</name>
                  <value>0</value>
                  <description>Transmit/send data to slave</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MSTAT</name>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <description>Master Status</description>
          <fields>
            <field>
              <name>RESERVED7</name>
              <description>[31:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>25</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>BUSBSY</name>
              <description>[6:6] Bus busy

0: The I2C bus is idle.
1: The I2C bus is busy.

The bit changes based on the MCTRL.START and MCTRL.STOP conditions.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>IDLE</name>
              <description>[5:5] I2C idle

0: The I2C controller is not idle.
1: The I2C controller is idle.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>ARBLST</name>
              <description>[4:4] Arbitration lost

0: The I2C controller won arbitration.
1: The I2C controller lost arbitration.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>DATACK_N</name>
              <description>[3:3] Data Was Not Acknowledge

0: The transmitted data was acknowledged.
1: The transmitted data was not acknowledged.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>ADRACK_N</name>
              <description>[2:2] Address Was Not Acknowledge

0: The transmitted address was acknowledged.
1: The transmitted address was not acknowledged.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>ERR</name>
              <description>[1:1] Error

0: No error was detected on the last operation.
1: An error occurred on the last operation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>BUSY</name>
              <description>[0:0] I2C busy

0: The controller is idle.
1: The controller is busy.

When this bit-field is set, the other status bits are not valid.

Note: The I2C controller requires four SYSBUS clock cycles to assert the BUSY status after I2C master operation has been initiated through MCTRL register. 
Hence after programming MCTRL register, application is requested to wait for four SYSBUS clock cycles before issuing a controller status inquiry through MSTAT register.
Any prior inquiry would result in wrong status being reported.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x20</resetValue>
        </register>
        <register>
          <name>MCTRL</name>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <description>Master Control

This register accesses status bits when read and control bits when written. When read, the status register indicates the state of the I2C bus controller as stated in MSTAT. When written, the control register configures the I2C controller operation.

To generate a single transmit cycle, the I2C Master Slave Address (MSA) register is written with the desired address, the MSA.RS bit is cleared, and this register is written with 
* ACK=X (0 or 1), 
* STOP=1, 
* START=1, 
* RUN=1 
to perform the operation and stop. 
When the operation is completed (or aborted due an error), an interrupt becomes active and the data may be read from the MDR register.</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>ACK</name>
              <description>[3:3] Data acknowledge enable

0: The received data byte is not acknowledged automatically by the master.
1: The received data byte is acknowledged automatically by the master.

This bit-field must be cleared when the I2C bus controller requires no further data to be transmitted from the slave transmitter.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable acknowledge</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable acknowledge</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STOP</name>
              <description>[2:2] This bit-field determines if the cycle stops at the end of the data cycle or continues on to a repeated START condition.

0: The controller does not generate the Stop condition.
1: The controller generates the Stop condition.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable STOP</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable STOP</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>START</name>
              <description>[1:1] This bit-field generates the Start or Repeated Start condition. 

0: The controller does not generate the Start condition.
1: The controller generates the Start condition.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable START</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable START</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RUN</name>
              <description>[0:0] I2C master enable

0: The master is disabled.
1: The master is enabled to transmit or receive data.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Master</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Master</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MDR</name>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <description>Master Data
This register contains the data to be transmitted when in the Master Transmit state and the data received when in the Master Receive state.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] When Read: Last RX Data is returned
When Written: Data is transferred during TX  transaction</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MTPR</name>
          <addressOffset>0x80c</addressOffset>
          <size>32</size>
          <description>I2C Master Timer Period
This register specifies the period of the SCL clock.</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TPR_7</name>
              <description>[7:7] Must be set to 0 to set TPR. If set to 1, a write to TPR will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TPR</name>
              <description>[6:0] SCL clock period
This field specifies the period of the SCL clock.
SCL_PRD = 2*(1+TPR)*(SCL_LP + SCL_HP)*CLK_PRD
where:
SCL_PRD is the SCL line period (I2C clock).
TPR is the timer period register value (range of 1 to 127)
SCL_LP is the SCL low period (fixed at 6).
SCL_HP is the SCL high period (fixed at 4).
CLK_PRD is the system clock period in ns.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>MIMR</name>
          <addressOffset>0x810</addressOffset>
          <size>32</size>
          <description>Master Interrupt Mask
This register controls whether a raw interrupt is promoted to a controller interrupt.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>IM</name>
              <description>[0:0] Interrupt mask

0: The MRIS.RIS interrupt is suppressed and not sent to the interrupt controller.
1: The master interrupt is sent to the interrupt controller when the MRIS.RIS is set.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MRIS</name>
          <addressOffset>0x814</addressOffset>
          <size>32</size>
          <description>Master Raw Interrupt Status
This register show the unmasked interrupt status.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RIS</name>
              <description>[0:0] Raw interrupt status

0: No interrupt
1: A master interrupt is pending.

This bit is cleared by writing 1 to the MICR.IC bit .</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MMIS</name>
          <addressOffset>0x818</addressOffset>
          <size>32</size>
          <description>Master Masked Interrupt Status
This register show which interrupt is active (based on result from MRIS and MIMR).</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MIS</name>
              <description>[0:0] Masked interrupt status

0: An interrupt has not occurred or is masked.
1: A master interrupt is pending.

This bit is cleared by writing 1 to the MICR.IC bit .</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MICR</name>
          <addressOffset>0x81c</addressOffset>
          <size>32</size>
          <description>Master Interrupt Clear
This register clears the raw and masked interrupt.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>IC</name>
              <description>[0:0] Interrupt clear
Writing 1 to this bit clears MRIS.RIS and  MMIS.MIS .

Reading this register returns no meaningful data.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MCR</name>
          <addressOffset>0x820</addressOffset>
          <size>32</size>
          <description>Master Configuration
This register configures the mode (Master or Slave) and sets the interface for test mode loopback.</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>SFE</name>
              <description>[5:5] I2C slave function enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Slave mode is enabled.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Slave mode is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MFE</name>
              <description>[4:4] I2C master function enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Master mode is enabled.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Master mode is disabled.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[3:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LPBK</name>
              <description>[0:0] I2C loopback

0: Normal operation
1: Loopback operation (test mode)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable Test Mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable Test Mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S0</name>
      <baseAddress>0x40021000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>I2S Audio DMA module supporting formats I2S, LJF, RJF and DSP</description>
      <registers>
        <register>
          <name>AIFWCLKSRC</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>WCLK Source Selection</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>WCLK_INV</name>
              <description>[2:2] Inverts WCLK source (pad or internal) when set.

0: Not inverted
1: Inverted</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>WCLK_SRC</name>
              <description>[1:0] Selects WCLK source for AIF (should be the same as the BCLK source). The BCLK source is defined in the PRCM:I2SBCLKSEL.SRC</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESERVED</name>
                  <value>3</value>
                  <description>Not supported. Will give same WCLK as 'NONE' ('00')</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INT</name>
                  <value>2</value>
                  <description>Internal WCLK generator, from module PRCM</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXT</name>
                  <value>1</value>
                  <description>External WCLK generator, from pad</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>None ('0')</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AIFDMACFG</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>DMA Buffer Size Configuration</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>END_FRAME_IDX</name>
              <description>[7:0] Defines the length of the DMA buffer. Writing a non-zero value to this register field enables and initializes AIF. Note that before doing so, all other configuration must have been done, and AIFINPTRNEXT/AIFOUTPTRNEXT must have been loaded.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AIFDIRCFG</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Pin Direction</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>AD1</name>
              <description>[5:4] Configures the AD1 audio data pin usage:

0x3: Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>2</value>
                  <description>Output mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Not in use (disabled)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[3:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>AD0</name>
              <description>[1:0] Configures the AD0 audio data pin usage:

0x3: Reserved</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OUT</name>
                  <value>2</value>
                  <description>Output mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IN</name>
                  <value>1</value>
                  <description>Input mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Not in use (disabled)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AIFFMTCFG</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Serial Interface Format Configuration</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DATA_DELAY</name>
              <description>[15:8] The number of BCLK periods between a WCLK edge and MSB of the first word in a phase:

0x00: LJF and DSP format
0x01: I2S and DSP format
0x02: RJF format
...
0xFF: RJF format

Note: When 0, MSB of the next word will be output in the idle period between LSB of the previous word and the start of the next word. Otherwise logical 0 will be output until the data delay has expired.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MEM_LEN_24</name>
              <description>[7:7] The size of each word stored to or loaded from memory:</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>24BIT</name>
                  <value>1</value>
                  <description>24-bit (one 8 bit and one 16 bit locked access per sample)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>16BIT</name>
                  <value>0</value>
                  <description>16-bit (one 16 bit access per sample)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SMPL_EDGE</name>
              <description>[6:6] On the serial audio interface, data (and wclk) is sampled and clocked out on opposite edges of BCLK.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POS</name>
                  <value>1</value>
                  <description>Data is sampled on the positive edge and clocked out on the negative edge.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>0</value>
                  <description>Data is sampled on the negative edge and clocked out on the positive edge.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DUAL_PHASE</name>
              <description>[5:5] Selects dual- or single-phase format.

0: Single-phase: DSP format
1: Dual-phase: I2S, LJF and RJF formats</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>WORD_LEN</name>
              <description>[4:0] Number of bits per word (8-24):
In single-phase format, this is the exact number of bits per word. 
In dual-phase format, this is the maximum number of bits per word.

Values below 8 and above 24 give undefined behavior. Data written to memory is always aligned to 16 or 24 bits as defined by MEM_LEN_24. Bit widths that differ from this alignment will either be truncated or zero padded.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x170</resetValue>
        </register>
        <register>
          <name>AIFWMASK0</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Word Selection Bit Mask for Pin 0</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MASK</name>
              <description>[7:0] Bit-mask indicating valid channels in a frame on AD0.

In single-phase mode, each bit represents one channel, starting with LSB for the first word in the frame. A frame can contain up to 8 channels.  Channels that are not included in the mask will not be sampled and stored in memory, and clocked out as '0'.

In dual-phase mode, only the two LSBs are considered. For a stereo configuration, set both bits. For a mono configuration, set bit 0 only. In mono mode, only channel 0 will be sampled and stored to memory, and channel 0 will be repeated when clocked out.

In mono mode, only channel 0 will be sampled and stored to memory, and channel 0 will be repeated in the second phase when clocked out.

If all bits are zero, no input words will be stored to memory, and the output data lines will be constant '0'. This can be utilized when PWM debug output is desired without any actively used output pins.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3</resetValue>
        </register>
        <register>
          <name>AIFWMASK1</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Word Selection Bit Mask for Pin 1</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MASK</name>
              <description>[7:0] Bit-mask indicating valid channels in a frame on AD1.

In single-phase mode, each bit represents one channel, starting with LSB for the first word in the frame. A frame can contain up to 8 channels.  Channels that are not included in the mask will not be sampled and stored in memory, and clocked out as '0'.

In dual-phase mode, only the two LSBs are considered. For a stereo configuration, set both bits. For a mono configuration, set bit 0 only. In mono mode, only channel 0 will be sampled and stored to memory, and channel 0 will be repeated when clocked out.

In mono mode, only channel 0 will be sampled and stored to memory, and channel 0 will be repeated in the second phase when clocked out.

If all bits are zero, no input words will be stored to memory, and the output data lines will be constant '0'. This can be utilized when PWM debug output is desired without any actively used output pins.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3</resetValue>
        </register>
        <register>
          <name>AIFWMASK2</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED0</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AIFPWMVALUE</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Audio Interface PWM Debug Value</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>PULSE_WIDTH</name>
              <description>[15:0] The value written to this register determines the width of the active high PWM pulse (pwm_debug), which starts together with MSB of the first output word in a DMA buffer:

0x0000: Constant low
0x0001: Width of the pulse (number of BCLK cycles, here 1).
...
0xFFFE: Width of the pulse (number of BCLK cycles, here 65534).
0xFFFF: Constant high</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AIFINPTRNEXT</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>DMA Input Buffer Next Pointer</description>
          <fields>
            <field>
              <name>PTR</name>
              <description>[31:0] Pointer to the first byte in the next DMA input buffer.

The read value equals the last written value until the currently used DMA input buffer is completed, and then becomes null when the last written value is transferred to the DMA controller to start on the next buffer. This event is signalized by IRQFLAGS.AIF_DMA_IN. 

At startup, the value must be written once before and once after configuring the DMA buffer size in AIFDMACFG.

The next pointer must be written to this register while the DMA function uses the previously written pointer. If not written in time, IRQFLAGS.PTR_ERR will be raised and all input pins will be disabled.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AIFINPTR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>DMA Input Buffer Current Pointer</description>
          <fields>
            <field>
              <name>PTR</name>
              <description>[31:0] Value of the DMA input buffer pointer currently used by the DMA controller. Incremented by 1 (byte) or 2 (word) for each AHB access.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AIFOUTPTRNEXT</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>DMA Output Buffer Next Pointer</description>
          <fields>
            <field>
              <name>PTR</name>
              <description>[31:0] Pointer to the first byte in the next DMA output buffer.

The read value equals the last written value until the currently used DMA output buffer is completed, and then becomes null when the last written value is transferred to the DMA controller to start on the next buffer. This event is signalized by IRQFLAGS.AIF_DMA_OUT. 

At startup, the value must be written once before and once after configuring the DMA buffer size in AIFDMACFG. At this time, the first two samples will be fetched from memory.

The next pointer must be written to this register while the DMA function uses the previously written pointer. If not written in time, IRQFLAGS.PTR_ERR will be raised and all output pins will be disabled.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>AIFOUTPTR</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>DMA Output Buffer Current Pointer</description>
          <fields>
            <field>
              <name>PTR</name>
              <description>[31:0] Value of the DMA output buffer pointer currently used by the DMA controller Incremented by 1 (byte) or 2 (word) for each AHB access.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPCTL</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Samplestamp Generator Control Register</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>OUT_RDY</name>
              <description>[2:2] Low until the output pins are ready to be started by the samplestamp generator. When started (that is STMPOUTTRIG equals the WCLK counter) the bit goes back low.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>IN_RDY</name>
              <description>[1:1] Low until the input pins are ready to be started by the samplestamp generator. When started (that is STMPINTRIG equals the WCLK counter) the bit goes back low.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STMP_EN</name>
              <description>[0:0] Enables the samplestamp generator. The samplestamp generator must only be enabled after it has been properly configured.
When cleared, all samplestamp generator counters and capture values are cleared.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPXCNTCAPT0</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Captured XOSC Counter Value, Capture Channel 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CAPT_VALUE</name>
              <description>[15:0] The value of the samplestamp XOSC counter (STMPXCNT.CURR_VALUE) last time an event was pulsed (event source selected in [EVENT.I2SSTMPSEL0.EV] for channel 0). This number corresponds to the number of 24 MHz clock cycles since the last positive edge of the selected WCLK.
The value is cleared when STMPCTL.STMP_EN = 0.
Note: Due to buffering and synchronization, WCLK is delayed by a small number of BCLK periods and clk periods.
Note: When calculating the fractional part of the sample stamp, STMPXPER may be less than this bit field.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPXPER</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>XOSC Period Value</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VALUE</name>
              <description>[15:0] The number of 24 MHz clock cycles in the previous WCLK period (that is -  the next value of the XOSC counter at the positive WCLK edge, had it not been reset to 0).
The value is cleared when STMPCTL.STMP_EN = 0.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPWCNTCAPT0</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Captured WCLK Counter Value, Capture Channel 0</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CAPT_VALUE</name>
              <description>[15:0] The value of the samplestamp WCLK counter (STMPWCNT.CURR_VALUE) last time an event was pulsed (event source selected in EVENT:I2SSTMPSEL0.EV for channel 0). This number corresponds to the number of positive WCLK edges since the samplestamp generator was enabled (not taking modification through STMPWADD/STMPWSET into account).
The value is cleared when STMPCTL.STMP_EN = 0.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPWPER</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>WCLK Counter Period Value</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VALUE</name>
              <description>[15:0] Used to define when STMPWCNT is to be reset so number of WCLK edges are found for the size of the sample buffer. This is thus a modulo value for the WCLK counter. This number must correspond to the size of the sample buffer used by the system (that is the index of the last sample plus 1).</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPINTRIG</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>WCLK Counter Trigger Value for Input Pins</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>IN_START_WCNT</name>
              <description>[15:0] Compare value used to start the incoming audio streams.
This bit field shall equal the WCLK counter value during the WCLK period in which the first input word(s) are sampled and stored to memory (that is the sample at the start of the very first DMA input buffer).

The value of this register takes effect when the following conditions are met:
- One or more pins are configured as inputs in AIFDIRCFG.
- AIFDMACFG has been configured for the correct buffer size, and at least 32 BCLK cycle ticks have happened.

Note: To avoid false triggers, this bit field should be set higher than STMPWPER.VALUE.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPOUTTRIG</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>WCLK Counter Trigger Value for Output Pins</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>OUT_START_WCNT</name>
              <description>[15:0] Compare value used to start the outgoing audio streams.

This bit field must equal the WCLK counter value during the WCLK period in which the first output word(s) read from memory are clocked out (that is the sample at the start of the very first DMA output buffer).

The value of this register takes effect when the following conditions are met:
- One or more pins are configured as outputs in AIFDIRCFG.
- AIFDMACFG has been configured for the correct buffer size, and 32 BCLK cycle ticks have happened.
- 2 samples have been preloaded from memory (examine the AIFOUTPTR register if necessary). 
Note: The memory read access is only performed when required, that is channels 0/1 must be selected in AIFWMASK0/AIFWMASK1.

Note: To avoid false triggers, this bit field should be set higher than STMPWPER.VALUE.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPWSET</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>WCLK Counter Set Operation</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VALUE</name>
              <description>[15:0] WCLK counter modification: Sets the running WCLK counter equal to the written value.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPWADD</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>WCLK Counter Add Operation</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VALUE_INC</name>
              <description>[15:0] WCLK counter modification: Adds the written value to the running WCLK counter. If a positive edge of WCLK occurs at the same time as the operation, this will be taken into account.
To add a negative value, write "STMPWPER.VALUE - value".</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPXPERMIN</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>XOSC Minimum Period Value
Minimum Value of STMPXPER</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>VALUE</name>
              <description>[15:0] Each time STMPXPER is updated, the value is also loaded into this register, provided that the value is smaller than the current value in this register.
When written, the register is reset to 0xFFFF (65535), regardless of the value written.
The minimum value can be used to detect extra WCLK pulses (this registers value will be significantly smaller than STMPXPER.VALUE).</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF</resetValue>
        </register>
        <register>
          <name>STMPWCNT</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Current Value of WCNT</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CURR_VALUE</name>
              <description>[15:0] Current value of the WCLK counter</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPXCNT</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>Current Value of XCNT</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CURR_VALUE</name>
              <description>[15:0] Current value of the XOSC counter, latched when reading STMPWCNT.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPXCNTCAPT1</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CAPT_VALUE</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>STMPWCNTCAPT1</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CAPT_VALUE</name>
              <description>[15:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQMASK</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>Interrupt Mask Register

Selects mask states of the flags in IRQFLAGS that contribute to the I2S_IRQ event.</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>AIF_DMA_IN</name>
              <description>[5:5] IRQFLAGS.AIF_DMA_IN interrupt mask

0: Disable
1: Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>AIF_DMA_OUT</name>
              <description>[4:4] IRQFLAGS.AIF_DMA_OUT interrupt mask

0: Disable
1: Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>WCLK_TIMEOUT</name>
              <description>[3:3] IRQFLAGS.WCLK_TIMEOUT interrupt mask

0: Disable
1: Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>BUS_ERR</name>
              <description>[2:2] IRQFLAGS.BUS_ERR interrupt mask

0: Disable
1: Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>WCLK_ERR</name>
              <description>[1:1] IRQFLAGS.WCLK_ERR interrupt mask

0: Disable
1: Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PTR_ERR</name>
              <description>[0:0] IRQFLAGS.PTR_ERR interrupt mask.

0: Disable
1: Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQFLAGS</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>Raw Interrupt Status Register</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>AIF_DMA_IN</name>
              <description>[5:5] Set when condition for this bit field event occurs (auto cleared when input pointer is updated - AIFINPTRNEXT), see description of AIFINPTRNEXT register for details.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>AIF_DMA_OUT</name>
              <description>[4:4] Set when condition for this bit field event occurs (auto cleared when output pointer is updated - AIFOUTPTRNEXT), see description of AIFOUTPTRNEXT register for details</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>WCLK_TIMEOUT</name>
              <description>[3:3] Set when the sample stamp generator does not detect a positive WCLK edge for  65535 clk periods. This signalizes that the internal or external BCLK and WCLK generator source has been disabled.

The bit is sticky and may only be cleared by software (by writing '1' to IRQCLR.WCLK_TIMEOUT).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>BUS_ERR</name>
              <description>[2:2] Set when a DMA operation is not completed in time (that is audio output buffer underflow, or audio input buffer overflow). 
This error requires a complete restart since word synchronization has been lost. The bit is sticky and may only be cleared by software (by writing '1' to IRQCLR.BUS_ERR).

Note that DMA initiated transactions to illegal addresses will not trigger an interrupt. The response to such transactions is undefined.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>WCLK_ERR</name>
              <description>[1:1] Set when: 
- An unexpected WCLK edge occurs during the data delay period of a phase.  Note unexpected WCLK edges during the word and idle periods of the phase are not detected.
-  In dual-phase mode, when two WCLK edges are less than 4 BCLK cycles apart.
-  In single-phase mode, when a WCLK pulse occurs before the last channel.
This error requires a complete restart since word synchronization has been lost. The bit is sticky and may only be cleared by software (by writing '1' to IRQCLR.WCLK_ERR).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PTR_ERR</name>
              <description>[0:0] Set when AIFINPTRNEXT or AIFOUTPTRNEXT has not been loaded with the next block address in time. 
This error requires a complete restart since word synchronization has been lost. The bit is sticky and may only be cleared by software (by writing '1' to IRQCLR.PTR_ERR).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQSET</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>Interrupt Set Register</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>AIF_DMA_IN</name>
              <description>[5:5] 1: Sets the interrupt of IRQFLAGS.AIF_DMA_IN (unless a auto clear criteria was given at the same time, in which the set will be ignored)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>AIF_DMA_OUT</name>
              <description>[4:4] 1: Sets the interrupt of IRQFLAGS.AIF_DMA_OUT (unless a auto clear criteria was given at the same time, in which the set will be ignored)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>WCLK_TIMEOUT</name>
              <description>[3:3] 1: Sets the interrupt of IRQFLAGS.WCLK_TIMEOUT</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>BUS_ERR</name>
              <description>[2:2] 1: Sets the interrupt of IRQFLAGS.BUS_ERR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>WCLK_ERR</name>
              <description>[1:1] 1: Sets the interrupt of IRQFLAGS.WCLK_ERR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PTR_ERR</name>
              <description>[0:0] 1: Sets the interrupt of IRQFLAGS.PTR_ERR</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQCLR</name>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <description>Interrupt Clear Register</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>AIF_DMA_IN</name>
              <description>[5:5] 1: Clears the interrupt of IRQFLAGS.AIF_DMA_IN (unless a set criteria was given at the same time in which the clear will be ignored)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>AIF_DMA_OUT</name>
              <description>[4:4] 1: Clears the interrupt of IRQFLAGS.AIF_DMA_OUT (unless a set criteria was given at the same time in which the clear will be ignored)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>WCLK_TIMEOUT</name>
              <description>[3:3] 1: Clears the interrupt of IRQFLAGS.WCLK_TIMEOUT (unless a set criteria was given at the same time in which the clear will be ignored)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>BUS_ERR</name>
              <description>[2:2] 1: Clears the interrupt of IRQFLAGS.BUS_ERR (unless a set criteria was given at the same time in which the clear will be ignored)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>WCLK_ERR</name>
              <description>[1:1] 1: Clears the interrupt of IRQFLAGS.WCLK_ERR (unless a set criteria was given at the same time in which the clear will be ignored)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>PTR_ERR</name>
              <description>[0:0] 1: Clears the interrupt of IRQFLAGS.PTR_ERR (unless a set criteria was given at the same time in which the clear will be ignored)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>IOC</name>
      <baseAddress>0x40081000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>IO Controller (IOC) - configures all the DIOs and resides in the MCU domain.</description>
      <registers>
        <register>
          <name>IOCFG0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Configuration of DIO0</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input/output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / outut</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO0</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Configuration of DIO1</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO1</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG2</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Configuration of DIO2</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO2</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG3</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Configuration of DIO3</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO3</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG4</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Configuration of DIO4</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO4</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG5</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Configuration of DIO5</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO5</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG6</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Configuration of DIO6</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO6</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG7</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Configuration of DIO7</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO7</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG8</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Configuration of DIO8</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO8</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG9</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Configuration of DIO9</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO9</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG10</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Configuration of DIO10</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO10</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG11</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Configuration of DIO11</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO11</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG12</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Configuration of DIO12</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO12</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG13</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Configuration of DIO13</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO13</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG14</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Configuration of DIO14</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO14</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG15</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Configuration of DIO15</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO15</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG16</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Configuration of DIO16</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO16</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x86000</resetValue>
        </register>
        <register>
          <name>IOCFG17</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Configuration of DIO17</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO17</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x106000</resetValue>
        </register>
        <register>
          <name>IOCFG18</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>Configuration of DIO18</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO18</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG19</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Configuration of DIO19</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO19</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG20</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>Configuration of DIO20</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO20</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG21</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>Configuration of DIO21</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO21</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG22</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>Configuration of DIO22</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO22</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG23</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>Configuration of DIO23</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO23</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG24</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>Configuration of DIO24</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO24</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG25</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>Configuration of DIO25</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO25</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG26</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>Configuration of DIO26</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO26</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG27</name>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <description>Configuration of DIO27</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO27</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG28</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>Configuration of DIO28</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO28</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG29</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>Configuration of DIO29</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO29</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG30</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>Configuration of DIO30</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO30</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
        <register>
          <name>IOCFG31</name>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <description>Configuration of DIO31</description>
          <fields>
            <field>
              <name>RESERVED31</name>
              <description>[31:31] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>HYST_EN</name>
              <description>[30:30] 0: Input hysteresis disable
1: Input hysteresis enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>IE</name>
              <description>[29:29] 0: Input disabled
1: Input enabled

Note: If IO is configured for AUX  ie. PORT_ID = 0x08, the enable will be ignored.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>WU_CFG</name>
              <description>[28:27] If DIO is configured GPIO or non-AON peripheral signals, i.e. PORT_ID 0x00 or >0x08:

00: No wake-up
01: No wake-up
10: Wakes up from shutdown if this pad is going low.
11: Wakes up from shutdown if this pad is going high.

If IO is configured for AON peripheral signals or AUX  ie. PORT_ID 0x01-0x08, this register only sets wakeup enable or not. 

00, 01: Wakeup disabled
10, 11: Wakeup enabled 

Polarity is controlled from AON registers.

Note:When the MSB is set, the IOC will deactivate the output enable for the DIO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>IOMODE</name>
              <description>[26:24] IO Mode 
N/A for IO configured for AON periph. signals and AUX  ie. PORT_ID 0x01-0x08 
AUX has its own open_source/drain configuration. 

0x2: Reserved. Undefined behavior.
0x3: Reserved. Undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPENSRC_INV</name>
                  <value>7</value>
                  <description>Open Source
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENSRC</name>
                  <value>6</value>
                  <description>Open Source
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR_INV</name>
                  <value>5</value>
                  <description>Open Drain
Inverted input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OPENDR</name>
                  <value>4</value>
                  <description>Open Drain, 
Normal input / output</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INV</name>
                  <value>1</value>
                  <description>Inverted input / ouput</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <value>0</value>
                  <description>Normal input / output</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED19</name>
              <description>[23:19] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>EDGE_IRQ_EN</name>
              <description>[18:18] 0: No interrupt generation 
1: Enable interrupt generation for this IO (Only effective if EDGE_DET is enabled)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>EDGE_DET</name>
              <description>[17:16] Enable generation of edge detection events on this IO</description>
              <bitWidth>2</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BOTH</name>
                  <value>3</value>
                  <description>Positive and negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POS</name>
                  <value>2</value>
                  <description>Positive edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEG</name>
                  <value>1</value>
                  <description>Negative edge detection</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NONE</name>
                  <value>0</value>
                  <description>No edge detection</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED15</name>
              <description>[15:15] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>PULL_CTL</name>
              <description>[14:13] Pull control</description>
              <bitWidth>2</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>3</value>
                  <description>No pull</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UP</name>
                  <value>2</value>
                  <description>Pull up</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DWN</name>
                  <value>1</value>
                  <description>Pull down</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLEW_RED</name>
              <description>[12:12] 0: Normal slew rate
1: Enables reduced slew rate in output driver.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>IOCURR</name>
              <description>[11:10] Selects IO current mode of this IO.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>4_8MA</name>
                  <value>2</value>
                  <description>Extended-Current (EC) mode: Min 8 mA for double drive strength IOs (min 4 mA for normal IOs) when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4MA</name>
                  <value>1</value>
                  <description>High-Current (HC) mode: Min 4 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2MA</name>
                  <value>0</value>
                  <description>Low-Current (LC) mode: Min 2 mA when IOSTR is set to AUTO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IOSTR</name>
              <description>[9:8] Select source for drive strength control of this IO.
This setting controls the drive strength of the Low-Current (LC) mode. Higher drive strength can be selected in IOCURR</description>
              <bitWidth>2</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <value>3</value>
                  <description>Maximum drive strength, controlled by AON_IOC:IOSTRMAX (min 2 mA @1.8V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MED</name>
                  <value>2</value>
                  <description>Medium drive strength, controlled by AON_IOC:IOSTRMED (min 2 mA @2.5V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MIN</name>
                  <value>1</value>
                  <description>Minimum drive strength, controlled by AON_IOC:IOSTRMIN (min 2 mA @3.3V with default values)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO</name>
                  <value>0</value>
                  <description>Automatic drive strength, controlled by AON BATMON based on battery voltage. (min 2 mA @VDDS)</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[7:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>PORT_ID</name>
              <description>[5:0] Selects usage for DIO31</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RFC_SMI_CL_IN</name>
                  <value>56</value>
                  <description>RF Core SMI Command Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_CL_OUT</name>
                  <value>55</value>
                  <description>RF Core SMI Command Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_IN</name>
                  <value>54</value>
                  <description>RF Core SMI Data Link In</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_SMI_DL_OUT</name>
                  <value>53</value>
                  <description>RF Core SMI Data Link Out</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI1</name>
                  <value>52</value>
                  <description>RF Core Data In 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPI0</name>
                  <value>51</value>
                  <description>RF Core Data In 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO3</name>
                  <value>50</value>
                  <description>RF Core Data Out 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO2</name>
                  <value>49</value>
                  <description>RF Core Data Out 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO1</name>
                  <value>48</value>
                  <description>RF Core Data Out 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_GPO0</name>
                  <value>47</value>
                  <description>RF Core Data Out 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFC_TRC</name>
                  <value>46</value>
                  <description>RF Core Trace</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_MCLK</name>
                  <value>41</value>
                  <description>I2S MCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_BCLK</name>
                  <value>40</value>
                  <description>I2S BCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_WCLK</name>
                  <value>39</value>
                  <description>I2S WCLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD1</name>
                  <value>38</value>
                  <description>I2S Data 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S_AD0</name>
                  <value>37</value>
                  <description>I2S Data 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_CLK</name>
                  <value>36</value>
                  <description>SSI1 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_FSS</name>
                  <value>35</value>
                  <description>SSI1 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_TX</name>
                  <value>34</value>
                  <description>SSI1 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI1_RX</name>
                  <value>33</value>
                  <description>SSI1 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPU_SWV</name>
                  <value>32</value>
                  <description>CPU SWV</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT7</name>
                  <value>30</value>
                  <description>PORT EVENT 7
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT6</name>
                  <value>29</value>
                  <description>PORT EVENT 6
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT5</name>
                  <value>28</value>
                  <description>PORT EVENT 5
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT4</name>
                  <value>27</value>
                  <description>PORT EVENT 4
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT3</name>
                  <value>26</value>
                  <description>PORT EVENT 3
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT2</name>
                  <value>25</value>
                  <description>PORT EVENT 2
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT1</name>
                  <value>24</value>
                  <description>PORT EVENT 1
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PORT_EVENT0</name>
                  <value>23</value>
                  <description>PORT EVENT 0
Can be used as a general purpose IO event by selecting it via registers in the EVENT module, e.g. EVENT:GPT0ACAPTSEL.EV, EVENT:UDMACH14BSEL.EV, etc</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RTS</name>
                  <value>18</value>
                  <description>UART0 RTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_CTS</name>
                  <value>17</value>
                  <description>UART0 CTS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_TX</name>
                  <value>16</value>
                  <description>UART0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART0_RX</name>
                  <value>15</value>
                  <description>UART0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSCL</name>
                  <value>14</value>
                  <description>I2C Clock</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2C_MSSDA</name>
                  <value>13</value>
                  <description>I2C Data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_CLK</name>
                  <value>12</value>
                  <description>SSI0 CLK</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_FSS</name>
                  <value>11</value>
                  <description>SSI0 FSS</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_TX</name>
                  <value>10</value>
                  <description>SSI0 TX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0_RX</name>
                  <value>9</value>
                  <description>SSI0 RX</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUX_IO</name>
                  <value>8</value>
                  <description>AUX IO</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AON_CLK32K</name>
                  <value>7</value>
                  <description>AON 32 KHz clock (SCLK_LF)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPIO</name>
                  <value>0</value>
                  <description>General Purpose IO</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x6000</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PRCM</name>
      <baseAddress>0x40082000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Power, Reset and Clock Management</description>
      <registers>
        <register>
          <name>INFRCLKDIVR</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Infrastructure Clock Division Factor For Run Mode</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RATIO</name>
              <description>[1:0] Division rate for clocks driving modules in the MCU_AON domain when system CPU is in run mode. Division ratio affects both infrastructure clock and perbusull clock.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIV32</name>
                  <value>3</value>
                  <description>Divide by 32</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV8</name>
                  <value>2</value>
                  <description>Divide by 8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV2</name>
                  <value>1</value>
                  <description>Divide by 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV1</name>
                  <value>0</value>
                  <description>Divide by 1</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>INFRCLKDIVS</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Infrastructure Clock Division Factor For Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RATIO</name>
              <description>[1:0] Division rate for clocks driving modules in the MCU_AON domain when system CPU is in sleep mode. Division ratio affects both infrastructure clock and perbusull clock.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIV32</name>
                  <value>3</value>
                  <description>Divide by 32</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV8</name>
                  <value>2</value>
                  <description>Divide by 8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV2</name>
                  <value>1</value>
                  <description>Divide by 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV1</name>
                  <value>0</value>
                  <description>Divide by 1</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>INFRCLKDIVDS</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Infrastructure Clock Division Factor For DeepSleep Mode</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RATIO</name>
              <description>[1:0] Division rate for clocks driving modules in the MCU_AON domain when system CPU is in seepsleep mode. Division ratio affects both infrastructure clock and perbusull clock.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIV32</name>
                  <value>3</value>
                  <description>Divide by 32</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV8</name>
                  <value>2</value>
                  <description>Divide by 8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV2</name>
                  <value>1</value>
                  <description>Divide by 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV1</name>
                  <value>0</value>
                  <description>Divide by 1</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>VDCTL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>MCU Voltage Domain Control</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MCU_VD</name>
              <description>[2:2] Request WUC to power down the MCU voltage domain

0: No request
1: Assert request when possible. An asserted power down request will result in a boot of the MCU system when powered up again.

The bit will have no effect before the following requirements are met:
1. PDCTL1.CPU_ON = 0
2. PDCTL1.VIMS_MODE = 0
3. SECDMACLKGDS.DMA_CLK_EN = 0 (Note: Setting must be loaded with CLKLOADCTL.LOAD)
4. SECDMACLKGDS.CRYPTO_CLK_EN = 0 (Note: Setting must be loaded with CLKLOADCTL.LOAD)
5. RFC do no request access to BUS
6. System CPU in deepsleep</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[1:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ULDO</name>
              <description>[0:0] Request WUC to switch to uLDO.

0: No request
1: Assert request when possible

The bit will have no effect before the following requirements are met:
1. PDCTL1.CPU_ON = 0
2. PDCTL1.VIMS_MODE = 0
3. SECDMACLKGDS.DMA_CLK_EN = 0 (Note: Setting must be loaded with CLKLOADCTL.LOAD)
4. SECDMACLKGDS.CRYPTO_CLK_EN = 0 (Note: Setting must be loaded with CLKLOADCTL.LOAD)
5. RFC do no request access to BUS
6. System CPU in deepsleep</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CLKLOADCTL</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Load PRCM Settings To CLKCTRL Power Domain</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>LOAD_DONE</name>
              <description>[1:1] Status of LOAD. 
Will be cleared to 0 when any of the registers requiring a LOAD is written to, and be set to 1 when a LOAD is done.
Note that writing no change to a register will result in the LOAD_DONE being cleared.

0 : One or more registers have been write accessed after last LOAD
1 : No registers are write accessed after last LOAD</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>LOAD</name>
              <description>[0:0] 0: No action
1: Load settings to CLKCTRL. Bit is HW cleared.

Multiple changes to settings may be done before LOAD is written once so all changes takes place at the same time. LOAD can also be done after single setting updates.

Registers that needs to be followed by LOAD before settings being applied are:
- RFCCLKG
- VIMSCLKG
- SECDMACLKGR
- SECDMACLKGS
- SECDMACLKGDS
- GPIOCLKGR
- GPIOCLKGS
- GPIOCLKGDS
- GPTCLKGR
- GPTCLKGS
- GPTCLKGDS
- GPTCLKDIV
- I2CCLKGR
- I2CCLKGS
- I2CCLKGDS
- SSICLKGR
- SSICLKGS
- SSICLKGDS
- UARTCLKGR
- UARTCLKGS
- UARTCLKGDS
- I2SCLKGR
- I2SCLKGS
- I2SCLKGDS
- I2SBCLKSEL
- I2SCLKCTL
- I2SMCLKDIV
- I2SBCLKDIV
- I2SWCLKDIV</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x2</resetValue>
        </register>
        <register>
          <name>RFCCLKG</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>RFC Clock Gate</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock if RFC power domain is on

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>VIMSCLKG</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>VIMS Clock Gate</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[1:0] 00: Disable clock 
01: Disable clock when system CPU is in DeepSleep 
11: Enable clock  

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3</resetValue>
        </register>
        <register>
          <name>SECDMACLKGR</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>TRNG, CRYPTO And UDMA Clock Gate For Run Mode</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DMA_CLK_EN</name>
              <description>[8:8] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[7:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TRNG_CLK_EN</name>
              <description>[1:1] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CRYPTO_CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SECDMACLKGS</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>TRNG, CRYPTO And UDMA Clock Gate For Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DMA_CLK_EN</name>
              <description>[8:8] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[7:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TRNG_CLK_EN</name>
              <description>[1:1] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CRYPTO_CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SECDMACLKGDS</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>TRNG, CRYPTO And UDMA Clock Gate For Deep Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>DMA_CLK_EN</name>
              <description>[8:8] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[7:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TRNG_CLK_EN</name>
              <description>[1:1] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CRYPTO_CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIOCLKGR</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>GPIO Clock Gate For Run Mode</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIOCLKGS</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>GPIO Clock Gate For Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPIOCLKGDS</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>GPIO Clock Gate For Deep Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPTCLKGR</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>GPT Clock Gate For Run Mode</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[3:0] Each bit below has the following meaning:

0: Disable clock
1: Enable clock

ENUMs can be combined
For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT3</name>
                  <value>8</value>
                  <description>Enable clock for GPT3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2</name>
                  <value>4</value>
                  <description>Enable clock for GPT2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1</name>
                  <value>2</value>
                  <description>Enable clock for GPT1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0</name>
                  <value>1</value>
                  <description>Enable clock for GPT0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPTCLKGS</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>GPT Clock Gate For Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[3:0] Each bit below has the following meaning:

0: Disable clock
1: Enable clock

ENUMs can be combined
For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT3</name>
                  <value>8</value>
                  <description>Enable clock for GPT3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2</name>
                  <value>4</value>
                  <description>Enable clock for GPT2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1</name>
                  <value>2</value>
                  <description>Enable clock for GPT1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0</name>
                  <value>1</value>
                  <description>Enable clock for GPT0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPTCLKGDS</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>GPT Clock Gate For Deep Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[3:0] Each bit below has the following meaning:

0: Disable clock
1: Enable clock

ENUMs can be combined
For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GPT3</name>
                  <value>8</value>
                  <description>Enable clock for GPT3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT2</name>
                  <value>4</value>
                  <description>Enable clock for GPT2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT1</name>
                  <value>2</value>
                  <description>Enable clock for GPT1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPT0</name>
                  <value>1</value>
                  <description>Enable clock for GPT0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>I2CCLKGR</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>I2C Clock Gate For Run Mode</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>I2CCLKGS</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>I2C Clock Gate For Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>I2CCLKGDS</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>I2C Clock Gate For Deep Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UARTCLKGR</name>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <description>UART Clock Gate For Run Mode</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UARTCLKGS</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>UART Clock Gate For Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>UARTCLKGDS</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>UART Clock Gate For Deep Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SSICLKGR</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>SSI Clock Gate For Run Mode</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[1:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI1</name>
                  <value>2</value>
                  <description>Enable clock for SSI1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0</name>
                  <value>1</value>
                  <description>Enable clock for SSI0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SSICLKGS</name>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <description>SSI Clock Gate For Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[1:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI1</name>
                  <value>2</value>
                  <description>Enable clock for SSI1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0</name>
                  <value>1</value>
                  <description>Enable clock for SSI0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SSICLKGDS</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>SSI Clock Gate For Deep Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[1:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI1</name>
                  <value>2</value>
                  <description>Enable clock for SSI1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI0</name>
                  <value>1</value>
                  <description>Enable clock for SSI0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>I2SCLKGR</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>I2S Clock Gate For Run Mode</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>I2SCLKGS</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>I2S Clock Gate For Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>I2SCLKGDS</name>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <description>I2S Clock Gate For Deep Sleep Mode</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CLK_EN</name>
              <description>[0:0] 0: Disable clock
1: Enable clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CPUCLKDIV</name>
          <addressOffset>0xb8</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Internal. Only to be used through TI provided API.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RATIO</name>
              <description>[0:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIV2</name>
                  <value>1</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV1</name>
                  <value>0</value>
                  <description>Internal. Only to be used through TI provided API.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PERBUSDMACLKDIV</name>
          <addressOffset>0xc0</addressOffset>
          <size>32</size>
          <description>Internal. Only to be used through TI provided API.</description>
          <fields>
            <field>
              <name>SPARE</name>
              <description>[31:0] Internal. Only to be used through TI provided API.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>I2SBCLKSEL</name>
          <addressOffset>0xc8</addressOffset>
          <size>32</size>
          <description>I2S Clock Control</description>
          <fields>
            <field>
              <name>SPARE</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>SRC</name>
              <description>[0:0] BCLK source selector

0: Use external BCLK
1: Use internally generated clock

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>GPTCLKDIV</name>
          <addressOffset>0xcc</addressOffset>
          <size>32</size>
          <description>GPT Scalar</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RATIO</name>
              <description>[3:0] Scalar used for GPTs. The division rate will be constant and ungated for Run / Sleep / DeepSleep mode. 

For changes to take effect, CLKLOADCTL.LOAD needs to be written
Other values are not supported.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIV256</name>
                  <value>8</value>
                  <description>Divide by 256</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV128</name>
                  <value>7</value>
                  <description>Divide by 128</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV64</name>
                  <value>6</value>
                  <description>Divide by 64</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV32</name>
                  <value>5</value>
                  <description>Divide by 32</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV16</name>
                  <value>4</value>
                  <description>Divide by 16</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV8</name>
                  <value>3</value>
                  <description>Divide by 8</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV4</name>
                  <value>2</value>
                  <description>Divide by 4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV2</name>
                  <value>1</value>
                  <description>Divide by 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV1</name>
                  <value>0</value>
                  <description>Divide by 1</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>I2SCLKCTL</name>
          <addressOffset>0xd0</addressOffset>
          <size>32</size>
          <description>I2S Clock Control</description>
          <fields>
            <field>
              <name>RESERVED4</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SMPL_ON_POSEDGE</name>
              <description>[3:3] On the I2S serial interface, data and WCLK is sampled and clocked out on opposite edges of BCLK. 

0 - data and WCLK are sampled on the negative edge and clocked out on the positive edge. 
1 - data and WCLK are sampled on the positive edge and clocked out on the negative edge.

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>WCLK_PHASE</name>
              <description>[2:1] Decides how the WCLK division ratio is calculated and used to generate different duty cycles (See I2SWCLKDIV.WDIV). 

0: Single phase
1: Dual phase
2: User Defined
3: Reserved/Undefined

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>EN</name>
              <description>[0:0] 0: MCLK, BCLK and WCLK will be static low
1: Enables the generation of  MCLK, BCLK and WCLK

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>I2SMCLKDIV</name>
          <addressOffset>0xd4</addressOffset>
          <size>32</size>
          <description>MCLK Division Ratio</description>
          <fields>
            <field>
              <name>RESERVED10</name>
              <description>[31:10] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>22</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>MDIV</name>
              <description>[9:0] An unsigned factor of the division ratio used to generate MCLK [2-1024]:

MCLK = MCUCLK/MDIV[Hz]
MCUCLK is 48MHz in normal mode. For powerdown mode the frequency is defined by AON_WUC:MCUCLK.PWR_DWN_SRC 

A value of 0 is interpreted as 1024.
A value of 1 is invalid.
If MDIV is odd the low phase of the clock is one MCUCLK period longer than the high phase.

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>10</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>I2SBCLKDIV</name>
          <addressOffset>0xd8</addressOffset>
          <size>32</size>
          <description>BCLK Division Ratio</description>
          <fields>
            <field>
              <name>RESERVED10</name>
              <description>[31:10] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>22</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BDIV</name>
              <description>[9:0] An unsigned factor of the division ratio used to generate I2S BCLK [2-1024]:

BCLK = MCUCLK/BDIV[Hz]
MCUCLK is 48MHz in normal mode. For powerdown mode the frequency is defined by AON_WUC:MCUCLK.PWR_DWN_SRC 

A value of 0 is interpreted as 1024.
A value of 1 is invalid.
If BDIV is odd and I2SCLKCTL.SMPL_ON_POSEDGE = 0, the low phase of the clock is one MCUCLK period longer than the high phase. 
If BDIV is odd and I2SCLKCTL.SMPL_ON_POSEDGE = 1 , the high phase of the clock is one MCUCLK period longer than the low phase. 

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>10</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>I2SWCLKDIV</name>
          <addressOffset>0xdc</addressOffset>
          <size>32</size>
          <description>WCLK Division Ratio</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>WDIV</name>
              <description>[15:0] If I2SCLKCTL.WCLK_PHASE = 0, Single phase.
WCLK is high one BCLK period and low WDIV[9:0] (unsigned, [1-1023]) BCLK periods.
 
WCLK = MCUCLK / BDIV*(WDIV[9:0] + 1) [Hz]
MCUCLK is 48MHz in normal mode. For powerdown mode the frequency is defined by AON_WUC:MCUCLK.PWR_DWN_SRC

If I2SCLKCTL.WCLK_PHASE = 1, Dual phase.
Each phase on WCLK (50% duty cycle) is WDIV[9:0] (unsigned, [1-1023]) BCLK periods.

WCLK = MCUCLK / BDIV*(2*WDIV[9:0]) [Hz] 

If I2SCLKCTL.WCLK_PHASE = 2, User defined.
WCLK is high WDIV[7:0] (unsigned, [1-255]) BCLK periods and low WDIV[15:8] (unsigned, [1-255]) BCLK periods.

WCLK = MCUCLK / (BDIV*(WDIV[7:0] + WDIV[15:8]) [Hz] 

For changes to take effect, CLKLOADCTL.LOAD needs to be written</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SWRESET</name>
          <addressOffset>0x10c</addressOffset>
          <size>32</size>
          <description>SW Initiated Resets</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MCU</name>
              <description>[2:2] Internal. Only to be used through TI provided API.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[1:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>WARMRESET</name>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <description>WARM Reset Control And Status</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>WR_TO_PINRESET</name>
              <description>[2:2] 0: No action
1: A warm system reset event triggered by the below listed sources will result in an emulated pin reset. 

Warm reset sources included:
ICEPick sysreset
System CPU reset request, CPU_SCS:AIRCR.SYSRESETREQ
System CPU Lockup
WDT timeout 

An active ICEPick block system reset will gate all sources except ICEPick sysreset

SW can read AON_SYSCTL:RESETCTL.RESET_SRC to find the source of the last reset resulting in a full power up sequence. WARMRESET in this register is set in the scenario that WR_TO_PINRESET=1 and one of the above listed sources is triggered.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>LOCKUP_STAT</name>
              <description>[1:1] 0: No registred event
1: A system CPU LOCKUP event has occured since last SW clear of the register.

A read of this register clears both  WDT_STAT and LOCKUP_STAT.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>WDT_STAT</name>
              <description>[0:0] 0: No registered event
1: A WDT event has occured since last SW clear of the register.

A read of this register clears both WDT_STAT and LOCKUP_STAT.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PDCTL0</name>
          <addressOffset>0x12c</addressOffset>
          <size>32</size>
          <description>Power Domain Control</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PERIPH_ON</name>
              <description>[2:2] PERIPH Power domain.

0: PERIPH power domain is powered down
1: PERIPH power domain is powered up</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SERIAL_ON</name>
              <description>[1:1] SERIAL Power domain.

0: SERIAL power domain is powered down
1: SERIAL power domain is powered up</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RFC_ON</name>
              <description>[0:0] 0: RFC power domain powered off if also PDCTL1.RFC_ON = 0
1: RFC power domain powered on</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PDCTL0RFC</name>
          <addressOffset>0x130</addressOffset>
          <size>32</size>
          <description>RFC Power Domain Control</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] Alias for PDCTL0.RFC_ON</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PDCTL0SERIAL</name>
          <addressOffset>0x134</addressOffset>
          <size>32</size>
          <description>SERIAL Power Domain Control</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] Alias for PDCTL0.SERIAL_ON</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PDCTL0PERIPH</name>
          <addressOffset>0x138</addressOffset>
          <size>32</size>
          <description>PERIPH Power Domain Control</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] Alias for PDCTL0.PERIPH_ON</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PDSTAT0</name>
          <addressOffset>0x140</addressOffset>
          <size>32</size>
          <description>Power Domain Status</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PERIPH_ON</name>
              <description>[2:2] PERIPH Power domain.

0: Domain may be powered down
1: Domain powered up (guaranteed)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SERIAL_ON</name>
              <description>[1:1] SERIAL Power domain.

0: Domain may be powered down
1: Domain powered up (guaranteed)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RFC_ON</name>
              <description>[0:0] RFC Power domain

0: Domain may be powered down
1: Domain powered up (guaranteed)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PDSTAT0RFC</name>
          <addressOffset>0x144</addressOffset>
          <size>32</size>
          <description>RFC Power Domain Status</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] Alias for PDSTAT0.RFC_ON</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PDSTAT0SERIAL</name>
          <addressOffset>0x148</addressOffset>
          <size>32</size>
          <description>SERIAL Power Domain Status</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] Alias for PDSTAT0.SERIAL_ON</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PDSTAT0PERIPH</name>
          <addressOffset>0x14c</addressOffset>
          <size>32</size>
          <description>PERIPH Power Domain Status</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] Alias for PDSTAT0.PERIPH_ON</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PDCTL1</name>
          <addressOffset>0x17c</addressOffset>
          <size>32</size>
          <description>Power Domain Control</description>
          <fields>
            <field>
              <name>RESERVED5</name>
              <description>[31:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RESERVED4</name>
              <description>[4:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>VIMS_MODE</name>
              <description>[3:3] 0: VIMS power domain is only powered when CPU power domain is powered.
1: VIMS power domain is powered whenever the BUS power domain is powered.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RFC_ON</name>
              <description>[2:2] 0: RFC power domain powered off if also PDCTL0.RFC_ON = 0
1: RFC power domain powered on

Bit shall be used by RFC in autonomus mode but there is no HW restrictions fom system CPU to access the bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CPU_ON</name>
              <description>[1:1] 0: Causes a power down of the CPU power domain when system CPU indicates it is idle. 
1: Initiates power-on of the CPU power domain.

This bit is automatically set by a WIC power-on event.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xA</resetValue>
        </register>
        <register>
          <name>PDCTL1CPU</name>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <description>CPU Power Domain Direct Control</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] This is an alias for PDCTL1.CPU_ON</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PDCTL1RFC</name>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <description>RFC Power Domain Direct Control</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] This is an alias for PDCTL1.RFC_ON</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PDCTL1VIMS</name>
          <addressOffset>0x18c</addressOffset>
          <size>32</size>
          <description>VIMS Mode Direct Control</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] This is an alias for PDCTL1.VIMS_MODE</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PDSTAT1</name>
          <addressOffset>0x194</addressOffset>
          <size>32</size>
          <description>Power Manager Status</description>
          <fields>
            <field>
              <name>RESERVED5</name>
              <description>[31:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>BUS_ON</name>
              <description>[4:4] 0: BUS domain not accessible
1: BUS domain is currently accessible</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>VIMS_MODE</name>
              <description>[3:3] 0: VIMS domain not accessible
1: VIMS domain is currently accessible</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RFC_ON</name>
              <description>[2:2] 0: RFC domain not accessible
1: RFC domain is currently accessible</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CPU_ON</name>
              <description>[1:1] 0: CPU and BUS domain not accessible
1: CPU and BUS domains are both currently accessible</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1A</resetValue>
        </register>
        <register>
          <name>PDSTAT1BUS</name>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <description>BUS Power Domain Direct Read Status</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] This is an alias for PDSTAT1.BUS_ON</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PDSTAT1RFC</name>
          <addressOffset>0x19c</addressOffset>
          <size>32</size>
          <description>RFC Power Domain Direct Read Status</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] This is an alias for PDSTAT1.RFC_ON</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PDSTAT1CPU</name>
          <addressOffset>0x1a0</addressOffset>
          <size>32</size>
          <description>CPU Power Domain Direct Read Status</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] This is an alias for PDSTAT1.CPU_ON</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PDSTAT1VIMS</name>
          <addressOffset>0x1a4</addressOffset>
          <size>32</size>
          <description>VIMS Mode Direct Read Status</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ON</name>
              <description>[0:0] This is an alias for PDSTAT1.VIMS_MODE</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>RFCBITS</name>
          <addressOffset>0x1cc</addressOffset>
          <size>32</size>
          <description>Control To RFC</description>
          <fields>
            <field>
              <name>READ</name>
              <description>[31:0] Control bits for RFC. The RF core CPE processor will automatically check this register when it boots, and it can be used to immediately instruct CPE to perform some tasks at its start-up. The supported functionality is ROM-defined and may vary. See the technical reference manual for more details.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RFCMODESEL</name>
          <addressOffset>0x1d0</addressOffset>
          <size>32</size>
          <description>Selected RFC Mode</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CURR</name>
              <description>[2:0] Selects the set of commands that the RFC will accept. Only modes permitted by RFCMODEHWOPT.AVAIL are writeable. See the technical reference manual for details.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MODE7</name>
                  <value>7</value>
                  <description>Select Mode 7</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE6</name>
                  <value>6</value>
                  <description>Select Mode 6</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE5</name>
                  <value>5</value>
                  <description>Select Mode 5</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE4</name>
                  <value>4</value>
                  <description>Select Mode 4</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE3</name>
                  <value>3</value>
                  <description>Select Mode 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE2</name>
                  <value>2</value>
                  <description>Select Mode 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE1</name>
                  <value>1</value>
                  <description>Select Mode 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE0</name>
                  <value>0</value>
                  <description>Select Mode 0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RFCMODEHWOPT</name>
          <addressOffset>0x1d4</addressOffset>
          <size>32</size>
          <description>Allowed RFC Modes</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>AVAIL</name>
              <description>[7:0] Permitted RFC modes. More than one mode can be permitted.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MODE7</name>
                  <value>128</value>
                  <description>Mode 7 permitted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE6</name>
                  <value>64</value>
                  <description>Mode 6 permitted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE5</name>
                  <value>32</value>
                  <description>Mode 5 permitted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE4</name>
                  <value>16</value>
                  <description>Mode 4 permitted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE3</name>
                  <value>8</value>
                  <description>Mode 3 permitted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE2</name>
                  <value>4</value>
                  <description>Mode 2 permitted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE1</name>
                  <value>2</value>
                  <description>Mode 1 permitted</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MODE0</name>
                  <value>1</value>
                  <description>Mode 0 permitted</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>PWRPROFSTAT</name>
          <addressOffset>0x1e0</addressOffset>
          <size>32</size>
          <description>Power Profiler Register</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>VALUE</name>
              <description>[7:0] SW can use these bits to timestamp the application. These bits are also available through the testtap and can thus be used by the emulator to profile in real time.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>RAMRETEN</name>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <description>Memory Retention Control</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RFC</name>
              <description>[2:2] 0: Retention for RFC SRAM disabled
1: Retention for RFC SRAM enabled
    
Memories controlled: CPERAM  MCERAM  RFERAM</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>VIMS</name>
              <description>[1:0] 0: Memory retention disabled
1: Memory retention enabled

Bit 0: VIMS_TRAM
Bit 1: VIMS_CRAM

Legal modes depend on settings in VIMS:CTL.MODE

00: VIMS:CTL.MODE must be OFF before DEEPSLEEP is asserted - must be set to CACHE or SPLIT mode after waking up again
01: VIMS:CTL.MODE must be GPRAM before DEEPSLEEP is asserted. Must remain in GPRAM mode after wake up, alternatively select OFF mode first and then CACHE or SPILT mode.
10: Illegal mode
11: No restrictions</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RFC_DBELL</name>
      <baseAddress>0x40041000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x40</size>
        <usage>registers</usage>
      </addressBlock>
      <description>RF Core Doorbell</description>
      <registers>
        <register>
          <name>CMDR</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Doorbell Command Register</description>
          <fields>
            <field>
              <name>CMD</name>
              <description>[31:0] Command register. Raises an interrupt to the Command and packet engine (CPE) upon write.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CMDSTA</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Doorbell Command Status Register</description>
          <fields>
            <field>
              <name>STAT</name>
              <description>[31:0] Status of the last command used</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RFHWIFG</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Interrupt Flags From RF Hardware Modules</description>
          <fields>
            <field>
              <name>RESERVED20</name>
              <description>[31:20] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>RATCH7</name>
              <description>[19:19] Radio timer channel 7 interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>RATCH6</name>
              <description>[18:18] Radio timer channel 6 interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RATCH5</name>
              <description>[17:17] Radio timer channel 5 interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RATCH4</name>
              <description>[16:16] Radio timer channel 4 interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RATCH3</name>
              <description>[15:15] Radio timer channel 3 interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>RATCH2</name>
              <description>[14:14] Radio timer channel 2 interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>RATCH1</name>
              <description>[13:13] Radio timer channel 1 interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RATCH0</name>
              <description>[12:12] Radio timer channel 0 interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RFESOFT2</name>
              <description>[11:11] RF engine software defined interrupt 2 flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>RFESOFT1</name>
              <description>[10:10] RF engine software defined interrupt 1 flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RFESOFT0</name>
              <description>[9:9] RF engine software defined interrupt 0 flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>RFEDONE</name>
              <description>[8:8] RF engine command done interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>[7:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TRCTK</name>
              <description>[6:6] Debug tracer system tick interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>MDMSOFT</name>
              <description>[5:5] Modem synchronization word detection interrupt flag. This interrupt will be raised by modem when the synchronization word is received. The CPE may decide to reject the packet based on its header (protocol specific). Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>MDMOUT</name>
              <description>[4:4] Modem FIFO output interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MDMIN</name>
              <description>[3:3] Modem FIFO input interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MDMDONE</name>
              <description>[2:2] Modem command done interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>FSCA</name>
              <description>[1:1] Frequency synthesizer calibration accelerator interrupt flag. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RFHWIEN</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Interrupt Enable For RF Hardware Modules</description>
          <fields>
            <field>
              <name>RESERVED20</name>
              <description>[31:20] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>12</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>RATCH7</name>
              <description>[19:19] Interrupt enable for RFHWIFG.RATCH7.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>RATCH6</name>
              <description>[18:18] Interrupt enable for RFHWIFG.RATCH6.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RATCH5</name>
              <description>[17:17] Interrupt enable for RFHWIFG.RATCH5.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RATCH4</name>
              <description>[16:16] Interrupt enable for RFHWIFG.RATCH4.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RATCH3</name>
              <description>[15:15] Interrupt enable for RFHWIFG.RATCH3.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>RATCH2</name>
              <description>[14:14] Interrupt enable for RFHWIFG.RATCH2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>RATCH1</name>
              <description>[13:13] Interrupt enable for RFHWIFG.RATCH1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>RATCH0</name>
              <description>[12:12] Interrupt enable for RFHWIFG.RATCH0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RFESOFT2</name>
              <description>[11:11] Interrupt enable for RFHWIFG.RFESOFT2.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>RFESOFT1</name>
              <description>[10:10] Interrupt enable for RFHWIFG.RFESOFT1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RFESOFT0</name>
              <description>[9:9] Interrupt enable for RFHWIFG.RFESOFT0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>RFEDONE</name>
              <description>[8:8] Interrupt enable for RFHWIFG.RFEDONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RESERVED7</name>
              <description>[7:7] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TRCTK</name>
              <description>[6:6] Interrupt enable for RFHWIFG.TRCTK.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>MDMSOFT</name>
              <description>[5:5] Interrupt enable for RFHWIFG.MDMSOFT.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>MDMOUT</name>
              <description>[4:4] Interrupt enable for RFHWIFG.MDMOUT.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MDMIN</name>
              <description>[3:3] Interrupt enable for RFHWIFG.MDMIN.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MDMDONE</name>
              <description>[2:2] Interrupt enable for RFHWIFG.MDMDONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>FSCA</name>
              <description>[1:1] Interrupt enable for RFHWIFG.FSCA.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RFCPEIFG</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Interrupt Flags For Command and Packet Engine Generated Interrupts</description>
          <fields>
            <field>
              <name>INTERNAL_ERROR</name>
              <description>[31:31] Interrupt flag 31. The command and packet engine (CPE) has observed an unexpected error. A reset of the CPE is needed. This can be done by switching the RF Core power domain off and on in PRCM:PDCTL1RFC. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>BOOT_DONE</name>
              <description>[30:30] Interrupt flag 30. The command and packet engine (CPE) boot is finished. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>MODULES_UNLOCKED</name>
              <description>[29:29] Interrupt flag 29. As part of command and packet engine (CPE) boot process, it has opened access to RF Core modules and memories. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>SYNTH_NO_LOCK</name>
              <description>[28:28] Interrupt flag 28. The phase-locked loop in frequency synthesizer has reported loss of lock. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>IRQ27</name>
              <description>[27:27] Interrupt flag 27. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>RX_ABORTED</name>
              <description>[26:26] Interrupt flag 26. Packet reception stopped before packet was done. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>RX_N_DATA_WRITTEN</name>
              <description>[25:25] Interrupt flag 25. Specified number of bytes written to partial read Rx buffer. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>RX_DATA_WRITTEN</name>
              <description>[24:24] Interrupt flag 24. Data written to partial read Rx buffer. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RX_ENTRY_DONE</name>
              <description>[23:23] Interrupt flag 23. Rx queue data entry changing state to finished.  Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>RX_BUF_FULL</name>
              <description>[22:22] Interrupt flag 22. Packet received that did not fit in Rx queue. BLE mode: Packet received that did not fit in the Rx queue. IEEE 802.15.4 mode: Frame received that did not fit in the Rx queue. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>RX_CTRL_ACK</name>
              <description>[21:21] Interrupt flag 21. BLE mode only: LL control packet received with CRC OK, not to be ignored, then acknowledgement sent. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>RX_CTRL</name>
              <description>[20:20] Interrupt flag 20. BLE mode only: LL control packet received with CRC OK, not to be ignored. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>[19:19] Interrupt flag 19. BLE mode only: Packet received with CRC OK, not to be ignored, no payload. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>RX_IGNORED</name>
              <description>[18:18] Interrupt flag 18. Packet received, but can be ignored. BLE mode: Packet received with CRC OK, but to be ignored. IEEE 802.15.4 mode: Frame received with ignore flag set. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RX_NOK</name>
              <description>[17:17] Interrupt flag 17. Packet received with CRC error. BLE mode: Packet received with CRC error. IEEE 802.15.4 mode: Frame received with CRC error. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RX_OK</name>
              <description>[16:16] Interrupt flag 16. Packet received correctly. BLE mode: Packet received with CRC OK, payload, and not to be ignored. IEEE 802.15.4 mode: Frame received with CRC OK. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>IRQ15</name>
              <description>[15:15] Interrupt flag 15. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>IRQ14</name>
              <description>[14:14] Interrupt flag 14. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>IRQ13</name>
              <description>[13:13] Interrupt flag 13. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>IRQ12</name>
              <description>[12:12] Interrupt flag 12. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TX_BUFFER_CHANGED</name>
              <description>[11:11] Interrupt flag 11. BLE mode only: A buffer change is complete after CMD_BLE_ADV_PAYLOAD. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>TX_ENTRY_DONE</name>
              <description>[10:10] Interrupt flag 10. Tx queue data entry state changed to finished. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TX_RETRANS</name>
              <description>[9:9] Interrupt flag 9. BLE mode only: Packet retransmitted. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TX_CTRL_ACK_ACK</name>
              <description>[8:8] Interrupt flag 8. BLE mode only: Acknowledgement received on a transmitted LL control packet, and acknowledgement transmitted for that packet. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TX_CTRL_ACK</name>
              <description>[7:7] Interrupt flag 7. BLE mode: Acknowledgement received on a transmitted LL control packet. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TX_CTRL</name>
              <description>[6:6] Interrupt flag 6. BLE mode: Transmitted LL control packet. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TX_ACK</name>
              <description>[5:5] Interrupt flag 5. BLE mode: Acknowledgement received on a transmitted packet. IEEE 802.15.4 mode: Transmitted automatic ACK frame. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TX_DONE</name>
              <description>[4:4] Interrupt flag 4. Packet transmitted. (BLE mode: A packet has been transmitted.) (IEEE 802.15.4 mode: A frame has been transmitted). Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>LAST_FG_COMMAND_DONE</name>
              <description>[3:3] Interrupt flag 3. IEEE 802.15.4 mode only: The last foreground radio operation command in a chain of commands has finished. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>FG_COMMAND_DONE</name>
              <description>[2:2] Interrupt flag 2. IEEE 802.15.4 mode only: A foreground radio operation command has finished. Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>LAST_COMMAND_DONE</name>
              <description>[1:1] Interrupt flag 1. The last radio operation command in a chain of commands has finished. (IEEE 802.15.4 mode: The last background level radio operation command in a chain of commands has finished.) Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>COMMAND_DONE</name>
              <description>[0:0] Interrupt flag 0. A radio operation has finished. (IEEE 802.15.4 mode: A background level radio operation command has finished.) Write zero to clear flag. Write to one has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RFCPEIEN</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Interrupt Enable For Command and Packet Engine Generated Interrupts</description>
          <fields>
            <field>
              <name>INTERNAL_ERROR</name>
              <description>[31:31] Interrupt enable for RFCPEIFG.INTERNAL_ERROR.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>BOOT_DONE</name>
              <description>[30:30] Interrupt enable for RFCPEIFG.BOOT_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>MODULES_UNLOCKED</name>
              <description>[29:29] Interrupt enable for RFCPEIFG.MODULES_UNLOCKED.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>SYNTH_NO_LOCK</name>
              <description>[28:28] Interrupt enable for RFCPEIFG.SYNTH_NO_LOCK.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>IRQ27</name>
              <description>[27:27] Interrupt enable for RFCPEIFG.IRQ27.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
            </field>
            <field>
              <name>RX_ABORTED</name>
              <description>[26:26] Interrupt enable for RFCPEIFG.RX_ABORTED.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
            </field>
            <field>
              <name>RX_N_DATA_WRITTEN</name>
              <description>[25:25] Interrupt enable for RFCPEIFG.RX_N_DATA_WRITTEN.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
            </field>
            <field>
              <name>RX_DATA_WRITTEN</name>
              <description>[24:24] Interrupt enable for RFCPEIFG.RX_DATA_WRITTEN.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RX_ENTRY_DONE</name>
              <description>[23:23] Interrupt enable for RFCPEIFG.RX_ENTRY_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
            </field>
            <field>
              <name>RX_BUF_FULL</name>
              <description>[22:22] Interrupt enable for RFCPEIFG.RX_BUF_FULL.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
            </field>
            <field>
              <name>RX_CTRL_ACK</name>
              <description>[21:21] Interrupt enable for RFCPEIFG.RX_CTRL_ACK.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>RX_CTRL</name>
              <description>[20:20] Interrupt enable for RFCPEIFG.RX_CTRL.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>[19:19] Interrupt enable for RFCPEIFG.RX_EMPTY.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
            </field>
            <field>
              <name>RX_IGNORED</name>
              <description>[18:18] Interrupt enable for RFCPEIFG.RX_IGNORED.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
            </field>
            <field>
              <name>RX_NOK</name>
              <description>[17:17] Interrupt enable for RFCPEIFG.RX_NOK.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>RX_OK</name>
              <description>[16:16] Interrupt enable for RFCPEIFG.RX_OK.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>IRQ15</name>
              <description>[15:15] Interrupt enable for RFCPEIFG.IRQ15.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
            </field>
            <field>
              <name>IRQ14</name>
              <description>[14:14] Interrupt enable for RFCPEIFG.IRQ14.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
            </field>
            <field>
              <name>IRQ13</name>
              <description>[13:13] Interrupt enable for RFCPEIFG.IRQ13.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
            </field>
            <field>
              <name>IRQ12</name>
              <description>[12:12] Interrupt enable for RFCPEIFG.IRQ12.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>TX_BUFFER_CHANGED</name>
              <description>[11:11] Interrupt enable for RFCPEIFG.TX_BUFFER_CHANGED.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>TX_ENTRY_DONE</name>
              <description>[10:10] Interrupt enable for RFCPEIFG.TX_ENTRY_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>TX_RETRANS</name>
              <description>[9:9] Interrupt enable for RFCPEIFG.TX_RETRANS.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>TX_CTRL_ACK_ACK</name>
              <description>[8:8] Interrupt enable for RFCPEIFG.TX_CTRL_ACK_ACK.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TX_CTRL_ACK</name>
              <description>[7:7] Interrupt enable for RFCPEIFG.TX_CTRL_ACK.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>TX_CTRL</name>
              <description>[6:6] Interrupt enable for RFCPEIFG.TX_CTRL.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TX_ACK</name>
              <description>[5:5] Interrupt enable for RFCPEIFG.TX_ACK.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>TX_DONE</name>
              <description>[4:4] Interrupt enable for RFCPEIFG.TX_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>LAST_FG_COMMAND_DONE</name>
              <description>[3:3] Interrupt enable for RFCPEIFG.LAST_FG_COMMAND_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>FG_COMMAND_DONE</name>
              <description>[2:2] Interrupt enable for RFCPEIFG.FG_COMMAND_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>LAST_COMMAND_DONE</name>
              <description>[1:1] Interrupt enable for RFCPEIFG.LAST_COMMAND_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>COMMAND_DONE</name>
              <description>[0:0] Interrupt enable for RFCPEIFG.COMMAND_DONE.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>RFCPEISL</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Interrupt Vector Selection For Command and Packet Engine Generated Interrupts</description>
          <fields>
            <field>
              <name>INTERNAL_ERROR</name>
              <description>[31:31] Select which CPU interrupt vector the RFCPEIFG.INTERNAL_ERROR interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BOOT_DONE</name>
              <description>[30:30] Select which CPU interrupt vector the RFCPEIFG.BOOT_DONE interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MODULES_UNLOCKED</name>
              <description>[29:29] Select which CPU interrupt vector the RFCPEIFG.MODULES_UNLOCKED interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYNTH_NO_LOCK</name>
              <description>[28:28] Select which CPU interrupt vector the RFCPEIFG.SYNTH_NO_LOCK interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>28</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IRQ27</name>
              <description>[27:27] Select which CPU interrupt vector the RFCPEIFG.IRQ27 interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>27</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_ABORTED</name>
              <description>[26:26] Select which CPU interrupt vector the RFCPEIFG.RX_ABORTED interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>26</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_N_DATA_WRITTEN</name>
              <description>[25:25] Select which CPU interrupt vector the RFCPEIFG.RX_N_DATA_WRITTEN interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>25</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_DATA_WRITTEN</name>
              <description>[24:24] Select which CPU interrupt vector the RFCPEIFG.RX_DATA_WRITTEN interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>24</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_ENTRY_DONE</name>
              <description>[23:23] Select which CPU interrupt vector the RFCPEIFG.RX_ENTRY_DONE interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>23</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_BUF_FULL</name>
              <description>[22:22] Select which CPU interrupt vector the RFCPEIFG.RX_BUF_FULL interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>22</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_CTRL_ACK</name>
              <description>[21:21] Select which CPU interrupt vector the RFCPEIFG.RX_CTRL_ACK interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>21</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_CTRL</name>
              <description>[20:20] Select which CPU interrupt vector the RFCPEIFG.RX_CTRL interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>20</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>[19:19] Select which CPU interrupt vector the RFCPEIFG.RX_EMPTY interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>19</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_IGNORED</name>
              <description>[18:18] Select which CPU interrupt vector the RFCPEIFG.RX_IGNORED interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>18</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_NOK</name>
              <description>[17:17] Select which CPU interrupt vector the RFCPEIFG.RX_NOK interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>17</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RX_OK</name>
              <description>[16:16] Select which CPU interrupt vector the RFCPEIFG.RX_OK interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>16</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IRQ15</name>
              <description>[15:15] Select which CPU interrupt vector the RFCPEIFG.IRQ15 interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IRQ14</name>
              <description>[14:14] Select which CPU interrupt vector the RFCPEIFG.IRQ14 interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IRQ13</name>
              <description>[13:13] Select which CPU interrupt vector the RFCPEIFG.IRQ13 interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>13</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>IRQ12</name>
              <description>[12:12] Select which CPU interrupt vector the RFCPEIFG.IRQ12 interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_BUFFER_CHANGED</name>
              <description>[11:11] Select which CPU interrupt vector the RFCPEIFG.TX_BUFFER_CHANGED interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_ENTRY_DONE</name>
              <description>[10:10] Select which CPU interrupt vector the RFCPEIFG.TX_ENTRY_DONE interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_RETRANS</name>
              <description>[9:9] Select which CPU interrupt vector the RFCPEIFG.TX_RETRANS interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_CTRL_ACK_ACK</name>
              <description>[8:8] Select which CPU interrupt vector the RFCPEIFG.TX_CTRL_ACK_ACK interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_CTRL_ACK</name>
              <description>[7:7] Select which CPU interrupt vector the RFCPEIFG.TX_CTRL_ACK interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_CTRL</name>
              <description>[6:6] Select which CPU interrupt vector the RFCPEIFG.TX_CTRL interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_ACK</name>
              <description>[5:5] Select which CPU interrupt vector the RFCPEIFG.TX_ACK interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TX_DONE</name>
              <description>[4:4] Select which CPU interrupt vector the RFCPEIFG.TX_DONE interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LAST_FG_COMMAND_DONE</name>
              <description>[3:3] Select which CPU interrupt vector the RFCPEIFG.LAST_FG_COMMAND_DONE interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FG_COMMAND_DONE</name>
              <description>[2:2] Select which CPU interrupt vector the RFCPEIFG.FG_COMMAND_DONE interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LAST_COMMAND_DONE</name>
              <description>[1:1] Select which CPU interrupt vector the RFCPEIFG.LAST_COMMAND_DONE interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COMMAND_DONE</name>
              <description>[0:0] Select which CPU interrupt vector the RFCPEIFG.COMMAND_DONE interrupt should use.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPE1</name>
                  <value>1</value>
                  <description>Associate this interrupt line with INT_RF_CPE1 interrupt vector</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPE0</name>
                  <value>0</value>
                  <description>Associate this interrupt line with INT_RF_CPE0 interrupt vector</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0xFFFF0000</resetValue>
        </register>
        <register>
          <name>RFACKIFG</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Doorbell Command Acknowledgement Interrupt Flag</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>ACKFLAG</name>
              <description>[0:0] Interrupt flag for Command ACK</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SYSGPOCTL</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>RF Core General Purpose Output Control</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>GPOCTL3</name>
              <description>[15:12] RF Core GPO control bit 3. Selects which signal to output on the RF Core GPO line 3.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RATGPO3</name>
                  <value>15</value>
                  <description>RAT GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RATGPO2</name>
                  <value>14</value>
                  <description>RAT GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RATGPO1</name>
                  <value>13</value>
                  <description>RAT GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RATGPO0</name>
                  <value>12</value>
                  <description>RAT GPO line 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO3</name>
                  <value>11</value>
                  <description>RFE GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO2</name>
                  <value>10</value>
                  <description>RFE GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO1</name>
                  <value>9</value>
                  <description>RFE GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO0</name>
                  <value>8</value>
                  <description>RFE GPO line 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO3</name>
                  <value>7</value>
                  <description>MCE GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO2</name>
                  <value>6</value>
                  <description>MCE GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO1</name>
                  <value>5</value>
                  <description>MCE GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO0</name>
                  <value>4</value>
                  <description>MCE GPO line 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO3</name>
                  <value>3</value>
                  <description>CPE GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO2</name>
                  <value>2</value>
                  <description>CPE GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO1</name>
                  <value>1</value>
                  <description>CPE GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO0</name>
                  <value>0</value>
                  <description>CPE GPO line 0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPOCTL2</name>
              <description>[11:8] RF Core GPO control bit 2. Selects which signal to output on the RF Core GPO line 2.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RATGPO3</name>
                  <value>15</value>
                  <description>RAT GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RATGPO2</name>
                  <value>14</value>
                  <description>RAT GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RATGPO1</name>
                  <value>13</value>
                  <description>RAT GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RATGPO0</name>
                  <value>12</value>
                  <description>RAT GPO line 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO3</name>
                  <value>11</value>
                  <description>RFE GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO2</name>
                  <value>10</value>
                  <description>RFE GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO1</name>
                  <value>9</value>
                  <description>RFE GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO0</name>
                  <value>8</value>
                  <description>RFE GPO line 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO3</name>
                  <value>7</value>
                  <description>MCE GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO2</name>
                  <value>6</value>
                  <description>MCE GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO1</name>
                  <value>5</value>
                  <description>MCE GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO0</name>
                  <value>4</value>
                  <description>MCE GPO line 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO3</name>
                  <value>3</value>
                  <description>CPE GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO2</name>
                  <value>2</value>
                  <description>CPE GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO1</name>
                  <value>1</value>
                  <description>CPE GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO0</name>
                  <value>0</value>
                  <description>CPE GPO line 0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPOCTL1</name>
              <description>[7:4] RF Core GPO control bit 1. Selects which signal to output on the RF Core GPO line 1.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RATGPO3</name>
                  <value>15</value>
                  <description>RAT GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RATGPO2</name>
                  <value>14</value>
                  <description>RAT GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RATGPO1</name>
                  <value>13</value>
                  <description>RAT GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RATGPO0</name>
                  <value>12</value>
                  <description>RAT GPO line 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO3</name>
                  <value>11</value>
                  <description>RFE GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO2</name>
                  <value>10</value>
                  <description>RFE GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO1</name>
                  <value>9</value>
                  <description>RFE GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO0</name>
                  <value>8</value>
                  <description>RFE GPO line 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO3</name>
                  <value>7</value>
                  <description>MCE GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO2</name>
                  <value>6</value>
                  <description>MCE GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO1</name>
                  <value>5</value>
                  <description>MCE GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO0</name>
                  <value>4</value>
                  <description>MCE GPO line 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO3</name>
                  <value>3</value>
                  <description>CPE GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO2</name>
                  <value>2</value>
                  <description>CPE GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO1</name>
                  <value>1</value>
                  <description>CPE GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO0</name>
                  <value>0</value>
                  <description>CPE GPO line 0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>GPOCTL0</name>
              <description>[3:0] RF Core GPO control bit 0. Selects which signal to output on the RF Core GPO line 0.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RATGPO3</name>
                  <value>15</value>
                  <description>RAT GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RATGPO2</name>
                  <value>14</value>
                  <description>RAT GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RATGPO1</name>
                  <value>13</value>
                  <description>RAT GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RATGPO0</name>
                  <value>12</value>
                  <description>RAT GPO line 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO3</name>
                  <value>11</value>
                  <description>RFE GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO2</name>
                  <value>10</value>
                  <description>RFE GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO1</name>
                  <value>9</value>
                  <description>RFE GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RFEGPO0</name>
                  <value>8</value>
                  <description>RFE GPO line 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO3</name>
                  <value>7</value>
                  <description>MCE GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO2</name>
                  <value>6</value>
                  <description>MCE GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO1</name>
                  <value>5</value>
                  <description>MCE GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MCEGPO0</name>
                  <value>4</value>
                  <description>MCE GPO line 0</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO3</name>
                  <value>3</value>
                  <description>CPE GPO line 3</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO2</name>
                  <value>2</value>
                  <description>CPE GPO line 2</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO1</name>
                  <value>1</value>
                  <description>CPE GPO line 1</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CPEGPO0</name>
                  <value>0</value>
                  <description>CPE GPO line 0</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RFC_PWR</name>
      <baseAddress>0x40040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <description>RF Core Power Management</description>
      <registers>
        <register>
          <name>PWMCLKEN</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>RF Core Power Management and Clock Enable</description>
          <fields>
            <field>
              <name>RESERVED11</name>
              <description>[31:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>RFCTRC</name>
              <description>[10:10] Enable clock to the RF Core Tracer (RFCTRC) module.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>FSCA</name>
              <description>[9:9] Enable clock to the Frequency Synthesizer Calibration Accelerator (FSCA) module.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PHA</name>
              <description>[8:8] Enable clock to the Packet Handling Accelerator (PHA) module.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>RAT</name>
              <description>[7:7] Enable clock to the Radio Timer (RAT) module.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RFERAM</name>
              <description>[6:6] Enable clock to the RF Engine RAM module.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RFE</name>
              <description>[5:5] Enable clock to the RF Engine (RFE) module.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>MDMRAM</name>
              <description>[4:4] Enable clock to the Modem RAM module.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MDM</name>
              <description>[3:3] Enable clock to the Modem (MDM) module.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>CPERAM</name>
              <description>[2:2] Enable clock to the Command and Packet Engine (CPE) RAM module. As part of RF Core initialization, set this bit together with CPE bit to enable CPE to boot.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CPE</name>
              <description>[1:1] Enable processor clock (hclk) to the Command and Packet Engine (CPE). As part of RF Core initialization, set this bit together with CPERAM bit to enable CPE to boot.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RFC</name>
              <description>[0:0] Enable essential clocks for the RF Core interface. This includes the interconnect, the radio doorbell DBELL command interface, the power management (PWR) clock control module, and bus clock (sclk) for the CPE. To remove possibility of locking yourself out from the RF Core, this bit can not be cleared. If you need to disable all clocks to the RF Core, see the PRCM:RFCCLKG.CLK_EN register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RFC_RAT</name>
      <baseAddress>0x40043000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x100</size>
        <usage>registers</usage>
      </addressBlock>
      <description>RF Core Radio Timer</description>
      <registers>
        <register>
          <name>RATCNT</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Radio Timer Counter Value</description>
          <fields>
            <field>
              <name>CNT</name>
              <description>[31:0] Counter value. This is not writable while radio timer counter is enabled.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RATCH0VAL</name>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <description>Timer Channel 0 Capture/Compare Register</description>
          <fields>
            <field>
              <name>VAL</name>
              <description>[31:0] Capture/compare value. The system CPU can safely read this register, but it is recommended to use the CPE API commands to configure it for compare mode.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RATCH1VAL</name>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <description>Timer Channel 1 Capture/Compare Register</description>
          <fields>
            <field>
              <name>VAL</name>
              <description>[31:0] Capture/compare value. The system CPU can safely read this register, but it is recommended to use the CPE API commands to configure it for compare mode.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RATCH2VAL</name>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <description>Timer Channel 2 Capture/Compare Register</description>
          <fields>
            <field>
              <name>VAL</name>
              <description>[31:0] Capture/compare value. The system CPU can safely read this register, but it is recommended to use the CPE API commands to configure it for compare mode.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RATCH3VAL</name>
          <addressOffset>0x8c</addressOffset>
          <size>32</size>
          <description>Timer Channel 3 Capture/Compare Register</description>
          <fields>
            <field>
              <name>VAL</name>
              <description>[31:0] Capture/compare value. The system CPU can safely read this register, but it is recommended to use the CPE API commands to configure it for compare mode.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RATCH4VAL</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>Timer Channel 4 Capture/Compare Register</description>
          <fields>
            <field>
              <name>VAL</name>
              <description>[31:0] Capture/compare value. The system CPU can safely read this register, but it is recommended to use the CPE API commands to configure it for compare mode.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RATCH5VAL</name>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <description>Timer Channel 5 Capture/Compare Register</description>
          <fields>
            <field>
              <name>VAL</name>
              <description>[31:0] Capture/compare value. The system CPU can safely read this register, but it is recommended to use the CPE API commands to configure it for compare mode.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RATCH6VAL</name>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <description>Timer Channel 6 Capture/Compare Register</description>
          <fields>
            <field>
              <name>VAL</name>
              <description>[31:0] Capture/compare value. The system CPU can safely read this register, but it is recommended to use the CPE API commands to configure it for compare mode.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RATCH7VAL</name>
          <addressOffset>0x9c</addressOffset>
          <size>32</size>
          <description>Timer Channel 7 Capture/Compare Register</description>
          <fields>
            <field>
              <name>VAL</name>
              <description>[31:0] Capture/compare value. The system CPU can safely read this register, but it is recommended to use the CPE API commands to configure it for compare mode.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SMPH</name>
      <baseAddress>0x40084000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>MCU Semaphore Module

This module provides 32 binary semaphores. The state of a binary semaphore is either taken or available. 

A semaphore does not implement any ownership attribute. Still, a semaphore can be used to handle mutual exclusion scenarios.</description>
      <registers>
        <register>
          <name>SMPH0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 0</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 1</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH2</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 2</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH3</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 3</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH4</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 4</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH5</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 5</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH6</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 6</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH7</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 7</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH8</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 8</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH9</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 9</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH10</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 10</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH11</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 11</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH12</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 12</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH13</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 13</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH14</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 14</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH15</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 15</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH16</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 16</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH17</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 17</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH18</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 18</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH19</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 19</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH20</name>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 20</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH21</name>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 21</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH22</name>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 22</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH23</name>
          <addressOffset>0x5c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 23</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH24</name>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 24</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH25</name>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 25</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH26</name>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 26</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH27</name>
          <addressOffset>0x6c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 27</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH28</name>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 28</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH29</name>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 29</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH30</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 30</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>SMPH31</name>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 31</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available

Reading the register causes it to change value to 0. Releasing the semaphore is done by writing 1.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK0</name>
          <addressOffset>0x800</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 0 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK1</name>
          <addressOffset>0x804</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 1 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK2</name>
          <addressOffset>0x808</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 2 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK3</name>
          <addressOffset>0x80c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 3 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK4</name>
          <addressOffset>0x810</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 4 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK5</name>
          <addressOffset>0x814</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 5 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK6</name>
          <addressOffset>0x818</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 6 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK7</name>
          <addressOffset>0x81c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 7 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK8</name>
          <addressOffset>0x820</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 8 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK9</name>
          <addressOffset>0x824</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 9 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK10</name>
          <addressOffset>0x828</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 10 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK11</name>
          <addressOffset>0x82c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 11 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK12</name>
          <addressOffset>0x830</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 12 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK13</name>
          <addressOffset>0x834</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 13 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK14</name>
          <addressOffset>0x838</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 14 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK15</name>
          <addressOffset>0x83c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 15 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK16</name>
          <addressOffset>0x840</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 16 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK17</name>
          <addressOffset>0x844</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 17 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK18</name>
          <addressOffset>0x848</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 18 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK19</name>
          <addressOffset>0x84c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 19 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK20</name>
          <addressOffset>0x850</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 20 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK21</name>
          <addressOffset>0x854</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 21 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK22</name>
          <addressOffset>0x858</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 22 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK23</name>
          <addressOffset>0x85c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 23 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK24</name>
          <addressOffset>0x860</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 24 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK25</name>
          <addressOffset>0x864</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 25 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK26</name>
          <addressOffset>0x868</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 26 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK27</name>
          <addressOffset>0x86c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 27 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK28</name>
          <addressOffset>0x870</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 28 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK29</name>
          <addressOffset>0x874</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 29 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK30</name>
          <addressOffset>0x878</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 30 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
        <register>
          <name>PEEK31</name>
          <addressOffset>0x87c</addressOffset>
          <size>32</size>
          <description>MCU SEMAPHORE 31 ALIAS</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] Status when reading:

0: Semaphore is taken
1: Semaphore is available 

Used for semaphore debugging. A read operation will not change register value. Register writing is not possible.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SSI0</name>
      <baseAddress>0x40000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Synchronous Serial Interface with master and slave capabilities</description>
      <registers>
        <register>
          <name>CR0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Control 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SCR</name>
              <description>[15:8] Serial clock rate:
This is used to generate the transmit and receive bit rate of the SSI. The bit rate is 
(SSI's clock frequency)/((SCR+1)*CPSR.CPSDVSR).
SCR is a value from 0-255.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SPH</name>
              <description>[7:7] CLKOUT phase (Motorola SPI frame format only)
This bit selects the clock edge that captures data and enables it to change state. It
has the most impact on the first bit transmitted by either permitting or not permitting a clock transition before the first data capture edge.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>2ND_CLK_EDGE</name>
                  <value>1</value>
                  <description>Data is captured on the second clock edge transition.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1ST_CLK_EDGE</name>
                  <value>0</value>
                  <description>Data is captured on the first clock edge transition.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPO</name>
              <description>[6:6] CLKOUT polarity (Motorola SPI frame format only)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>1</value>
                  <description>SSI produces a steady state HIGH value on the CLKOUT pin when data is not being transferred.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>0</value>
                  <description>SSI produces a steady state LOW value on the
CLKOUT pin when data is not being transferred.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRF</name>
              <description>[5:4] Frame format. 
The supported frame formats are Motorola SPI, TI synchronous serial and National Microwire. 
Value 0'b11 is reserved and shall not be used.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NATIONAL_MICROWIRE</name>
                  <value>2</value>
                  <description>National Microwire frame format</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TI_SYNC_SERIAL</name>
                  <value>1</value>
                  <description>TI synchronous serial frame format</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MOTOROLA_SPI</name>
                  <value>0</value>
                  <description>Motorola SPI frame format</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSS</name>
              <description>[3:0] Data Size Select. 
Values 0b0000, 0b0001, 0b0010 are reserved and shall not be used.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>16_BIT</name>
                  <value>15</value>
                  <description>16-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>15_BIT</name>
                  <value>14</value>
                  <description>15-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>14_BIT</name>
                  <value>13</value>
                  <description>14-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>13_BIT</name>
                  <value>12</value>
                  <description>13-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>12_BIT</name>
                  <value>11</value>
                  <description>12-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>11_BIT</name>
                  <value>10</value>
                  <description>11-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>10_BIT</name>
                  <value>9</value>
                  <description>10-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>9_BIT</name>
                  <value>8</value>
                  <description>9-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8_BIT</name>
                  <value>7</value>
                  <description>8-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>7_BIT</name>
                  <value>6</value>
                  <description>7-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>6_BIT</name>
                  <value>5</value>
                  <description>6-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>5_BIT</name>
                  <value>4</value>
                  <description>5-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4_BIT</name>
                  <value>3</value>
                  <description>4-bit data</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CR1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Control 1</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SOD</name>
              <description>[3:3] Slave-mode output disabled
This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an SSI master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, this bitfield can be set if the SSI slave is not supposed to drive the TXD line:

0: SSI can drive the TXD output in slave mode.
1: SSI cannot drive the TXD output in slave mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MS</name>
              <description>[2:2] Master or slave mode select. This bit can be modified only when SSI is disabled, SSE=0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLAVE</name>
                  <value>1</value>
                  <description>Device configured as slave</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MASTER</name>
                  <value>0</value>
                  <description>Device configured as master</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSE</name>
              <description>[1:1] Synchronous serial interface enable.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI_ENABLED</name>
                  <value>1</value>
                  <description>Operation enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI_DISABLED</name>
                  <value>0</value>
                  <description>Operation disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LBM</name>
              <description>[0:0] Loop back mode:

0: Normal serial port operation enabled.
1: Output of transmit serial shifter is connected to input of receive serial shifter internally.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Data
16-bits wide data register:
When read, the entry in the receive FIFO, pointed to by the current FIFO read pointer, is accessed. As data values are removed by the  receive logic from the incoming data frame, they are placed into the entry in the receive FIFO, pointed to by the current FIFO write pointer.
When written, the entry in the transmit FIFO, pointed to by the write pointer, is written to. Data values are removed from the transmit FIFO one value at a time by the transmit logic. It is loaded into the transmit serial shifter, then serially shifted out onto the TXD output pin at the programmed bit rate.
When a data size of less than 16 bits is selected, the user must right-justify data written to the transmit FIFO. The transmit logic ignores the unused bits. Received data less than 16 bits is automatically right-justified in the receive buffer.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[15:0] Transmit/receive data
The values read from this field or written to this field must be right-justified when SSI is programmed for a data size that is less than 16 bits (CR0.DSS != 0b1111). Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SR</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Status</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>BSY</name>
              <description>[4:4] Serial interface busy:

0: SSI is idle
1: SSI is currently transmitting and/or receiving a frame or the transmit FIFO is not empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RFF</name>
              <description>[3:3] Receive FIFO full:

0: Receive FIFO is not full.
1: Receive FIFO is full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RNE</name>
              <description>[2:2] Receive FIFO not empty

0: Receive FIFO is empty.
1: Receive FIFO is not empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TNF</name>
              <description>[1:1] Transmit FIFO not full:

0: Transmit FIFO is full.
1: Transmit FIFO is not full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TFE</name>
              <description>[0:0] Transmit FIFO empty:

0: Transmit FIFO is not empty.
1: Transmit FIFO is empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3</resetValue>
        </register>
        <register>
          <name>CPSR</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Clock Prescale</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CPSDVSR</name>
              <description>[7:0] Clock prescale divisor:
This field specifies the division factor by which the input system clock to SSI must be internally divided before further use.
The value programmed into this field must be an even non-zero number (2-254). The least significant bit of the programmed number is hard-coded to zero. If an odd number is written to this register, data read back from
this register has the least significant bit as zero.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IMSC</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Interrupt Mask Set and Clear</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TXIM</name>
              <description>[3:3] Transmit FIFO interrupt mask:
A read returns the current mask for transmit FIFO interrupt. On a write of 1, the mask for transmit FIFO interrupt is set which means the interrupt state will be reflected in MIS.TXMIS. A write of 0 clears the mask which means MIS.TXMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXIM</name>
              <description>[2:2] Receive FIFO interrupt mask:
A read returns the current mask for receive FIFO interrupt. On a write of 1, the mask for receive FIFO interrupt is set which means the interrupt state will be reflected in MIS.RXMIS. A write of 0 clears the mask which means MIS.RXMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTIM</name>
              <description>[1:1] Receive timeout interrupt mask:
A read returns the current mask for receive timeout interrupt. On a write of 1, the mask for receive timeout interrupt is set which means the interrupt state will be reflected in MIS.RTMIS. A write of 0 clears the mask which means MIS.RTMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORIM</name>
              <description>[0:0] Receive overrun interrupt mask:
A read returns the current mask for receive overrun interrupt. On a write of 1, the mask for receive overrun interrupt is set which means the interrupt state will be reflected in MIS.RORMIS. A write of 0 clears the mask which means MIS.RORMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Raw Interrupt Status</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TXRIS</name>
              <description>[3:3] Raw transmit FIFO interrupt status:
The transmit interrupt is asserted when there are four or fewer valid entries in the transmit FIFO. The transmit interrupt is not qualified with the SSI enable signal. Therefore one of the following ways can be used:
 - data can be written to the transmit FIFO prior to enabling the SSI and the
interrupts.
 - SSI and interrupts can be enabled so that data can be written to the transmit FIFO by an interrupt service routine.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXRIS</name>
              <description>[2:2] Raw interrupt state of receive FIFO interrupt:
The receive interrupt is asserted when there are four or more valid entries in the receive FIFO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTRIS</name>
              <description>[1:1] Raw interrupt state of receive timeout interrupt:
The receive timeout interrupt is asserted when the receive FIFO is not empty and SSI has remained idle for a fixed 32 bit period. This mechanism can be used to notify the user that data is still present in the receive FIFO and requires servicing. This interrupt is deasserted if the receive FIFO becomes empty by subsequent reads, or if new data is received on RXD.
It can also be cleared by writing to ICR.RTIC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORRIS</name>
              <description>[0:0] Raw interrupt state of receive overrun interrupt:
The receive overrun interrupt is asserted when the FIFO is already full and an additional data frame is received, causing an overrun of the FIFO. Data is over-written in the
receive shift register, but not the FIFO so the FIFO contents stay valid.
It can also be cleared by writing to ICR.RORIC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x8</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Masked Interrupt Status</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TXMIS</name>
              <description>[3:3] Masked interrupt state of transmit FIFO interrupt:
This field returns the masked interrupt state of transmit FIFO interrupt which is the AND product of raw interrupt state RIS.TXRIS and the mask setting IMSC.TXIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXMIS</name>
              <description>[2:2] Masked interrupt state of receive FIFO interrupt:
This field returns the masked interrupt state of receive FIFO interrupt which is the AND product of raw interrupt state RIS.RXRIS and the mask setting IMSC.RXIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTMIS</name>
              <description>[1:1] Masked interrupt state of receive timeout interrupt:
This field returns the masked interrupt state of receive timeout interrupt which is the AND product of raw interrupt state RIS.RTRIS and the mask setting IMSC.RTIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORMIS</name>
              <description>[0:0] Masked interrupt state of receive overrun interrupt:
This field returns the masked interrupt state of receive overrun interrupt which is the AND product of raw interrupt state RIS.RORRIS and the mask setting IMSC.RORIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Interrupt Clear
On a write of 1, the corresponding interrupt is cleared. A write of 0 has no effect.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTIC</name>
              <description>[1:1] Clear the receive timeout interrupt:
Writing 1 to this field clears the timeout interrupt (RIS.RTRIS). Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORIC</name>
              <description>[0:0] Clear the receive overrun interrupt:
Writing 1 to this field clears the overrun error interrupt (RIS.RORRIS). Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMACR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>DMA Control</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TXDMAE</name>
              <description>[1:1] Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RXDMAE</name>
              <description>[0:0] Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED1</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED2</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SSI1</name>
      <baseAddress>0x40008000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Synchronous Serial Interface with master and slave capabilities</description>
      <registers>
        <register>
          <name>CR0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Control 0</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>SCR</name>
              <description>[15:8] Serial clock rate:
This is used to generate the transmit and receive bit rate of the SSI. The bit rate is 
(SSI's clock frequency)/((SCR+1)*CPSR.CPSDVSR).
SCR is a value from 0-255.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SPH</name>
              <description>[7:7] CLKOUT phase (Motorola SPI frame format only)
This bit selects the clock edge that captures data and enables it to change state. It
has the most impact on the first bit transmitted by either permitting or not permitting a clock transition before the first data capture edge.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>2ND_CLK_EDGE</name>
                  <value>1</value>
                  <description>Data is captured on the second clock edge transition.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1ST_CLK_EDGE</name>
                  <value>0</value>
                  <description>Data is captured on the first clock edge transition.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPO</name>
              <description>[6:6] CLKOUT polarity (Motorola SPI frame format only)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HIGH</name>
                  <value>1</value>
                  <description>SSI produces a steady state HIGH value on the CLKOUT pin when data is not being transferred.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOW</name>
                  <value>0</value>
                  <description>SSI produces a steady state LOW value on the
CLKOUT pin when data is not being transferred.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FRF</name>
              <description>[5:4] Frame format. 
The supported frame formats are Motorola SPI, TI synchronous serial and National Microwire. 
Value 0'b11 is reserved and shall not be used.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NATIONAL_MICROWIRE</name>
                  <value>2</value>
                  <description>National Microwire frame format</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TI_SYNC_SERIAL</name>
                  <value>1</value>
                  <description>TI synchronous serial frame format</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MOTOROLA_SPI</name>
                  <value>0</value>
                  <description>Motorola SPI frame format</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DSS</name>
              <description>[3:0] Data Size Select. 
Values 0b0000, 0b0001, 0b0010 are reserved and shall not be used.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>16_BIT</name>
                  <value>15</value>
                  <description>16-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>15_BIT</name>
                  <value>14</value>
                  <description>15-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>14_BIT</name>
                  <value>13</value>
                  <description>14-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>13_BIT</name>
                  <value>12</value>
                  <description>13-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>12_BIT</name>
                  <value>11</value>
                  <description>12-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>11_BIT</name>
                  <value>10</value>
                  <description>11-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>10_BIT</name>
                  <value>9</value>
                  <description>10-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>9_BIT</name>
                  <value>8</value>
                  <description>9-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8_BIT</name>
                  <value>7</value>
                  <description>8-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>7_BIT</name>
                  <value>6</value>
                  <description>7-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>6_BIT</name>
                  <value>5</value>
                  <description>6-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>5_BIT</name>
                  <value>4</value>
                  <description>5-bit data</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4_BIT</name>
                  <value>3</value>
                  <description>4-bit data</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CR1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Control 1</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>SOD</name>
              <description>[3:3] Slave-mode output disabled
This bit is relevant only in the slave mode, MS=1. In multiple-slave systems, it is possible for an SSI master to broadcast a message to all slaves in the system while ensuring that only one slave drives data onto its serial output line. In such systems the RXD lines from multiple slaves could be tied together. To operate in such systems, this bitfield can be set if the SSI slave is not supposed to drive the TXD line:

0: SSI can drive the TXD output in slave mode.
1: SSI cannot drive the TXD output in slave mode.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>MS</name>
              <description>[2:2] Master or slave mode select. This bit can be modified only when SSI is disabled, SSE=0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLAVE</name>
                  <value>1</value>
                  <description>Device configured as slave</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MASTER</name>
                  <value>0</value>
                  <description>Device configured as master</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSE</name>
              <description>[1:1] Synchronous serial interface enable.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SSI_ENABLED</name>
                  <value>1</value>
                  <description>Operation enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SSI_DISABLED</name>
                  <value>0</value>
                  <description>Operation disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LBM</name>
              <description>[0:0] Loop back mode:

0: Normal serial port operation enabled.
1: Output of transmit serial shifter is connected to input of receive serial shifter internally.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DR</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Data
16-bits wide data register:
When read, the entry in the receive FIFO, pointed to by the current FIFO read pointer, is accessed. As data values are removed by the  receive logic from the incoming data frame, they are placed into the entry in the receive FIFO, pointed to by the current FIFO write pointer.
When written, the entry in the transmit FIFO, pointed to by the write pointer, is written to. Data values are removed from the transmit FIFO one value at a time by the transmit logic. It is loaded into the transmit serial shifter, then serially shifted out onto the TXD output pin at the programmed bit rate.
When a data size of less than 16 bits is selected, the user must right-justify data written to the transmit FIFO. The transmit logic ignores the unused bits. Received data less than 16 bits is automatically right-justified in the receive buffer.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[15:0] Transmit/receive data
The values read from this field or written to this field must be right-justified when SSI is programmed for a data size that is less than 16 bits (CR0.DSS != 0b1111). Unused bits at the top are ignored by transmit logic. The receive logic automatically right-justifies.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SR</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Status</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:5] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>27</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>BSY</name>
              <description>[4:4] Serial interface busy:

0: SSI is idle
1: SSI is currently transmitting and/or receiving a frame or the transmit FIFO is not empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RFF</name>
              <description>[3:3] Receive FIFO full:

0: Receive FIFO is not full.
1: Receive FIFO is full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RNE</name>
              <description>[2:2] Receive FIFO not empty

0: Receive FIFO is empty.
1: Receive FIFO is not empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TNF</name>
              <description>[1:1] Transmit FIFO not full:

0: Transmit FIFO is full.
1: Transmit FIFO is not full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TFE</name>
              <description>[0:0] Transmit FIFO empty:

0: Transmit FIFO is not empty.
1: Transmit FIFO is empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x3</resetValue>
        </register>
        <register>
          <name>CPSR</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Clock Prescale</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>CPSDVSR</name>
              <description>[7:0] Clock prescale divisor:
This field specifies the division factor by which the input system clock to SSI must be internally divided before further use.
The value programmed into this field must be an even non-zero number (2-254). The least significant bit of the programmed number is hard-coded to zero. If an odd number is written to this register, data read back from
this register has the least significant bit as zero.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IMSC</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Interrupt Mask Set and Clear</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TXIM</name>
              <description>[3:3] Transmit FIFO interrupt mask:
A read returns the current mask for transmit FIFO interrupt. On a write of 1, the mask for transmit FIFO interrupt is set which means the interrupt state will be reflected in MIS.TXMIS. A write of 0 clears the mask which means MIS.TXMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXIM</name>
              <description>[2:2] Receive FIFO interrupt mask:
A read returns the current mask for receive FIFO interrupt. On a write of 1, the mask for receive FIFO interrupt is set which means the interrupt state will be reflected in MIS.RXMIS. A write of 0 clears the mask which means MIS.RXMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTIM</name>
              <description>[1:1] Receive timeout interrupt mask:
A read returns the current mask for receive timeout interrupt. On a write of 1, the mask for receive timeout interrupt is set which means the interrupt state will be reflected in MIS.RTMIS. A write of 0 clears the mask which means MIS.RTMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORIM</name>
              <description>[0:0] Receive overrun interrupt mask:
A read returns the current mask for receive overrun interrupt. On a write of 1, the mask for receive overrun interrupt is set which means the interrupt state will be reflected in MIS.RORMIS. A write of 0 clears the mask which means MIS.RORMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Raw Interrupt Status</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TXRIS</name>
              <description>[3:3] Raw transmit FIFO interrupt status:
The transmit interrupt is asserted when there are four or fewer valid entries in the transmit FIFO. The transmit interrupt is not qualified with the SSI enable signal. Therefore one of the following ways can be used:
 - data can be written to the transmit FIFO prior to enabling the SSI and the
interrupts.
 - SSI and interrupts can be enabled so that data can be written to the transmit FIFO by an interrupt service routine.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXRIS</name>
              <description>[2:2] Raw interrupt state of receive FIFO interrupt:
The receive interrupt is asserted when there are four or more valid entries in the receive FIFO.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTRIS</name>
              <description>[1:1] Raw interrupt state of receive timeout interrupt:
The receive timeout interrupt is asserted when the receive FIFO is not empty and SSI has remained idle for a fixed 32 bit period. This mechanism can be used to notify the user that data is still present in the receive FIFO and requires servicing. This interrupt is deasserted if the receive FIFO becomes empty by subsequent reads, or if new data is received on RXD.
It can also be cleared by writing to ICR.RTIC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORRIS</name>
              <description>[0:0] Raw interrupt state of receive overrun interrupt:
The receive overrun interrupt is asserted when the FIFO is already full and an additional data frame is received, causing an overrun of the FIFO. Data is over-written in the
receive shift register, but not the FIFO so the FIFO contents stay valid.
It can also be cleared by writing to ICR.RORIC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x8</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Masked Interrupt Status</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>TXMIS</name>
              <description>[3:3] Masked interrupt state of transmit FIFO interrupt:
This field returns the masked interrupt state of transmit FIFO interrupt which is the AND product of raw interrupt state RIS.TXRIS and the mask setting IMSC.TXIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RXMIS</name>
              <description>[2:2] Masked interrupt state of receive FIFO interrupt:
This field returns the masked interrupt state of receive FIFO interrupt which is the AND product of raw interrupt state RIS.RXRIS and the mask setting IMSC.RXIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTMIS</name>
              <description>[1:1] Masked interrupt state of receive timeout interrupt:
This field returns the masked interrupt state of receive timeout interrupt which is the AND product of raw interrupt state RIS.RTRIS and the mask setting IMSC.RTIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORMIS</name>
              <description>[0:0] Masked interrupt state of receive overrun interrupt:
This field returns the masked interrupt state of receive overrun interrupt which is the AND product of raw interrupt state RIS.RORRIS and the mask setting IMSC.RORIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Interrupt Clear
On a write of 1, the corresponding interrupt is cleared. A write of 0 has no effect.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>RTIC</name>
              <description>[1:1] Clear the receive timeout interrupt:
Writing 1 to this field clears the timeout interrupt (RIS.RTRIS). Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RORIC</name>
              <description>[0:0] Clear the receive overrun interrupt:
Writing 1 to this field clears the overrun error interrupt (RIS.RORRIS). Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMACR</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>DMA Control</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TXDMAE</name>
              <description>[1:1] Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RXDMAE</name>
              <description>[0:0] Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED1</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED2</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TRNG</name>
      <baseAddress>0x40028000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x2000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>True Random Number Generator</description>
      <registers>
        <register>
          <name>OUT0</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Random Number Lower Word Readout Value</description>
          <fields>
            <field>
              <name>VALUE_31_0</name>
              <description>[31:0] LSW of 64- bit random value. New value ready when IRQFLAGSTAT.RDY = 1.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>OUT1</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Random Number Upper Word Readout Value</description>
          <fields>
            <field>
              <name>VALUE_63_32</name>
              <description>[31:0] MSW of 64-bit random value. New value ready when IRQFLAGSTAT.RDY = 1.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQFLAGSTAT</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Interrupt Status</description>
          <fields>
            <field>
              <name>NEED_CLOCK</name>
              <description>[31:31] 1: Indicates that the TRNG is busy generating entropy or is in one of its test modes - clocks may not be turned off and the power supply voltage must be kept stable. 
0: TRNG is idle and can be shut down</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[30:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SHUTDOWN_OVF</name>
              <description>[1:1] 1: The number of FROs shut down (i.e. the number of '1' bits in the ALARMSTOP register) has exceeded the threshold set by ALARMCNT.SHUTDOWN_THR 

Writing '1' to IRQFLAGCLR.SHUTDOWN_OVF clears this bit to '0' again.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RDY</name>
              <description>[0:0] 1: Data are available in OUT0 and OUT1.

Acknowledging this state by writing '1' to IRQFLAGCLR.RDY clears this bit to '0'. 
If a new number is already available in the internal register of the TRNG, the number is directly clocked into the result register. In this case the status bit is asserted again, after one clock cycle.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQFLAGMASK</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Interrupt Mask</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SHUTDOWN_OVF</name>
              <description>[1:1] 1: Allow IRQFLAGSTAT.SHUTDOWN_OVF to activate the interrupt from this module.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RDY</name>
              <description>[0:0] 1: Allow IRQFLAGSTAT.RDY to activate the interrupt from this module.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQFLAGCLR</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Interrupt Flag Clear</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SHUTDOWN_OVF</name>
              <description>[1:1] 1: Clear IRQFLAGSTAT.SHUTDOWN_OVF.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RDY</name>
              <description>[0:0] 1: Clear IRQFLAGSTAT.RDY.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Control</description>
          <fields>
            <field>
              <name>STARTUP_CYCLES</name>
              <description>[31:16] This field determines the number of samples (between 2^8 and 2^24) taken to gather entropy from the FROs during startup. If the written value of this field is zero, the number of samples is 2^24, otherwise the number of samples equals the written value times 2^8.

0x0000: 2^24 samples
0x0001: 1*2^8 samples
0x0002: 2*2^8 samples
0x0003: 3*2^8 samples
...
0x8000: 32768*2^8 samples
0xC000: 49152*2^8 samples
...
0xFFFF: 65535*2^8 samples

This field can only be modified while TRNG_EN is 0. If 1 an update will be ignored.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED11</name>
              <description>[15:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>TRNG_EN</name>
              <description>[10:10] 0: Forces all TRNG logic back into the idle state immediately.
1: Starts TRNG, gathering entropy from the FROs for the number of samples determined by STARTUP_CYCLES.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RESERVED3</name>
              <description>[9:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>NO_LFSR_FB</name>
              <description>[2:2] 1: Remove XNOR feedback from the main LFSR, converting it into a normal shift register for the XOR-ed outputs of the FROs (shifting data in on the LSB side). A '1' also forces the LFSR to sample continuously. 

This bit can only be set to '1' when TEST_MODE is also set to '1' and should not be used for other than test purposes</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TEST_MODE</name>
              <description>[1:1] 1: Enables access to the TESTCNT and LFSR0/LFSR1/LFSR2 registers (the latter are automatically cleared before enabling access)  and keeps IRQFLAGSTAT.NEED_CLOCK at '1'. 

This bit shall not be used unless you need to change the LFSR seed prior to creating a new random value. All other testing is done external to register control.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CFG0</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Configuration 0</description>
          <fields>
            <field>
              <name>MAX_REFILL_CYCLES</name>
              <description>[31:16] This field determines the maximum number of samples (between 2^8 and 2^24) taken to re-generate entropy from the FROs after reading out a 64 bits random number. If the written value of this field is zero, the number of samples is 2^24, otherwise the number of samples equals the written value times 2^8.

0x0000: 2^24 samples
0x0001: 1*2^8 samples
0x0002: 2*2^8 samples
0x0003: 3*2^8 samples
...
0x8000: 32768*2^8 samples
0xC000: 49152*2^8 samples
...
0xFFFF: 65535*2^8 samples

This field can only be modified while CTL.TRNG_EN is 0.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[15:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>SMPL_DIV</name>
              <description>[11:8] This field directly controls the number of clock cycles between samples taken from the FROs. Default value 0 indicates that samples are taken every clock cycle,
maximum value 0xF takes one sample every 16 clock cycles.
This field must be set to a value such that the slowest FRO (even under worst-case
conditions) has a cycle time less than twice the sample period.

This field can only be modified while CTL.TRNG_EN is '0'.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>MIN_REFILL_CYCLES</name>
              <description>[7:0] This field determines the minimum number of samples (between 2^6 and 2^14) taken to re-generate entropy from the FROs after reading out a 64 bits random number. If the value of this field is zero, the number of samples is fixed to the value determined by the MAX_REFILL_CYCLES field, otherwise the minimum number of samples equals the written value times 64 (which can be up to 2^14). To ensure same entropy in all generated random numbers the value 0 should be used. Then MAX_REFILL_CYCLES controls the minimum refill interval. The number of samples defined here cannot be higher than the number defined by the 'max_refill_cycles' field (i.e. that field takes precedence). No random value will be created if min refill > max refill.

This field can only be modified while CTL.TRNG_EN = 0.

0x00: Minimum samples = MAX_REFILL_CYCLES (all numbers have same entropy)
0x01: 1*2^6 samples
0x02: 2*2^6 samples
...
0xFF: 255*2^6 samples</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ALARMCNT</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Alarm Control</description>
          <fields>
            <field>
              <name>RESERVED30</name>
              <description>[31:30] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>SHUTDOWN_CNT</name>
              <description>[29:24] Read-only, indicates the number of '1' bits in ALARMSTOP register.
The maximum value equals the number of FROs.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>RESERVED21</name>
              <description>[23:21] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>SHUTDOWN_THR</name>
              <description>[20:16] Threshold setting for generating IRQFLAGSTAT.SHUTDOWN_OVF interrupt. The interrupt is triggered when SHUTDOWN_CNT value exceeds this bit field.</description>
              <bitWidth>5</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED8</name>
              <description>[15:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>ALARM_THR</name>
              <description>[7:0] Alarm detection threshold for the repeating pattern detectors on each FRO. An FRO 'alarm event' is declared when a repeating pattern (of up to four samples length) is detected continuously for the number of samples defined by this field's value. Reset value 0xFF should keep the number of 'alarm events' to a manageable level.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFF</resetValue>
        </register>
        <register>
          <name>FROEN</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>FRO Enable</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>FRO_MASK</name>
              <description>[23:0] Enable bits for the individual FROs. A '1' in bit [n] enables FRO 'n'. Default state is all '1's to enable all FROs after power-up. Note that they are not actually started up before the CTL.TRNG_EN bit  is set to '1'.

Bits are automatically forced to '0' here (and cannot be written to '1') while the corresponding bit in  ALARMSTOP.FRO_FLAGS has value '1'.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFF</resetValue>
        </register>
        <register>
          <name>FRODETUNE</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>FRO De-tune Bit</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>FRO_MASK</name>
              <description>[23:0] De-tune bits for the individual FROs. A '1' in bit [n] lets FRO 'n' run approximately 5% faster. The value of one of these bits may only be changed while the corresponding FRO is turned off (by temporarily writing a '0' in the corresponding
bit of the FROEN.FRO_MASK register).</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ALARMMASK</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Alarm Event</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>FRO_MASK</name>
              <description>[23:0] Logging bits for the 'alarm events' of individual FROs. A '1' in bit [n] indicates FRO 'n' experienced an 'alarm event'.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ALARMSTOP</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Alarm Shutdown</description>
          <fields>
            <field>
              <name>RESERVED24</name>
              <description>[31:24] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>FRO_FLAGS</name>
              <description>[23:0] Logging bits for the 'alarm events' of individual FROs. A '1' in bit [n] indicates FRO 'n' experienced more than one 'alarm event' in quick succession and has been turned off. A '1' in this field forces the corresponding bit in FROEN.FRO_MASK to '0'.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>LFSR0</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>LFSR Readout Value</description>
          <fields>
            <field>
              <name>LFSR_31_0</name>
              <description>[31:0] Bits [31:0] of the main entropy accumulation LFSR. Register can only be accessed when CTL.TEST_MODE  = 1.
Register contents will be cleared to zero before access is enabled.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>LFSR1</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>LFSR Readout Value</description>
          <fields>
            <field>
              <name>LFSR_63_32</name>
              <description>[31:0] Bits [63:32] of the main entropy accumulation LFSR. Register can only be accessed when CTL.TEST_MODE = 1. 
Register contents will be cleared to zero before access is enabled.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>LFSR2</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>LFSR Readout Value</description>
          <fields>
            <field>
              <name>RESERVED17</name>
              <description>[31:17] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>15</bitWidth>
              <bitOffset>17</bitOffset>
            </field>
            <field>
              <name>LFSR_80_64</name>
              <description>[16:0] Bits [80:64] of the main entropy accumulation LFSR. Register can only be accessed when CTL.TEST_MODE = 1. 
Register contents will be cleared to zero before access is enabled.</description>
              <bitWidth>17</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>HWOPT</name>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <description>TRNG Engine Options Information</description>
          <fields>
            <field>
              <name>RESERVED12</name>
              <description>[31:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>NR_OF_FROS</name>
              <description>[11:6] Number of FROs implemented in this TRNG, value 24 (decimal).</description>
              <bitWidth>6</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[5:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x600</resetValue>
        </register>
        <register>
          <name>HWVER0</name>
          <addressOffset>0x7c</addressOffset>
          <size>32</size>
          <description>HW Version 0
EIP Number And Core Revision</description>
          <fields>
            <field>
              <name>RESERVED28</name>
              <description>[31:28] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>HW_MAJOR_VER</name>
              <description>[27:24] 4 bits binary encoding of the major hardware revision number.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>24</bitOffset>
            </field>
            <field>
              <name>HW_MINOR_VER</name>
              <description>[23:20] 4 bits binary encoding of the minor hardware revision number.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>20</bitOffset>
            </field>
            <field>
              <name>HW_PATCH_LVL</name>
              <description>[19:16] 4 bits binary encoding of the hardware patch level, initial release will carry value zero.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>EIP_NUM_COMPL</name>
              <description>[15:8] Bit-by-bit logic complement of bits [7:0]. This TRNG gives 0xB4.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>EIP_NUM</name>
              <description>[7:0] 8 bits binary encoding of the module number. This TRNG gives 0x4B.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x200B44B</resetValue>
        </register>
        <register>
          <name>IRQSTATMASK</name>
          <addressOffset>0x1fd8</addressOffset>
          <size>32</size>
          <description>Interrupt Status After Masking</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>SHUTDOWN_OVF</name>
              <description>[1:1] Shutdown Overflow (result of IRQFLAGSTAT.SHUTDOWN_OVF AND'ed with IRQFLAGMASK.SHUTDOWN_OVF)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RDY</name>
              <description>[0:0] New random value available (result of IRQFLAGSTAT.RDY AND'ed with IRQFLAGMASK.RDY)</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>HWVER1</name>
          <addressOffset>0x1fe0</addressOffset>
          <size>32</size>
          <description>HW Version 1
TRNG Revision Number</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>REV</name>
              <description>[7:0] The revision number of this module is Rev 2.0.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x20</resetValue>
        </register>
        <register>
          <name>IRQSET</name>
          <addressOffset>0x1fec</addressOffset>
          <size>32</size>
          <description>Interrupt Set</description>
          <fields>
            <field>
              <name>RDY</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SWRESET</name>
          <addressOffset>0x1ff0</addressOffset>
          <size>32</size>
          <description>SW Reset Control</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESET</name>
              <description>[0:0] Write '1' to soft reset , reset will be low for 4-5 clock cycles. Poll to 0 for reset to be completed.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IRQSTAT</name>
          <addressOffset>0x1ff8</addressOffset>
          <size>32</size>
          <description>Interrupt Status</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STAT</name>
              <description>[0:0] TRNG Interrupt status. OR'ed version of IRQFLAGSTAT.SHUTDOWN_OVF and IRQFLAGSTAT.RDY</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <baseAddress>0x40001000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Universal Asynchronous Receiver/Transmitter (UART) interface</description>
      <registers>
        <register>
          <name>DR</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Data
For words to be transmitted:
  - if the FIFOs are enabled (LCRH.FEN = 1), data written to this location is pushed onto the transmit FIFO
  - if the FIFOs are not enabled (LCRH.FEN = 0), data is stored in the transmitter holding register (the bottom word of the transmit FIFO).
The write operation initiates transmission from the UART. The data is prefixed with a start bit, appended with the appropriate parity bit (if parity is enabled), and a stop bit.
The resultant word is then transmitted.
For received words:
  - if the FIFOs are enabled (LCRH.FEN = 1), the data byte and the 4-bit status (break, frame, parity, and overrun) is pushed onto the 12-bit wide receive FIFO 
  - if the FIFOs are not enabled (LCRH.FEN = 0), the data byte and status are stored in the receiving holding register (the bottom word of the receive FIFO).
The received data byte is read by performing reads from this register along with the corresponding status information. The status information can also be read by a read of the RSR register.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>20</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>OE</name>
              <description>[11:11] UART Overrun Error:
This bit is set to 1 if data is received and the receive FIFO is already full. The FIFO contents remain valid because no more data is written when the FIFO is full, , only the contents of the shift register are overwritten.
This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>BE</name>
              <description>[10:10] UART Break Error:
This bit is set to 1 if a break condition was detected, indicating that the received data input (UARTRXD input pin) was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits).
In FIFO mode, this error is associated with the character at the top of the FIFO (i.e., the oldest received data character since last read). When a break occurs, a 0 character is loaded into the FIFO. The next character is enabled after the receive data input (UARTRXD input pin) goes to a 1 (marking state), and the next valid start bit is received.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>PE</name>
              <description>[9:9] UART Parity Error:
When set to 1, it indicates that the parity of the received data character does not match the parity that the LCRH.EPS and LCRH.SPS select.
In FIFO mode, this error is associated with the character at the top of the FIFO (i.e., the oldest received data character since last read).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>FE</name>
              <description>[8:8] UART Framing Error:
When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1).
In FIFO mode, this error is associated with the character at the top of the FIFO (i.e., the oldest received data character since last read).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>DATA</name>
              <description>[7:0] Data transmitted or received:
On writes, the transmit data character is pushed into the FIFO.
On reads, the oldest received data character since the last read is returned.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RSR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Status
This register is mapped to the same address as ECR register.  Reads from this address are associated with RSR register and return the receive status. Writes to this address are associated with ECR register and clear the receive status flags (framing, parity, break, and overrun errors).
If the status is read from this register, then the status information for break, framing and parity corresponds to the data character read from the Data Register, DR prior to reading the RSR. The status information for overrun is set immediately when an overrun condition occurs.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>OE</name>
              <description>[3:3] UART Overrun Error:
This bit is set to 1 if data is received and the receive FIFO is already full. The FIFO contents remain valid because no more data is written when the FIFO is full, , only the contents of the shift register are overwritten.
This is cleared to 0 once there is an empty space in the FIFO and a new character can be written to it.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>BE</name>
              <description>[2:2] UART Break Error:
This bit is set to 1 if a break condition was detected, indicating that the received data input (UARTRXD input pin) was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits).
When a break occurs, a 0 character is loaded into the FIFO. The next character is enabled after the receive data input (UARTRXD input pin) goes to a 1 (marking state), and the next valid start bit is received.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PE</name>
              <description>[1:1] UART Parity Error:
When set to 1, it indicates that the parity of the received data character does not match the parity that the LCRH.EPS and LCRH.SPS select.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>FE</name>
              <description>[0:0] UART Framing Error:
When set to 1, it indicates that the received character did not have a valid stop bit (a valid stop bit is 1).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ECR</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Error Clear
This register is mapped to the same address as RSR register.  Reads from this address are associated with RSR register and return the receive status. Writes to this address are associated with ECR register and clear the receive status flags (framing, parity, break, and overrun errors).</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:4] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>28</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>OE</name>
              <description>[3:3] The framing (FE), parity (PE), break (BE) and overrun (OE) errors are cleared to 0 by any write to this register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>BE</name>
              <description>[2:2] The framing (FE), parity (PE), break (BE) and overrun (OE) errors are cleared to 0 by any write to this register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>PE</name>
              <description>[1:1] The framing (FE), parity (PE), break (BE) and overrun (OE) errors are cleared to 0 by any write to this register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>FE</name>
              <description>[0:0] The framing (FE), parity (PE), break (BE) and overrun (OE) errors are cleared to 0 by any write to this register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED0</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FR</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Flag
Reads from this register return the UART flags.</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>TXFE</name>
              <description>[7:7] UART Transmit FIFO Empty:
The meaning of this bit depends on the state of LCRH.FEN .
  - If the FIFO is disabled, this bit is set when the transmit holding register is empty.
  - If the FIFO is enabled, this bit is set when the transmit FIFO is empty.
This bit does not indicate if there is data in the transmit shift register.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RXFF</name>
              <description>[6:6] UART Receive FIFO Full: 
The meaning of this bit depends on the state of LCRH.FEN.
  - If the FIFO is disabled, this bit is set when the receive holding register is full.
  - If the FIFO is enabled, this bit is set when the receive FIFO is full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXFF</name>
              <description>[5:5] UART Transmit FIFO Full:
Transmit FIFO full. The meaning of this bit depends on the state of LCRH.FEN.
  - If the FIFO is disabled, this bit is set when the transmit holding register is full.
  - If the FIFO is enabled, this bit is set when the transmit FIFO is full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXFE</name>
              <description>[4:4] UART Receive FIFO Empty:
Receive FIFO empty. The meaning of this bit depends on the state of LCRH.FEN.
  - If the FIFO is disabled, this bit is set when the receive holding register is empty.
  - If the FIFO is enabled, this bit is set when the receive FIFO is empty.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>BUSY</name>
              <description>[3:3] UART Busy: 
If this bit is set to 1, the UART is busy transmitting data. This bit remains set until the complete byte, including all the stop bits, has been sent from the shift register.
This bit is set as soon as the transmit FIFO becomes non-empty, regardless of whether the UART is enabled or not.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[2:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CTS</name>
              <description>[0:0] Clear To Send: 
This bit is the complement of the active-low UART CTS input pin.
That is, the bit is 1 when CTS input pin is LOW.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x90</resetValue>
        </register>
        <register>
          <name>RESERVED2</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>IBRD</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Integer Baud-Rate Divisor
If this register is modified while trasmission or reception is on-going, the baudrate will not be updated until transmission or reception of the current character is complete.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>DIVINT</name>
              <description>[15:0] The integer baud rate divisor:
The baud rate divisor is calculated using the formula below:
Baud rate divisor = (UART reference clock frequency) / (16 * Baud rate)
Baud rate divisor must be minimum 1 and maximum 65535. 
That is, DIVINT=0 does not give a valid baud rate. 
Similarly, if DIVINT=0xFFFF, any non-zero values in FBRD.DIVFRAC will be illegal.
A valid value must be written to this field before the UART can be used for RX or TX operations.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>FBRD</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Fractional Baud-Rate Divisor
If this register is modified while trasmission or reception is on-going, the baudrate will not be updated until transmission or reception of the current character is complete.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>DIVFRAC</name>
              <description>[5:0] Fractional Baud-Rate Divisor:
The baud rate divisor is calculated using the formula below:
Baud rate divisor = (UART reference clock frequency) / (16 * Baud rate)
Baud rate divisor must be minimum 1 and maximum 65535. 
That is, IBRD.DIVINT=0 does not give a valid baud rate. 
Similarly, if IBRD.DIVINT=0xFFFF, any non-zero values in DIVFRAC will be illegal.
A valid value must be written to this field before the UART can be used for RX or TX operations.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>LCRH</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Line Control</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>SPS</name>
              <description>[7:7] UART Stick Parity Select:

0: Stick parity is disabled
1: The parity bit is transmitted and checked as invert of EPS field (i.e. the parity bit is transmitted and checked as 1 when EPS = 0).

This bit has no effect when PEN disables parity checking and generation.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>WLEN</name>
              <description>[6:5] UART Word Length:
These bits indicate the number of data bits transmitted or received in a frame.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>5</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>8</name>
                  <value>3</value>
                  <description>Word Length 8 bits</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>7</name>
                  <value>2</value>
                  <description>Word Length 7 bits</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>6</name>
                  <value>1</value>
                  <description>Word Length 6 bits</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>5</name>
                  <value>0</value>
                  <description>Word Length 5 bits</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FEN</name>
              <description>[4:4] UART Enable FIFOs</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Transmit and receive FIFO buffers are enabled (FIFO mode)</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>FIFOs are disabled (character mode) that is, the FIFOs become 1-byte-deep holding registers.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STP2</name>
              <description>[3:3] UART Two Stop Bits Select:
If this bit is set to 1, two stop bits are transmitted at the end of the frame. The receive logic does not check for two stop bits being received.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>EPS</name>
              <description>[2:2] UART Even Parity Select</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EVEN</name>
                  <value>1</value>
                  <description>Even parity: The UART generates or checks for an even number of 1s in the data and parity bits.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ODD</name>
                  <value>0</value>
                  <description>Odd parity: The UART generates or checks for an odd number of 1s in the data and parity bits.</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PEN</name>
              <description>[1:1] UART Parity Enable
This bit controls generation and checking of parity bit.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Parity checking and generation is enabled.</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Parity is disabled and no parity bit is added to the data frame</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BRK</name>
              <description>[0:0] UART Send Break
If this bit is set to 1, a low-level is continually output on the UARTTXD output pin, after completing transmission of the current character. For the proper execution of the break command, the
software must set this bit for at least two complete frames. For normal use, this bit must be cleared to 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Control</description>
          <fields>
            <field>
              <name>RESERVED16</name>
              <description>[31:16] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>16</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>CTSEN</name>
              <description>[15:15] CTS hardware flow control enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>15</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>CTS hardware flow control enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>CTS hardware flow control disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RTSEN</name>
              <description>[14:14] RTS hardware flow control enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>14</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>RTS hardware flow control enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>RTS hardware flow control disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED12</name>
              <description>[13:12] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>12</bitOffset>
            </field>
            <field>
              <name>RTS</name>
              <description>[11:11] Request to Send
This bit is the complement of the active-low UART RTS output. That is, when the bit is programmed to a 1 then RTS output on the pins is LOW.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>RESERVED10</name>
              <description>[10:10] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RXE</name>
              <description>[9:9] UART Receive Enable
If the UART is disabled in the middle of reception, it completes the current character before stopping.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>UART Receive enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>UART Receive disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXE</name>
              <description>[8:8] UART Transmit Enable
If the UART is disabled in the middle of transmission, it completes the current character before stopping.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>UART Transmit enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>UART Transmit disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LBE</name>
              <description>[7:7] UART Loop Back Enable:
Enabling the loop-back mode connects the UARTTXD output from the UART to UARTRXD input of the UART.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Loop Back enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Loop Back disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[6:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>6</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>UARTEN</name>
              <description>[0:0] UART Enable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>UART enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>UART disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x300</resetValue>
        </register>
        <register>
          <name>IFLS</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Interrupt FIFO Level Select</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>RXSEL</name>
              <description>[5:3] Receive interrupt FIFO level select:
This field sets the trigger points for the receive interrupt. Values 0b101-0b111 are reserved.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>3</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>7_8</name>
                  <value>4</value>
                  <description>Receive FIFO becomes >= 7/8 full</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>6_8</name>
                  <value>3</value>
                  <description>Receive FIFO becomes >= 3/4 full</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4_8</name>
                  <value>2</value>
                  <description>Receive FIFO becomes >= 1/2 full</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2_8</name>
                  <value>1</value>
                  <description>Receive FIFO becomes >= 1/4 full</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1_8</name>
                  <value>0</value>
                  <description>Receive FIFO becomes >= 1/8 full</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TXSEL</name>
              <description>[2:0] Transmit interrupt FIFO level select:
This field sets the trigger points for the transmit interrupt. Values 0b101-0b111 are reserved.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>7_8</name>
                  <value>4</value>
                  <description>Transmit FIFO becomes &lt;= 7/8 full</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>6_8</name>
                  <value>3</value>
                  <description>Transmit FIFO becomes &lt;= 3/4 full</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4_8</name>
                  <value>2</value>
                  <description>Transmit FIFO becomes &lt;= 1/2 full</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>2_8</name>
                  <value>1</value>
                  <description>Transmit FIFO becomes &lt;= 1/4 full</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>1_8</name>
                  <value>0</value>
                  <description>Transmit FIFO becomes &lt;= 1/8 full</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x12</resetValue>
        </register>
        <register>
          <name>IMSC</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Interrupt Mask Set/Clear</description>
          <fields>
            <field>
              <name>RESERVED11</name>
              <description>[31:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OEIM</name>
              <description>[10:10] Overrun error interrupt mask. A read returns the current mask for UART's overrun error interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.OEMIS. A write of 0 clears the mask which means MIS.OEMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BEIM</name>
              <description>[9:9] Break error interrupt mask. A read returns the current mask for UART's break error interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.BEMIS. A write of 0 clears the mask which means MIS.BEMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PEIM</name>
              <description>[8:8] Parity error interrupt mask. A read returns the current mask for UART's parity error interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.PEMIS. A write of 0 clears the mask which means MIS.PEMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FEIM</name>
              <description>[7:7] Framing error interrupt mask. A read returns the current mask for UART's framing error interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.FEMIS. A write of 0 clears the mask which means MIS.FEMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RTIM</name>
              <description>[6:6] Receive timeout interrupt mask. A read returns the current mask for UART's receive timeout interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.RTMIS. A write of 0 clears the mask which means this bitfield will not reflect the interrupt. 
The raw interrupt for receive timeout RIS.RTRIS cannot be set unless the mask is set (RTIM = 1). This is because the mask acts as an enable for power saving. That is, the same status can be read from MIS.RTMIS and RIS.RTRIS.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXIM</name>
              <description>[5:5] Transmit interrupt mask. A read returns the current mask for UART's transmit interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.TXMIS. A write of 0 clears the mask which means MIS.TXMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXIM</name>
              <description>[4:4] Receive interrupt mask. A read returns the current mask for UART's receive interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.RXMIS. A write of 0 clears the mask which means MIS.RXMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[3:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CTSMIM</name>
              <description>[1:1] Clear to Send (CTS) modem interrupt mask. A read returns the current mask for UART's clear to send interrupt. On a write of 1, the mask of the overrun error interrupt is set which means the interrupt state will be reflected in MIS.CTSMMIS. A write of 0 clears the mask which means MIS.CTSMMIS will not reflect the interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Raw Interrupt Status</description>
          <fields>
            <field>
              <name>RESERVED11</name>
              <description>[31:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OERIS</name>
              <description>[10:10] Overrun error interrupt status: 
This field returns the raw interrupt state of UART's overrun error interrupt. Overrun error occurs if data is received and the receive FIFO is full.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BERIS</name>
              <description>[9:9] Break error interrupt status:
This field returns the raw interrupt state of UART's break error interrupt. Break error is set when a break condition is detected, indicating that the received data input (UARTRXD input pin) was held LOW for longer than a full-word transmission time (defined as start, data, parity and stop bits).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PERIS</name>
              <description>[8:8] Parity error interrupt status:
This field returns the raw interrupt state of UART's parity error interrupt. Parity error is set if the parity of the received data character does not match the parity that the LCRH.EPS and LCRH.SPS select.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FERIS</name>
              <description>[7:7] Framing error interrupt status:
This field returns the raw interrupt state of UART's framing error interrupt. Framing error is set if the received character does not have a valid stop bit (a valid stop bit is 1).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RTRIS</name>
              <description>[6:6] Receive timeout interrupt status:
This field returns the raw interrupt state of UART's receive timeout interrupt. The receive timeout interrupt is asserted when the receive FIFO is not empty, and no more data is received during a 32-bit period. The receive timeout interrupt is cleared either when the FIFO becomes empty through reading all the data, or when a 1 is written to ICR.RTIC.
The raw interrupt for receive timeout cannot be set unless the mask is set (IMSC.RTIM = 1). This is because the mask acts as an enable for power saving. That is, the same status can be read from MIS.RTMIS and RTRIS.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXRIS</name>
              <description>[5:5] Transmit interrupt status: 
This field returns the raw interrupt state of UART's transmit interrupt.
When FIFOs are enabled (LCRH.FEN = 1), the transmit interrupt is asserted if the number of bytes in transmit FIFO is equal to or lower than the programmed trigger level (IFLS.TXSEL). The transmit interrupt is cleared by writing data to the transmit FIFO until it becomes greater than the trigger level, or by clearing the interrupt through ICR.TXIC.
When FIFOs are disabled (LCRH.FEN = 0), that is they have a depth of one location, the transmit interrupt is asserted if there is no data present in the transmitters single location. It is cleared by performing a single write to the transmit FIFO, or by clearing the interrupt through ICR.TXIC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXRIS</name>
              <description>[4:4] Receive interrupt status:
This field returns the raw interrupt state of UART's receive interrupt. 
When FIFOs are enabled (LCRH.FEN = 1), the receive interrupt is asserted if the receive FIFO reaches the programmed trigger
level (IFLS.RXSEL). The receive interrupt is cleared by reading data from the receive FIFO until it becomes less than the trigger level, or by clearing the interrupt through ICR.RXIC.
When FIFOs are disabled (LCRH.FEN = 0), that is they have a depth of one location, the receive interrupt is asserted if data is received
thereby filling the location. The receive interrupt is cleared by performing a single read of the receive FIFO, or by clearing the interrupt through ICR.RXIC.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[3:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CTSRMIS</name>
              <description>[1:1] Clear to Send (CTS) modem interrupt status: 
This field returns the raw interrupt state of UART's clear to send interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xD</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <description>Masked Interrupt Status</description>
          <fields>
            <field>
              <name>RESERVED11</name>
              <description>[31:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OEMIS</name>
              <description>[10:10] Overrun error masked interrupt status: 
This field returns the masked interrupt state of the overrun interrupt which is the AND product of raw interrupt state RIS.OERIS and the mask setting IMSC.OEIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BEMIS</name>
              <description>[9:9] Break error masked interrupt status: 
This field returns the masked interrupt state of the break error interrupt which is the AND product of raw interrupt state RIS.BERIS and the mask setting IMSC.BEIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PEMIS</name>
              <description>[8:8] Parity error masked interrupt status:
This field returns the masked interrupt state of the parity error interrupt which is the AND product of raw interrupt state RIS.PERIS and the mask setting IMSC.PEIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FEMIS</name>
              <description>[7:7] Framing error masked interrupt status: Returns the masked interrupt state of the framing error interrupt which is the AND product of raw interrupt state RIS.FERIS and the mask setting IMSC.FEIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RTMIS</name>
              <description>[6:6] Receive timeout masked interrupt status: 
Returns the masked interrupt state of the receive timeout interrupt.
The raw interrupt for receive timeout cannot be set unless the mask is set (IMSC.RTIM = 1). This is because the mask acts as an enable for power saving. That is, the same status can be read from RTMIS and RIS.RTRIS.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXMIS</name>
              <description>[5:5] Transmit masked interrupt status: 
This field returns the masked interrupt state of the transmit interrupt  which is the AND product of raw interrupt state RIS.TXRIS and the mask setting IMSC.TXIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXMIS</name>
              <description>[4:4] Receive masked interrupt status:
This field returns the masked interrupt state of the receive interrupt  which is the AND product of raw interrupt state RIS.RXRIS and the mask setting IMSC.RXIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[3:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CTSMMIS</name>
              <description>[1:1] Clear to Send (CTS) modem masked interrupt status:
This field returns the masked interrupt state of the clear to send interrupt which is the AND product of raw interrupt state RIS.CTSRMIS and the mask setting IMSC.CTSMIM.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <description>Interrupt Clear
On a write of 1, the corresponding interrupt is cleared. A write of 0 has no effect.</description>
          <fields>
            <field>
              <name>RESERVED11</name>
              <description>[31:11] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>21</bitWidth>
              <bitOffset>11</bitOffset>
            </field>
            <field>
              <name>OEIC</name>
              <description>[10:10] Overrun error interrupt clear:
Writing 1 to this field clears the overrun error interrupt (RIS.OERIS). Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>BEIC</name>
              <description>[9:9] Break error interrupt clear:
Writing 1 to this field clears the break error interrupt (RIS.BERIS). Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>PEIC</name>
              <description>[8:8] Parity error interrupt clear:
Writing 1 to this field clears the parity error interrupt (RIS.PERIS). Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>FEIC</name>
              <description>[7:7] Framing error interrupt clear:
Writing 1 to this field clears the framing error interrupt (RIS.FERIS). Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>7</bitOffset>
            </field>
            <field>
              <name>RTIC</name>
              <description>[6:6] Receive timeout interrupt clear:
Writing 1 to this field clears the receive timeout interrupt (RIS.RTRIS). Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>TXIC</name>
              <description>[5:5] Transmit interrupt clear:
Writing 1 to this field clears the transmit interrupt (RIS.TXRIS). Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RXIC</name>
              <description>[4:4] Receive interrupt clear:
Writing 1 to this field clears the receive interrupt (RIS.RXRIS). Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED2</name>
              <description>[3:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior. Write 0</description>
              <bitWidth>2</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CTSMIC</name>
              <description>[1:1] Clear to Send (CTS) modem interrupt clear:
Writing 1 to this field clears the clear to send interrupt (RIS.CTSRMIS). Writing 0 has no effect.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[0:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior. Write 0.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DMACTL</name>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <description>DMA Control</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>DMAONERR</name>
              <description>[2:2] DMA on error. If this bit is set to 1, the DMA receive request outputs (for  single and burst requests) are disabled when the UART error interrupt is asserted (more specifically if any of the error interrupts RIS.PERIS, RIS.BERIS, RIS.FERIS or RIS.OERIS are asserted).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>TXDMAE</name>
              <description>[1:1] Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>RXDMAE</name>
              <description>[0:0] Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is enabled.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED1</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED3</name>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RESERVED4</name>
          <addressOffset>0xfd0</addressOffset>
          <size>32</size>
          <description>Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UDMA0</name>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>ARM Micro Direct Memory Access Controller</description>
      <registers>
        <register>
          <name>STATUS</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Status</description>
          <fields>
            <field>
              <name>TEST</name>
              <description>[31:28] 0x0: Controller does not include the integration test logic
0x1: Controller includes the integration test logic
0x2: Undefined
...
0xF: Undefined</description>
              <bitWidth>4</bitWidth>
              <bitOffset>28</bitOffset>
            </field>
            <field>
              <name>RESERVED21</name>
              <description>[27:21] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>21</bitOffset>
            </field>
            <field>
              <name>TOTALCHANNELS</name>
              <description>[20:16] Register value returns number of available uDMA channels minus one. For example a read out value of:

0x00: Show that the controller is configured to use 1 uDMA channel
0x01: Shows that the controller is configured to use 2 uDMA channels
...
0x1F: Shows that the controller is configured to use 32 uDMA channels (32-1=31=0x1F)</description>
              <bitWidth>5</bitWidth>
              <bitOffset>16</bitOffset>
            </field>
            <field>
              <name>RESERVED8</name>
              <description>[15:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>8</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>STATE</name>
              <description>[7:4] Current state of the control state machine. State can be one of the following:

0x0: Idle
0x1: Reading channel controller data
0x2: Reading source data end pointer
0x3: Reading destination data end pointer
0x4: Reading source data
0x5: Writing destination data
0x6: Waiting for uDMA request to clear
0x7: Writing channel controller data
0x8: Stalled
0x9: Done
0xA: Peripheral scatter-gather transition
0xB: Undefined
...
0xF: Undefined.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[3:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MASTERENABLE</name>
              <description>[0:0] Shows the enable status of the controller as configured by CFG.MASTERENABLE:

0: Controller is disabled
1: Controller is enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x1F0000</resetValue>
        </register>
        <register>
          <name>CFG</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Configuration</description>
          <fields>
            <field>
              <name>RESERVED8</name>
              <description>[31:8] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>24</bitWidth>
              <bitOffset>8</bitOffset>
            </field>
            <field>
              <name>PRTOCTRL</name>
              <description>[7:5] Sets the AHB-Lite bus protocol protection state by controlling the AHB signal HProt[3:1] as follows:

Bit [7] Controls HProt[3] to indicate if a cacheable access is occurring.
Bit [6] Controls HProt[2] to indicate if a bufferable access is occurring.
Bit [5] Controls HProt[1] to indicate if a privileged access is occurring.

When bit [n] = 1 then the corresponding HProt bit is high.
When bit [n] = 0 then the corresponding HProt bit is low.

This field controls HProt[3:1] signal for all transactions initiated by uDMA except two transactions below:
- the read from the address indicated by source address pointer
- the write to the address indicated by destination address pointer
HProt[3:1] for these two exceptions can be controlled by dedicated fields in the channel configutation descriptor.</description>
              <bitWidth>3</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[4:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>4</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>MASTERENABLE</name>
              <description>[0:0] Enables the controller:

0: Disables the controller
1: Enables the controller</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CTRL</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Channel Control Data Base Pointer</description>
          <fields>
            <field>
              <name>BASEPTR</name>
              <description>[31:10] This register point to the base address for the primary data structures of each DMA channel. This is not stored in module, but in system memory, thus space must be allocated for this usage when DMA is in usage</description>
              <bitWidth>22</bitWidth>
              <bitOffset>10</bitOffset>
            </field>
            <field>
              <name>RESERVED0</name>
              <description>[9:0] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>10</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ALTCTRL</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Channel Alternate Control Data Base Pointer</description>
          <fields>
            <field>
              <name>BASEPTR</name>
              <description>[31:0] This register shows the base address for the alternate data structures and is calculated by module, thus read only</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x200</resetValue>
        </register>
        <register>
          <name>WAITONREQ</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Channel Wait On Request Status</description>
          <fields>
            <field>
              <name>CHNLSTATUS</name>
              <description>[31:0] Channel wait on request status:

Bit [Ch] = 0: Once uDMA receives a single or burst request on channel Ch, this channel may come out of active state even if request is still present.
Bit [Ch] = 1: Once uDMA receives a single or burst request on channel Ch, it keeps channel Ch in active state until the requests are deasserted. This handshake is necessary for channels where the requester is in an asynchronous domain or can run at slower clock speed than uDMA</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFF1EFF</resetValue>
        </register>
        <register>
          <name>SOFTREQ</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Channel Software Request</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Set the appropriate bit to generate a software uDMA request on the corresponding uDMA channel

Bit [Ch] = 0: Does not create a uDMA request for channel Ch
Bit [Ch] = 1: Creates a uDMA request for channel Ch

Writing to a bit where a uDMA channel is not implemented does not create a uDMA request for that channel</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SETBURST</name>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <description>Channel Set UseBurst</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Returns the useburst status, or disables individual channels from generating single uDMA requests. The value R is the arbitration rate and stored in the controller data structure. 

Read as:

Bit [Ch] = 0: uDMA channel Ch responds to both burst and single requests on channel C. The controller performs 2^R, or single, bus transfers.

Bit [Ch] = 1: uDMA channel Ch does not respond to single transfer requests. The controller only responds to burst transfer requests and performs 2^R transfers.

Write as:
Bit [Ch] = 0: No effect. Use the CLEARBURST.CHNLS to set bit [Ch] to 0.
Bit [Ch] = 1: Disables single transfer requests on channel Ch. The controller performs 2^R transfers for burst requests.

Writing to a bit where a uDMA channel is not implemented has no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CLEARBURST</name>
          <addressOffset>0x1c</addressOffset>
          <size>32</size>
          <description>Channel Clear UseBurst</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Set the appropriate bit to enable single transfer requests. 

Write as:

Bit [Ch] = 0: No effect. Use the SETBURST.CHNLS to disable single transfer requests.

Bit [Ch] = 1: Enables single transfer requests on channel Ch.

Writing to a bit where a DMA channel is not implemented has no effect.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SETREQMASK</name>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <description>Channel Set Request Mask</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Returns the burst and single request mask status, or disables the corresponding channel from generating uDMA requests. 

Read as:
Bit [Ch] = 0: External requests are enabled for channel Ch.
Bit [Ch] = 1: External requests are disabled for channel Ch.

Write as:
Bit [Ch] = 0: No effect. Use the CLEARREQMASK.CHNLS to enable uDMA requests.
Bit [Ch] = 1: Disables uDMA burst request channel [C] and uDMA single request channel [C] input from generating uDMA requests.

Writing to a bit where a uDMA channel is not implemented has no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CLEARREQMASK</name>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <description>Clear Channel Request Mask</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Set the appropriate bit to enable DMA request for the channel. 

Write as:
Bit [Ch] = 0: No effect. Use the SETREQMASK.CHNLS to disable channel C from generating requests.
Bit [Ch] = 1: Enables channel [C] to generate DMA requests.

Writing to a bit where a DMA channel is not implemented has no effect.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SETCHANNELEN</name>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <description>Set Channel Enable</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Returns the enable status of the channels, or enables the corresponding channels. 

Read as:
Bit [Ch] = 0: Channel Ch is disabled.
Bit [Ch] = 1: Channel Ch is enabled.

Write as:
Bit [Ch] = 0: No effect. Use the CLEARCHANNELEN.CHNLS to disable a channel
Bit [Ch] = 1: Enables channel Ch

Writing to a bit where a DMA channel is not implemented has no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CLEARCHANNELEN</name>
          <addressOffset>0x2c</addressOffset>
          <size>32</size>
          <description>Clear Channel Enable</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Set the appropriate bit to disable the corresponding uDMA channel. 

Write as:
Bit [Ch] = 0: No effect. Use the SETCHANNELEN.CHNLS to enable uDMA channels.
Bit [Ch] = 1: Disables channel Ch

Writing to a bit where a uDMA channel is not implemented has no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SETCHNLPRIALT</name>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <description>Channel Set Primary-Alternate</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Returns the channel control data structure status, or selects the alternate data structure for the corresponding uDMA channel. 

Read as:
Bit [Ch] = 0: uDMA channel Ch is using the primary data structure.
Bit [Ch] = 1: uDMA channel Ch is using the alternate data structure.

Write as:
Bit [Ch] = 0: No effect. Use the CLEARCHNLPRIALT.CHNLS to disable a channel
Bit [Ch] = 1: Selects the alternate data structure for channel Ch

Writing to a bit where a uDMA channel is not implemented has no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CLEARCHNLPRIALT</name>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <description>Channel Clear Primary-Alternate</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Clears the appropriate bit to select the primary data structure for the corresponding uDMA channel.

Write as:
Bit [Ch] = 0: No effect. Use the SETCHNLPRIALT.CHNLS to select the alternate data structure.
Bit [Ch] = 1: Selects the primary data structure for channel Ch.

Writing to a bit where a uDMA channel is not implemented has no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>SETCHNLPRIORITY</name>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <description>Set Channel Priority</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Returns the channel priority mask status, or sets the channel priority to high. 

Read as:
Bit [Ch] = 0: uDMA channel Ch is using the default priority level.
Bit [Ch] = 1: uDMA channel Ch is using a high priority level.

Write as:
Bit [Ch] = 0: No effect. Use the CLEARCHNLPRIORITY.CHNLS to set channel Ch to the default priority level.
Bit [Ch] = 1: Channel Ch uses the high priority level.

Writing to a bit where a uDMA channel is not implemented has no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CLEARCHNLPRIORITY</name>
          <addressOffset>0x3c</addressOffset>
          <size>32</size>
          <description>Clear Channel Priority</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Clear the appropriate bit to select the default priority level for the specified uDMA channel.

Write as:
Bit [Ch] = 0: No effect. Use the SETCHNLPRIORITY.CHNLS to set channel Ch to the high priority level.
Bit [Ch] = 1: Channel Ch uses the default priority level.

Writing to a bit where a uDMA channel is not implemented has no effect</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ERROR</name>
          <addressOffset>0x4c</addressOffset>
          <size>32</size>
          <description>Error Status and Clear</description>
          <fields>
            <field>
              <name>RESERVED</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>STATUS</name>
              <description>[0:0] Returns the status of bus error flag in uDMA, or clears this bit 

Read as:

0: No bus error detected
1: Bus error detected

Write as:

0: No effect, status of bus error flag is unchanged.
1: Clears the bus error flag.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>REQDONE</name>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <description>Channel Request Done</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Reflects the uDMA done status for the given channel, channel [Ch]. It's a sticky done bit. Unless cleared by writing a 1, it holds the value of 1.

Read as:
Bit [Ch] = 0: Request has not completed for channel Ch
Bit [Ch] = 1: Request has completed for the channel Ch

Writing a 1 to individual bits would clear the corresponding bit. 

Write as:
Bit [Ch] = 0: No effect.
Bit [Ch] = 1: The corresponding [Ch] bit is cleared  and is set to 0</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>DONEMASK</name>
          <addressOffset>0x520</addressOffset>
          <size>32</size>
          <description>Channel Request Done Mask</description>
          <fields>
            <field>
              <name>CHNLS</name>
              <description>[31:0] Controls the propagation of the uDMA done and active state to the assigned peripheral. Specifically used for software channels.

Read as:
Bit [Ch] = 0: uDMA done and active state for channel Ch is not blocked from reaching to the peripherals. 
Note that the uDMA done state for channel [Ch] is blocked from contributing to generation of combined uDMA done signal

Bit [Ch] = 1: uDMA done and active state for channel Ch is blocked from reaching to the peripherals. 
Note that the uDMA done state for channel [Ch] is not blocked from contributing to generation of combined uDMA done signal 

Write as:
Bit [Ch] = 0: Allows uDMA done and active stat to propagate to the peripherals. 
Note that this disables uDMA done state for channel [Ch] from contributing to generation of combined uDMA done signal

Bit [Ch] = 1: Blocks uDMA done and active state to propagate to the peripherals. 
Note that this enables uDMA done for  channel [Ch] to contribute to generation of combined uDMA done signal.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>VIMS</name>
      <baseAddress>0x40034000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x400</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Versatile Instruction Memory System
Controls memory access to the Flash and encapsulates the following instruction memories:
- Boot ROM
- Cache / GPRAM</description>
      <registers>
        <register>
          <name>STAT</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Status
Displays current VIMS mode and line buffer status</description>
          <fields>
            <field>
              <name>RESERVED6</name>
              <description>[31:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>26</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>IDCODE_LB_DIS</name>
              <description>[5:5] Icode/Dcode flash line buffer status

0: Enabled or in transition to disabled
1: Disabled and flushed</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>SYSBUS_LB_DIS</name>
              <description>[4:4] Sysbus flash line buffer control

0: Enabled or in transition to disabled
1: Disabled and flushed</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>MODE_CHANGING</name>
              <description>[3:3] VIMS mode change status

0: VIMS is in the mode defined by MODE
1: VIMS is in the process of changing to the mode given in CTL.MODE</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>INV</name>
              <description>[2:2] This bit is set when invalidation of the cache memory is active / ongoing</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MODE</name>
              <description>[1:0] Current VIMS mode</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <value>3</value>
                  <description>VIMS Off mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CACHE</name>
                  <value>1</value>
                  <description>VIMS Cache mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPRAM</name>
                  <value>0</value>
                  <description>VIMS GPRAM mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Control
Configure VIMS mode and line buffer settings</description>
          <fields>
            <field>
              <name>STATS_CLR</name>
              <description>[31:31] Set this bit to clear statistic counters.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>31</bitOffset>
            </field>
            <field>
              <name>STATS_EN</name>
              <description>[30:30] Set this bit to enable statistic counters.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>30</bitOffset>
            </field>
            <field>
              <name>DYN_CG_EN</name>
              <description>[29:29] 0: The in-built clock gate functionality is bypassed.
1: The in-built clock gate functionality is enabled, automatically gating the clock when not needed.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>29</bitOffset>
            </field>
            <field>
              <name>RESERVED6</name>
              <description>[28:6] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>6</bitOffset>
            </field>
            <field>
              <name>IDCODE_LB_DIS</name>
              <description>[5:5] Icode/Dcode flash line buffer control

0: Enable
1: Disable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>5</bitOffset>
            </field>
            <field>
              <name>SYSBUS_LB_DIS</name>
              <description>[4:4] Sysbus flash line buffer control

0: Enable
1: Disable</description>
              <bitWidth>1</bitWidth>
              <bitOffset>4</bitOffset>
            </field>
            <field>
              <name>ARB_CFG</name>
              <description>[3:3] Icode/Dcode and sysbus arbitation scheme

0: Static arbitration  (icode/docde > sysbus)
1: Round-robin arbitration</description>
              <bitWidth>1</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>[2:2] Tag prefetch control

0: Disabled
1: Enabled</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>MODE</name>
              <description>[1:0] VIMS mode request.
Write accesses to this field will be blocked while STAT.MODE_CHANGING is set to 1.
Note: Transaction from CACHE mode to GPRAM mode should be done through OFF mode to minimize flash block delay.</description>
              <bitWidth>2</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <value>3</value>
                  <description>VIMS Off mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CACHE</name>
                  <value>1</value>
                  <description>VIMS Cache mode</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GPRAM</name>
                  <value>0</value>
                  <description>VIMS GPRAM mode</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT</name>
      <baseAddress>0x40080000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <description>Watchdog Timer</description>
      <registers>
        <register>
          <name>LOAD</name>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <description>Configuration</description>
          <fields>
            <field>
              <name>WDTLOAD</name>
              <description>[31:0] This register is the 32-bit interval value used by the 32-bit counter. When this register is written, the value is immediately loaded and the counter is restarted to count down from the new value. If this register is loaded with 0x0000.0000, an interrupt is immediately generated.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>VALUE</name>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <description>Current Count Value</description>
          <fields>
            <field>
              <name>WDTVALUE</name>
              <description>[31:0] This register contains the current count value of the timer.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0xFFFFFFFF</resetValue>
        </register>
        <register>
          <name>CTL</name>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <description>Control</description>
          <fields>
            <field>
              <name>RESERVED3</name>
              <description>[31:3] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>29</bitWidth>
              <bitOffset>3</bitOffset>
            </field>
            <field>
              <name>INTTYPE</name>
              <description>[2:2] WDT Interrupt Type

0:  WDT interrupt is a standard interrupt.  
1:  WDT interrupt is a non-maskable interrupt.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>2</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NONMASKABLE</name>
                  <value>1</value>
                  <description>Non-maskable interrupt</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MASKABLE</name>
                  <value>0</value>
                  <description>Maskable interrupt</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESEN</name>
              <description>[1:1] WDT Reset Enable. Defines the function of the WDT reset source (see PRCM:WARMRESET.WDT_STAT if enabled)

0:  Disabled.  
1:  Enable the Watchdog reset output.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Reset output Enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Reset output Disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INTEN</name>
              <description>[0:0] WDT Interrupt Enable

0: Interrupt event disabled.  
1: Interrupt event enabled. Once set, this bit can only be cleared by a hardware reset.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Interrupt Enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Interrupt Disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>ICR</name>
          <addressOffset>0xc</addressOffset>
          <size>32</size>
          <description>Interrupt Clear</description>
          <fields>
            <field>
              <name>WDTICR</name>
              <description>[31:0] This register is the interrupt clear register. A write of any value to this register clears the WDT interrupt and reloads the 32-bit counter from the LOAD register.</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>RIS</name>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <description>Raw Interrupt Status</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>WDTRIS</name>
              <description>[0:0] This register is the raw interrupt status register. WDT interrupt events can be monitored via this register if the controller interrupt is masked.

Value Description

0: The WDT has not timed out
1: A WDT time-out event has occurred</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>MIS</name>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <description>Masked Interrupt Status</description>
          <fields>
            <field>
              <name>RESERVED1</name>
              <description>[31:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>31</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>WDTMIS</name>
              <description>[0:0] This register is the masked interrupt status register. The value of this register is the logical AND of the raw interrupt bit and the WDT interrupt enable bit CTL.INTEN. 

Value Description 

0: The WDT has not timed out or is masked.
1: An unmasked WDT time-out event has occurred.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>TEST</name>
          <addressOffset>0x418</addressOffset>
          <size>32</size>
          <description>Test Mode</description>
          <fields>
            <field>
              <name>RESERVED9</name>
              <description>[31:9] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>23</bitWidth>
              <bitOffset>9</bitOffset>
            </field>
            <field>
              <name>STALL</name>
              <description>[8:8] WDT Stall Enable

0:  The WDT timer continues counting if the CPU is stopped with a debugger.
1:  If the CPU is stopped with a debugger, the WDT stops counting. Once the CPU is restarted, the WDT resumes counting.</description>
              <bitWidth>1</bitWidth>
              <bitOffset>8</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Enable STALL</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Disable STALL</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RESERVED1</name>
              <description>[7:1] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>7</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>TEST_EN</name>
              <description>[0:0] The test enable bit 

0: Enable external reset
1: Disables the generation of an external reset. Instead bit 1 of the INT_CAUS register is set and an interrupt is generated</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
              <enumeratedValues>
                <enumeratedValue>
                  <name>EN</name>
                  <value>1</value>
                  <description>Test mode Enabled</description>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIS</name>
                  <value>0</value>
                  <description>Test mode Disabled</description>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>INT_CAUS</name>
          <addressOffset>0x41c</addressOffset>
          <size>32</size>
          <description>Interrupt Cause Test Mode</description>
          <fields>
            <field>
              <name>RESERVED2</name>
              <description>[31:2] Software should not rely on the value of a reserved. Writing any other value than the reset value may result in undefined behavior.</description>
              <bitWidth>30</bitWidth>
              <bitOffset>2</bitOffset>
            </field>
            <field>
              <name>CAUSE_RESET</name>
              <description>[1:1] Indicates that the cause of an interrupt was a reset generated but blocked due to TEST.TEST_EN (only possible when TEST.TEST_EN is set).</description>
              <bitWidth>1</bitWidth>
              <bitOffset>1</bitOffset>
            </field>
            <field>
              <name>CAUSE_INTR</name>
              <description>[0:0] Replica of RIS.WDTRIS</description>
              <bitWidth>1</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
        <register>
          <name>LOCK</name>
          <addressOffset>0xc00</addressOffset>
          <size>32</size>
          <description>Lock</description>
          <fields>
            <field>
              <name>WDTLOCK</name>
              <description>[31:0] WDT Lock: A write of the value 0x1ACC.E551 unlocks the watchdog registers for write access. A write of any other value reapplies the lock, preventing any register updates (NOTE: TEST.TEST_EN bit is not lockable).  

A read of this register returns the following values: 

0x0000.0000: Unlocked
0x0000.0001:  Locked</description>
              <bitWidth>32</bitWidth>
              <bitOffset>0</bitOffset>
            </field>
          </fields>
          <resetValue>0x0</resetValue>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>